<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Antlr4.Runtime.Standard</name>
    </assembly>
    <members>
        <member name="T:Antlr4.Runtime.AntlrFileStream">
            <summary>
            This is an
            <see cref="T:Antlr4.Runtime.AntlrInputStream"/>
            that is loaded from a file all at once
            when you construct the object.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.AntlrFileStream.#ctor(System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Antlr4.Runtime.AntlrFileStream.#ctor(System.String,System.Text.Encoding)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Antlr4.Runtime.AntlrFileStream.Load(System.String,System.Text.Encoding)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="F:Antlr4.Runtime.BaseInputCharStream.n">
            <summary>How many characters are actually in the buffer</summary>
        </member>
        <member name="F:Antlr4.Runtime.BaseInputCharStream.p">
            <summary>0..n-1 index into string of next char</summary>
        </member>
        <member name="F:Antlr4.Runtime.BaseInputCharStream.name">
            <summary>What is name or source of this char stream?</summary>
        </member>
        <member name="M:Antlr4.Runtime.BaseInputCharStream.Reset">
            <summary>
            Reset the stream so that it's in the same state it was
            when the object was created *except* the data array is not
            touched.
            </summary>
            <remarks>
            Reset the stream so that it's in the same state it was
            when the object was created *except* the data array is not
            touched.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.BaseInputCharStream.Index">
            <summary>
            Return the current input symbol index 0..n where n indicates the
            last symbol has been read.
            </summary>
            <remarks>
            Return the current input symbol index 0..n where n indicates the
            last symbol has been read.  The index is the index of char to
            be returned from LA(1).
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.BaseInputCharStream.Mark">
            <summary>mark/release do nothing; we have entire buffer</summary>
        </member>
        <member name="M:Antlr4.Runtime.BaseInputCharStream.Seek(System.Int32)">
            <summary>
            consume() ahead until p==index; can't just set p=index as we must
            update line and charPositionInLine.
            </summary>
            <remarks>
            consume() ahead until p==index; can't just set p=index as we must
            update line and charPositionInLine. If we seek backwards, just set p
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.AntlrInputStream">
            <summary>
            Vacuum all input from a
            <see cref="T:System.IO.TextReader"/>
            /
            <see cref="T:System.IO.Stream"/>
            and then treat it
            like a
            <c>char[]</c>
            buffer. Can also pass in a
            <see cref="T:System.String"/>
            or
            <c>char[]</c>
            to use.
            <p>If you need encoding, pass in stream/reader with correct encoding.</p>
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.AntlrInputStream.data">
            <summary>The data being scanned</summary>
        </member>
        <member name="M:Antlr4.Runtime.AntlrInputStream.#ctor(System.String)">
            <summary>Copy data in string to a local char array</summary>
        </member>
        <member name="M:Antlr4.Runtime.AntlrInputStream.#ctor(System.Char[],System.Int32)">
            <summary>This is the preferred constructor for strings as no data is copied</summary>
        </member>
        <member name="M:Antlr4.Runtime.AntlrInputStream.#ctor(System.IO.TextReader)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Antlr4.Runtime.AntlrInputStream.#ctor(System.IO.TextReader,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Antlr4.Runtime.AntlrInputStream.#ctor(System.IO.TextReader,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Antlr4.Runtime.AntlrInputStream.#ctor(System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Antlr4.Runtime.AntlrInputStream.#ctor(System.IO.Stream,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Antlr4.Runtime.AntlrInputStream.#ctor(System.IO.Stream,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Antlr4.Runtime.AntlrInputStream.Load(System.IO.TextReader,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Antlr4.Runtime.CodePointCharStream">
             <summary>
             Alternative to
             <see cref="T:Antlr4.Runtime.AntlrInputStream"/>
             which treats the input as a series of Unicode code points,
             instead of a series of UTF-16 code units.
            
             Use this if you need to parse input which potentially contains
             Unicode values > U+FFFF.
             </summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.AbstractPredicateTransition">
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Atn.AmbiguityInfo">
            <summary>This class represents profiling event information for an ambiguity.</summary>
            <remarks>
            This class represents profiling event information for an ambiguity.
            Ambiguities are decisions where a particular input resulted in an SLL
            conflict, followed by LL prediction also reaching a conflict state
            (indicating a true ambiguity in the grammar).
            <p>
            This event may be reported during SLL prediction in cases where the
            conflicting SLL configuration set provides sufficient information to
            determine that the SLL conflict is truly an ambiguity. For example, if none
            of the ATN configurations in the conflicting SLL configuration set have
            traversed a global follow transition (i.e.
            <see cref="F:Antlr4.Runtime.Atn.ATNConfig.reachesIntoOuterContext"/>
            is
            <see langword="false"/>
            for all
            configurations), then the result of SLL prediction for that input is known to
            be equivalent to the result of LL prediction for that input.</p>
            <p>
            In some cases, the minimum represented alternative in the conflicting LL
            configuration set is not equal to the minimum represented alternative in the
            conflicting SLL configuration set. Grammars and inputs which result in this
            scenario are unable to use
            <see cref="F:Antlr4.Runtime.Atn.PredictionMode.SLL"/>
            , which in turn means
            they cannot use the two-stage parsing strategy to improve parsing performance
            for that input.</p>
            </remarks>
            <seealso cref="M:Antlr4.Runtime.Atn.ParserATNSimulator.ReportAmbiguity(Antlr4.Runtime.Dfa.DFA,Antlr4.Runtime.Dfa.DFAState,System.Int32,System.Int32,System.Boolean,Antlr4.Runtime.Sharpen.BitSet,Antlr4.Runtime.Atn.ATNConfigSet)"/>
            <seealso cref="M:Antlr4.Runtime.IParserErrorListener.ReportAmbiguity(Antlr4.Runtime.Parser,Antlr4.Runtime.Dfa.DFA,System.Int32,System.Int32,System.Boolean,Antlr4.Runtime.Sharpen.BitSet,Antlr4.Runtime.Atn.ATNConfigSet)"/>
            <since>4.3</since>
        </member>
        <member name="M:Antlr4.Runtime.Atn.AmbiguityInfo.#ctor(System.Int32,Antlr4.Runtime.Atn.SimulatorState,Antlr4.Runtime.ITokenStream,System.Int32,System.Int32)">
            <summary>
            Constructs a new instance of the
            <see cref="T:Antlr4.Runtime.Atn.AmbiguityInfo"/>
            class with the
            specified detailed ambiguity information.
            </summary>
            <param name="decision">The decision number</param>
            <param name="state">
            The final simulator state identifying the ambiguous
            alternatives for the current input
            </param>
            <param name="input">The input token stream</param>
            <param name="startIndex">The start index for the current prediction</param>
            <param name="stopIndex">
            The index at which the ambiguity was identified during
            prediction
            </param>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ArrayPredictionContext.parents">
            Parent can be null only if full ctx mode and we make an array
            from {@link #EMPTY} and non-empty. We merge {@link #EMPTY} by using null parent and
            returnState == {@link #EMPTY_RETURN_STATE}.
        </member>
        <member name="F:Antlr4.Runtime.Atn.ArrayPredictionContext.returnStates">
            Sorted for merge, no duplicates; if present,
            {@link #EMPTY_RETURN_STATE} is always last.
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATN.decisionToState">
            <summary>
            Each subrule/rule is a decision point and we must track them so we
            can go back later and build DFA predictors for them.
            </summary>
            <remarks>
            Each subrule/rule is a decision point and we must track them so we
            can go back later and build DFA predictors for them.  This includes
            all the rules, subrules, optional blocks, ()+, ()* etc...
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATN.ruleToStartState">
            <summary>Maps from rule index to starting state number.</summary>
            <remarks>Maps from rule index to starting state number.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATN.ruleToStopState">
            <summary>Maps from rule index to stop state number.</summary>
            <remarks>Maps from rule index to stop state number.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATN.grammarType">
            <summary>The type of the ATN.</summary>
            <remarks>The type of the ATN.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATN.maxTokenType">
            <summary>The maximum value for any symbol recognized by a transition in the ATN.</summary>
            <remarks>The maximum value for any symbol recognized by a transition in the ATN.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATN.ruleToTokenType">
            <summary>For lexer ATNs, this maps the rule index to the resulting token type.</summary>
            <remarks>
            For lexer ATNs, this maps the rule index to the resulting token type.
            For parser ATNs, this maps the rule index to the generated bypass token
            type if the
            <see cref="P:Antlr4.Runtime.Atn.ATNDeserializationOptions.GenerateRuleBypassTransitions"/>
            deserialization option was specified; otherwise, this is
            <see langword="null"/>
            .
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATN.lexerActions">
            <summary>
            For lexer ATNs, this is an array of
            <see cref="T:Antlr4.Runtime.Atn.ILexerAction"/>
            objects which may
            be referenced by action transitions in the ATN.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ATN.#ctor(Antlr4.Runtime.Atn.ATNType,System.Int32)">
            <summary>Used for runtime deserialization of ATNs from strings</summary>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ATN.NextTokens(Antlr4.Runtime.Atn.ATNState,Antlr4.Runtime.RuleContext)">
            <summary>
            Compute the set of valid tokens that can occur starting in state
            <paramref name="s"/>
            .
            If
            <paramref name="ctx"/>
            is
            <see cref="F:Antlr4.Runtime.Atn.PredictionContext.EMPTY"/>
            , the set of tokens will not include what can follow
            the rule surrounding
            <paramref name="s"/>
            . In other words, the set will be
            restricted to tokens reachable staying within
            <paramref name="s"/>
            's rule.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ATN.NextTokens(Antlr4.Runtime.Atn.ATNState)">
            <summary>
            Compute the set of valid tokens that can occur starting in
            <paramref name="s"/>
            and
            staying in same rule.
            <see cref="F:Antlr4.Runtime.TokenConstants.EPSILON"/>
            is in set if we reach end of
            rule.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ATN.GetExpectedTokens(System.Int32,Antlr4.Runtime.RuleContext)">
            <summary>
            Computes the set of input symbols which could follow ATN state number
            <paramref name="stateNumber"/>
            in the specified full
            <paramref name="context"/>
            . This method
            considers the complete parser context, but does not evaluate semantic
            predicates (i.e. all predicates encountered during the calculation are
            assumed true). If a path in the ATN exists from the starting state to the
            <see cref="T:Antlr4.Runtime.Atn.RuleStopState"/>
            of the outermost context without matching any
            symbols,
            <see cref="F:Antlr4.Runtime.TokenConstants.EOF"/>
            is added to the returned set.
            <p>If
            <paramref name="context"/>
            is
            <see langword="null"/>
            , it is treated as
            <see cref="P:Antlr4.Runtime.ParserRuleContext.EmptyContext"/>
            .</p>
            </summary>
            <param name="stateNumber">the ATN state number</param>
            <param name="context">the full parse context</param>
            <returns>
            The set of potentially valid input symbols which could follow the
            specified state in the specified context.
            </returns>
            <exception cref="T:System.ArgumentException">
            if the ATN does not contain a state with
            number
            <paramref name="stateNumber"/>
            </exception>
        </member>
        <member name="T:Antlr4.Runtime.Atn.ATNConfig">
            A tuple: (ATN state, predicted alt, syntactic, semantic context).
            The syntactic context is a graph-structured stack node whose
            path(s) to the root is the rule invocation(s)
            chain used to arrive at the state.  The semantic context is
            the tree of semantic predicates encountered before reaching
            an ATN state.
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNConfig.SUPPRESS_PRECEDENCE_FILTER">
            This field stores the bit mask for implementing the
            {@link #isPrecedenceFilterSuppressed} property as a bit within the
            existing {@link #reachesIntoOuterContext} field.
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNConfig.state">
            The ATN state associated with this configuration 
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNConfig.alt">
            What alt (or lexer rule) is predicted by this configuration 
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNConfig.context">
            The stack of invoking states leading to the rule/states associated
            with this config.  We track only those contexts pushed during
            execution of the ATN simulator.
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNConfig.reachesIntoOuterContext">
             We cannot execute predicates dependent upon local context unless
             we know for sure we are in the correct context. Because there is
             no way to do this efficiently, we simply cannot evaluate
             dependent predicates unless we are in the rule that initially
             invokes the ATN simulator.
            
             <p>
             closure() tracks the depth of how far we dip into the outer context:
             depth &gt; 0.  Note that it may not be totally accurate depth since I
             don't ever decrement. TODO: make it a boolean then</p>
            
             <p>
             For memory efficiency, the {@link #isPrecedenceFilterSuppressed} method
             is also backed by this field. Since the field is publicly accessible, the
             highest bit which would not cause the value to become negative is used to
             store this field. This choice minimizes the risk that code which only
             compares this value to 0 would be affected by the new purpose of the
             flag. It also ensures the performance of the existing {@link ATNConfig}
             constructors as well as certain operations like
             {@link ATNConfigSet#add(ATNConfig, DoubleKeyMap)} method are
             <em>completely</em> unaffected by the change.</p>
        </member>
        <member name="P:Antlr4.Runtime.Atn.ATNConfig.OuterContextDepth">
            This method gets the value of the {@link #reachesIntoOuterContext} field
            as it existed prior to the introduction of the
            {@link #isPrecedenceFilterSuppressed} method.
        </member>
        <member name="M:Antlr4.Runtime.Atn.ATNConfig.Equals(System.Object)">
            An ATN configuration is equal to another if both have
            the same state, they predict the same alternative, and
            syntactic/semantic contexts are the same.
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNConfigSet.readOnly">
            Indicates that the set of configurations is read-only. Do not
            allow any code to manipulate the set; DFA states will point at
            the sets and they must not change. This does not protect the other
            fields; in particular, conflictingAlts is set after
            we've made this readonly.
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNConfigSet.configLookup">
            All configs but hashed by (s, i, _, pi) not including context. Wiped out
            when we go readonly as this set becomes a DFA state.
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNConfigSet.configs">
            Track the elements as they are added to the set; supports get(i) 
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNConfigSet.conflictingAlts">
            Currently this is only used when we detect SLL conflict; this does
            not necessarily represent the ambiguous alternatives. In fact,
            I should also point out that this seems to include predicated alternatives
            that have predicates that evaluate to false. Computed in computeTargetState().
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNConfigSet.fullCtx">
            Indicates that this configuration set is part of a full context
            LL prediction. It will be used to determine how to merge $. With SLL
            it's a wildcard whereas it is not for LL context merge.
        </member>
        <member name="M:Antlr4.Runtime.Atn.ATNConfigSet.Add(Antlr4.Runtime.Atn.ATNConfig,Antlr4.Runtime.Atn.MergeCache)">
             Adding a new config means merging contexts with existing configs for
             {@code (s, i, pi, _)}, where {@code s} is the
             {@link ATNConfig#state}, {@code i} is the {@link ATNConfig#alt}, and
             {@code pi} is the {@link ATNConfig#semanticContext}. We use
             {@code (s,i,pi)} as key.
            
             <p>This method updates {@link #dipsIntoOuterContext} and
             {@link #hasSemanticContext} when necessary.</p>
        </member>
        <member name="P:Antlr4.Runtime.Atn.ATNConfigSet.Elements">
            Return a List holding list of configs 
        </member>
        <member name="M:Antlr4.Runtime.Atn.ATNConfigSet.GetAlts">
             Gets the complete set of represented alternatives for the configuration
             set.
            
             @return the set of represented alternatives in this configuration set
            
             @since 4.3
        </member>
        <member name="T:Antlr4.Runtime.Atn.ConfigHashSet">
            The reason that we need this is because we don't want the hash map to use
            the standard hash code and equals. We need all configurations with the same
            {@code (s,i,_,semctx)} to be equal. Unfortunately, this key effectively doubles
            the number of objects associated with ATNConfigs. The other solution is to
            use a hash table that lets us specify the equals/hashcode operation.
        </member>
        <member name="T:Antlr4.Runtime.Atn.ATNDeserializationOptions">
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Atn.ATNDeserializer">
            <author>Sam Harwell</author>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNDeserializer.BaseSerializedUuid">
            <summary>This is the earliest supported serialized UUID.</summary>
            <remarks>This is the earliest supported serialized UUID.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNDeserializer.AddedUnicodeSmp">
            <summary>
            This UUID indicates the serialized ATN contains two sets of
            IntervalSets, where the second set's values are encoded as
            32-bit integers to support the full Unicode SMP range up to U+10FFFF.
            </summary>
            <remarks>
            This UUID indicates the serialized ATN contains two sets of
            IntervalSets, where the second set's values are encoded as
            32-bit integers to support the full Unicode SMP range up to U+10FFFF.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNDeserializer.SupportedUuids">
            <summary>
            This list contains all of the currently supported UUIDs, ordered by when
            the feature first appeared in this branch.
            </summary>
            <remarks>
            This list contains all of the currently supported UUIDs, ordered by when
            the feature first appeared in this branch.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNDeserializer.SerializedUuid">
            <summary>This is the current serialized UUID.</summary>
            <remarks>This is the current serialized UUID.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ATNDeserializer.IsFeatureSupported(System.Guid,System.Guid)">
             <summary>
             Determines if a particular serialized representation of an ATN supports
             a particular feature, identified by the
             <see cref="T:System.Guid"/>
             used for serializing
             the ATN at the time the feature was first introduced.
             </summary>
             <param name="feature">
             The
             <see cref="T:System.Guid"/>
             marking the first time the feature was
             supported in the serialized ATN.
             </param>
             <param name="actualUuid">
             The
             <see cref="T:System.Guid"/>
             of the actual serialized ATN which is
             currently being deserialized.
             </param>
             <returns>
            
             <see langword="true"/>
             if the
             <paramref name="actualUuid"/>
             value represents a
             serialized ATN at or after the feature identified by
             <paramref name="feature"/>
             was
             introduced; otherwise,
             <see langword="false"/>
             .
             </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ATNDeserializer.MarkPrecedenceDecisions(Antlr4.Runtime.Atn.ATN)">
            <summary>
            Analyze the
            <see cref="T:Antlr4.Runtime.Atn.StarLoopEntryState"/>
            states in the specified ATN to set
            the
            <see cref="F:Antlr4.Runtime.Atn.StarLoopEntryState.isPrecedenceDecision"/>
            field to the
            correct value.
            </summary>
            <param name="atn">The ATN.</param>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNSimulator.ERROR">
            Must distinguish between missing edge and edge we know leads nowhere 
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNSimulator.sharedContextCache">
            The context cache maps all PredictionContext objects that are equals()
              to a single cached copy. This cache is shared across all contexts
              in all ATNConfigs in all DFA states.  We rebuild each ATNConfigSet
              to use only cached nodes/graphs in addDFAState(). We don't want to
              fill this during closure() since there are lots of contexts that
              pop up but are not used ever again. It also greatly slows down closure().
            
              <p>This cache makes a huge difference in memory and a little bit in speed.
              For the Java grammar on java.*, it dropped the memory requirements
              at the end from 25M to 16M. We don't store any of the full context
              graphs in the DFA because they are limited to local context only,
              but apparently there's a lot of repetition there as well. We optimize
              the config contexts before storing the config set in the DFA states
              by literally rebuilding them with cached subgraphs only.</p>
            
              <p>I tried a cache for use during closure operations, that was
              whacked after each adaptivePredict(). It cost a little bit
              more time I think and doesn't save on the overall footprint
              so it's not worth the complexity.</p>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ATNSimulator.ClearDFA">
             Clear the DFA cache used by the current instance. Since the DFA cache may
             be shared by multiple ATN simulators, this method may affect the
             performance (but not accuracy) of other parsers which are being used
             concurrently.
            
             @throws UnsupportedOperationException if the current instance does not
             support clearing the DFA.
            
             @since 4.3
        </member>
        <member name="T:Antlr4.Runtime.Atn.ATNType">
            <summary>Represents the type of recognizer an ATN applies to.</summary>
            <remarks>Represents the type of recognizer an ATN applies to.</remarks>
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Atn.AtomTransition">
            <summary>TODO: make all transitions sets? no, should remove set edges</summary>
        </member>
        <member name="F:Antlr4.Runtime.Atn.AtomTransition.token">
            <summary>The token type or character value; or, signifies special label.</summary>
            <remarks>The token type or character value; or, signifies special label.</remarks>
        </member>
        <member name="T:Antlr4.Runtime.Atn.BasicBlockStartState">
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Atn.BasicState">
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Atn.BlockEndState">
            <summary>
            Terminal node of a simple
            <c>(a|b|c)</c>
            block.
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.BlockStartState">
            <summary>
            The start of a regular
            <c>(...)</c>
            block.
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.ConflictInfo">
            <summary>This class stores information about a configuration conflict.</summary>
            <author>Sam Harwell</author>
        </member>
        <member name="P:Antlr4.Runtime.Atn.ConflictInfo.ConflictedAlts">
            <summary>Gets the set of conflicting alternatives for the configuration set.</summary>
            <remarks>Gets the set of conflicting alternatives for the configuration set.</remarks>
        </member>
        <member name="P:Antlr4.Runtime.Atn.ConflictInfo.IsExact">
            <summary>Gets whether or not the configuration conflict is an exact conflict.</summary>
            <remarks>
            Gets whether or not the configuration conflict is an exact conflict.
            An exact conflict occurs when the prediction algorithm determines that
            the represented alternatives for a particular configuration set cannot be
            further reduced by consuming additional input. After reaching an exact
            conflict during an SLL prediction, only switch to full-context prediction
            could reduce the set of viable alternatives. In LL prediction, an exact
            conflict indicates a true ambiguity in the input.
            <p>
            For the
            <see cref="F:Antlr4.Runtime.Atn.PredictionMode.LL_EXACT_AMBIG_DETECTION"/>
            prediction mode,
            accept states are conflicting but not exact are treated as non-accept
            states.</p>
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.Atn.ContextSensitivityInfo">
            <summary>This class represents profiling event information for a context sensitivity.</summary>
            <remarks>
            This class represents profiling event information for a context sensitivity.
            Context sensitivities are decisions where a particular input resulted in an
            SLL conflict, but LL prediction produced a single unique alternative.
            <p>
            In some cases, the unique alternative identified by LL prediction is not
            equal to the minimum represented alternative in the conflicting SLL
            configuration set. Grammars and inputs which result in this scenario are
            unable to use
            <see cref="F:Antlr4.Runtime.Atn.PredictionMode.SLL"/>
            , which in turn means they cannot use
            the two-stage parsing strategy to improve parsing performance for that
            input.</p>
            </remarks>
            <seealso cref="M:Antlr4.Runtime.Atn.ParserATNSimulator.ReportContextSensitivity(Antlr4.Runtime.Dfa.DFA,System.Int32,Antlr4.Runtime.Atn.ATNConfigSet,System.Int32,System.Int32)"/>
            <seealso cref="M:Antlr4.Runtime.IParserErrorListener.ReportContextSensitivity(Antlr4.Runtime.Parser,Antlr4.Runtime.Dfa.DFA,System.Int32,System.Int32,System.Int32,Antlr4.Runtime.Atn.SimulatorState)"/>
            <since>4.3</since>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ContextSensitivityInfo.#ctor(System.Int32,Antlr4.Runtime.Atn.SimulatorState,Antlr4.Runtime.ITokenStream,System.Int32,System.Int32)">
            <summary>
            Constructs a new instance of the
            <see cref="T:Antlr4.Runtime.Atn.ContextSensitivityInfo"/>
            class
            with the specified detailed context sensitivity information.
            </summary>
            <param name="decision">The decision number</param>
            <param name="state">
            The final simulator state containing the unique
            alternative identified by full-context prediction
            </param>
            <param name="input">The input token stream</param>
            <param name="startIndex">The start index for the current prediction</param>
            <param name="stopIndex">
            The index at which the context sensitivity was
            identified during full-context prediction
            </param>
        </member>
        <member name="T:Antlr4.Runtime.Atn.DecisionEventInfo">
            <summary>
            This is the base class for gathering detailed information about prediction
            events which occur during parsing.
            </summary>
            <remarks>
            This is the base class for gathering detailed information about prediction
            events which occur during parsing.
            </remarks>
            <since>4.3</since>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionEventInfo.decision">
            <summary>The invoked decision number which this event is related to.</summary>
            <remarks>The invoked decision number which this event is related to.</remarks>
            <seealso cref="F:Antlr4.Runtime.Atn.ATN.decisionToState"/>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionEventInfo.state">
            <summary>
            The simulator state containing additional information relevant to the
            prediction state when the current event occurred, or
            <see langword="null"/>
            if no
            additional information is relevant or available.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionEventInfo.input">
            <summary>The input token stream which is being parsed.</summary>
            <remarks>The input token stream which is being parsed.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionEventInfo.startIndex">
            <summary>
            The token index in the input stream at which the current prediction was
            originally invoked.
            </summary>
            <remarks>
            The token index in the input stream at which the current prediction was
            originally invoked.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionEventInfo.stopIndex">
            <summary>The token index in the input stream at which the current event occurred.</summary>
            <remarks>The token index in the input stream at which the current event occurred.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionEventInfo.fullCtx">
            <summary>
            <see langword="true"/>
            if the current event occurred during LL prediction;
            otherwise,
            <see langword="false"/>
            if the input occurred during SLL prediction.
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.DecisionInfo">
            <summary>This class contains profiling gathered for a particular decision.</summary>
            <remarks>
            This class contains profiling gathered for a particular decision.
            <p>
            Parsing performance in ANTLR 4 is heavily influenced by both static factors
            (e.g. the form of the rules in the grammar) and dynamic factors (e.g. the
            choice of input and the state of the DFA cache at the time profiling
            operations are started). For best results, gather and use aggregate
            statistics from a large sample of inputs representing the inputs expected in
            production before using the results to make changes in the grammar.</p>
            </remarks>
            <since>4.3</since>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.decision">
            The decision number, which is an index into {@link ATN#decisionToState}.
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.invocations">
            The total number of times {@link ParserATNSimulator#adaptivePredict} was
            invoked for this decision.
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.timeInPrediction">
             The total time spent in {@link ParserATNSimulator#adaptivePredict} for
             this decision, in nanoseconds.
            
             <p>
             The value of this field contains the sum of differential results obtained
             by {@link System#nanoTime()}, and is not adjusted to compensate for JIT
             and/or garbage collection overhead. For best accuracy, use a modern JVM
             implementation that provides precise results from
             {@link System#nanoTime()}, and perform profiling in a separate process
             which is warmed up by parsing the input prior to profiling. If desired,
             call {@link ATNSimulator#clearDFA} to reset the DFA cache to its initial
             state before starting the profiling measurement pass.</p>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.SLL_TotalLook">
            The sum of the lookahead required for SLL prediction for this decision.
            Note that SLL prediction is used before LL prediction for performance
            reasons even when {@link PredictionMode#LL} or
            {@link PredictionMode#LL_EXACT_AMBIG_DETECTION} is used.
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.SLL_MinLook">
            Gets the minimum lookahead required for any single SLL prediction to
            complete for this decision, by reaching a unique prediction, reaching an
            SLL conflict state, or encountering a syntax error.
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.SLL_MaxLook">
            Gets the maximum lookahead required for any single SLL prediction to
            complete for this decision, by reaching a unique prediction, reaching an
            SLL conflict state, or encountering a syntax error.
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.SLL_MaxLookEvent">
            Gets the {@link LookaheadEventInfo} associated with the event where the
            {@link #SLL_MaxLook} value was set.
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.LL_TotalLook">
            The sum of the lookahead required for LL prediction for this decision.
            Note that LL prediction is only used when SLL prediction reaches a
            conflict state.
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.LL_MinLook">
            Gets the minimum lookahead required for any single LL prediction to
            complete for this decision. An LL prediction completes when the algorithm
            reaches a unique prediction, a conflict state (for
            {@link PredictionMode#LL}, an ambiguity state (for
            {@link PredictionMode#LL_EXACT_AMBIG_DETECTION}, or a syntax error.
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.LL_MaxLook">
            Gets the maximum lookahead required for any single LL prediction to
            complete for this decision. An LL prediction completes when the algorithm
            reaches a unique prediction, a conflict state (for
            {@link PredictionMode#LL}, an ambiguity state (for
            {@link PredictionMode#LL_EXACT_AMBIG_DETECTION}, or a syntax error.
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.LL_MaxLookEvent">
            Gets the {@link LookaheadEventInfo} associated with the event where the
            {@link #LL_MaxLook} value was set.
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.contextSensitivities">
             A collection of {@link ContextSensitivityInfo} instances describing the
             context sensitivities encountered during LL prediction for this decision.
            
             @see ContextSensitivityInfo
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.errors">
             A collection of {@link ErrorInfo} instances describing the parse errors
             identified during calls to {@link ParserATNSimulator#adaptivePredict} for
             this decision.
            
             @see ErrorInfo
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.ambiguities">
             A collection of {@link AmbiguityInfo} instances describing the
             ambiguities encountered during LL prediction for this decision.
            
             @see AmbiguityInfo
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.predicateEvals">
             A collection of {@link PredicateEvalInfo} instances describing the
             results of evaluating individual predicates during prediction for this
             decision.
            
             @see PredicateEvalInfo
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.SLL_ATNTransitions">
             The total number of ATN transitions required during SLL prediction for
             this decision. An ATN transition is determined by the number of times the
             DFA does not contain an edge that is required for prediction, resulting
             in on-the-fly computation of that edge.
            
             <p>
             If DFA caching of SLL transitions is employed by the implementation, ATN
             computation may cache the computed edge for efficient lookup during
             future parsing of this decision. Otherwise, the SLL parsing algorithm
             will use ATN transitions exclusively.</p>
            
             @see #SLL_ATNTransitions
             @see ParserATNSimulator#computeTargetState
             @see LexerATNSimulator#computeTargetState
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.SLL_DFATransitions">
             The total number of DFA transitions required during SLL prediction for
             this decision.
            
             <p>If the ATN simulator implementation does not use DFA caching for SLL
             transitions, this value will be 0.</p>
            
             @see ParserATNSimulator#getExistingTargetState
             @see LexerATNSimulator#getExistingTargetState
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.LL_Fallback">
             Gets the total number of times SLL prediction completed in a conflict
             state, resulting in fallback to LL prediction.
            
             <p>Note that this value is not related to whether or not
             {@link PredictionMode#SLL} may be used successfully with a particular
             grammar. If the ambiguity resolution algorithm applied to the SLL
             conflicts for this decision produce the same result as LL prediction for
             this decision, {@link PredictionMode#SLL} would produce the same overall
             parsing result as {@link PredictionMode#LL}.</p>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.LL_ATNTransitions">
             The total number of ATN transitions required during LL prediction for
             this decision. An ATN transition is determined by the number of times the
             DFA does not contain an edge that is required for prediction, resulting
             in on-the-fly computation of that edge.
            
             <p>
             If DFA caching of LL transitions is employed by the implementation, ATN
             computation may cache the computed edge for efficient lookup during
             future parsing of this decision. Otherwise, the LL parsing algorithm will
             use ATN transitions exclusively.</p>
            
             @see #LL_DFATransitions
             @see ParserATNSimulator#computeTargetState
             @see LexerATNSimulator#computeTargetState
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.LL_DFATransitions">
             The total number of DFA transitions required during LL prediction for
             this decision.
            
             <p>If the ATN simulator implementation does not use DFA caching for LL
             transitions, this value will be 0.</p>
            
             @see ParserATNSimulator#getExistingTargetState
             @see LexerATNSimulator#getExistingTargetState
        </member>
        <member name="M:Antlr4.Runtime.Atn.DecisionInfo.#ctor(System.Int32)">
             Constructs a new instance of the {@link DecisionInfo} class to contain
             statistics for a particular decision.
            
             @param decision The decision number
        </member>
        <member name="P:Antlr4.Runtime.Atn.EpsilonTransition.OutermostPrecedenceReturn">
            <returns>
            the rule index of a precedence rule for which this transition is
            returning from, where the precedence value is 0; otherwise, -1.
            </returns>
            <seealso cref="P:Antlr4.Runtime.Atn.ATNConfig.IsPrecedenceFilterSuppressed"/>
            <seealso cref="M:Antlr4.Runtime.Atn.ParserATNSimulator.ApplyPrecedenceFilter(Antlr4.Runtime.Atn.ATNConfigSet)"/>
            <since>4.4.1</since>
        </member>
        <member name="T:Antlr4.Runtime.Atn.ErrorInfo">
            <summary>
            This class represents profiling event information for a syntax error
            identified during prediction.
            </summary>
            <remarks>
            This class represents profiling event information for a syntax error
            identified during prediction. Syntax errors occur when the prediction
            algorithm is unable to identify an alternative which would lead to a
            successful parse.
            </remarks>
            <seealso cref="M:Antlr4.Runtime.Parser.NotifyErrorListeners(Antlr4.Runtime.IToken,System.String,Antlr4.Runtime.RecognitionException)"/>
            <seealso cref="M:Antlr4.Runtime.IAntlrErrorListener`1.SyntaxError(System.IO.TextWriter,Antlr4.Runtime.IRecognizer,`0,System.Int32,System.Int32,System.String,Antlr4.Runtime.RecognitionException)"/>
            <since>4.3</since>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ErrorInfo.#ctor(System.Int32,Antlr4.Runtime.Atn.SimulatorState,Antlr4.Runtime.ITokenStream,System.Int32,System.Int32)">
            <summary>
            Constructs a new instance of the
            <see cref="T:Antlr4.Runtime.Atn.ErrorInfo"/>
            class with the
            specified detailed syntax error information.
            </summary>
            <param name="decision">The decision number</param>
            <param name="state">
            The final simulator state reached during prediction
            prior to reaching the
            <see cref="F:Antlr4.Runtime.Atn.ATNSimulator.ERROR"/>
            state
            </param>
            <param name="input">The input token stream</param>
            <param name="startIndex">The start index for the current prediction</param>
            <param name="stopIndex">The index at which the syntax error was identified</param>
        </member>
        <member name="T:Antlr4.Runtime.Atn.ILexerAction">
            <summary>
            Represents a single action which can be executed following the successful
            match of a lexer rule.
            </summary>
            <remarks>
            Represents a single action which can be executed following the successful
            match of a lexer rule. Lexer actions are used for both embedded action syntax
            and ANTLR 4's new lexer command syntax.
            </remarks>
            <author>Sam Harwell</author>
            <since>4.2</since>
        </member>
        <member name="P:Antlr4.Runtime.Atn.ILexerAction.ActionType">
            <summary>Gets the serialization type of the lexer action.</summary>
            <remarks>Gets the serialization type of the lexer action.</remarks>
            <returns>The serialization type of the lexer action.</returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.ILexerAction.IsPositionDependent">
             <summary>Gets whether the lexer action is position-dependent.</summary>
             <remarks>
             Gets whether the lexer action is position-dependent. Position-dependent
             actions may have different semantics depending on the
             <see cref="T:Antlr4.Runtime.ICharStream"/>
             index at the time the action is executed.
             <p>Many lexer commands, including
             <c>type</c>
             ,
             <c>skip</c>
             , and
             <c>more</c>
             , do not check the input index during their execution.
             Actions like this are position-independent, and may be stored more
             efficiently as part of the
             <see cref="F:Antlr4.Runtime.Atn.LexerATNConfig.lexerActionExecutor"/>
             .</p>
             </remarks>
             <returns>
            
             <see langword="true"/>
             if the lexer action semantics can be affected by the
             position of the input
             <see cref="T:Antlr4.Runtime.ICharStream"/>
             at the time it is executed;
             otherwise,
             <see langword="false"/>
             .
             </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ILexerAction.Execute(Antlr4.Runtime.Lexer)">
            <summary>
            Execute the lexer action in the context of the specified
            <see cref="T:Antlr4.Runtime.Lexer"/>
            .
            <p>For position-dependent actions, the input stream must already be
            positioned correctly prior to calling this method.</p>
            </summary>
            <param name="lexer">The lexer instance.</param>
        </member>
        <member name="T:Antlr4.Runtime.Atn.LexerActionExecutor">
            <summary>
            Represents an executor for a sequence of lexer actions which traversed during
            the matching operation of a lexer rule (token).
            </summary>
            <remarks>
            Represents an executor for a sequence of lexer actions which traversed during
            the matching operation of a lexer rule (token).
            <p>The executor tracks position information for position-dependent lexer actions
            efficiently, ensuring that actions appearing only at the end of the rule do
            not cause bloating of the
            <see cref="T:Antlr4.Runtime.Dfa.DFA"/>
            created for the lexer.</p>
            </remarks>
            <author>Sam Harwell</author>
            <since>4.2</since>
        </member>
        <member name="F:Antlr4.Runtime.Atn.LexerActionExecutor.hashCode">
            <summary>
            Caches the result of
            <see cref="F:Antlr4.Runtime.Atn.LexerActionExecutor.hashCode"/>
            since the hash code is an element
            of the performance-critical
            <see cref="M:Antlr4.Runtime.Atn.ATNConfig.GetHashCode"/>
            operation.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerActionExecutor.#ctor(Antlr4.Runtime.Atn.ILexerAction[])">
            <summary>
            Constructs an executor for a sequence of
            <see cref="T:Antlr4.Runtime.Atn.ILexerAction"/>
            actions.
            </summary>
            <param name="lexerActions">The lexer actions to execute.</param>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerActionExecutor.Append(Antlr4.Runtime.Atn.LexerActionExecutor,Antlr4.Runtime.Atn.ILexerAction)">
            <summary>
            Creates a
            <see cref="T:Antlr4.Runtime.Atn.LexerActionExecutor"/>
            which executes the actions for
            the input
            <paramref name="lexerActionExecutor"/>
            followed by a specified
            <paramref name="lexerAction"/>
            .
            </summary>
            <param name="lexerActionExecutor">
            The executor for actions already traversed by
            the lexer while matching a token within a particular
            <see cref="T:Antlr4.Runtime.Atn.ATNConfig"/>
            . If this is
            <see langword="null"/>
            , the method behaves as though
            it were an empty executor.
            </param>
            <param name="lexerAction">
            The lexer action to execute after the actions
            specified in
            <paramref name="lexerActionExecutor"/>
            .
            </param>
            <returns>
            A
            <see cref="T:Antlr4.Runtime.Atn.LexerActionExecutor"/>
            for executing the combine actions
            of
            <paramref name="lexerActionExecutor"/>
            and
            <paramref name="lexerAction"/>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerActionExecutor.FixOffsetBeforeMatch(System.Int32)">
            <summary>
            Creates a
            <see cref="T:Antlr4.Runtime.Atn.LexerActionExecutor"/>
            which encodes the current offset
            for position-dependent lexer actions.
            <p>Normally, when the executor encounters lexer actions where
            <see cref="P:Antlr4.Runtime.Atn.ILexerAction.IsPositionDependent"/>
            returns
            <see langword="true"/>
            , it calls
            <see cref="M:Antlr4.Runtime.IIntStream.Seek(System.Int32)"/>
            on the input
            <see cref="T:Antlr4.Runtime.ICharStream"/>
            to set the input
            position to the <em>end</em> of the current token. This behavior provides
            for efficient DFA representation of lexer actions which appear at the end
            of a lexer rule, even when the lexer rule matches a variable number of
            characters.</p>
            <p>Prior to traversing a match transition in the ATN, the current offset
            from the token start index is assigned to all position-dependent lexer
            actions which have not already been assigned a fixed offset. By storing
            the offsets relative to the token start index, the DFA representation of
            lexer actions which appear in the middle of tokens remains efficient due
            to sharing among tokens of the same length, regardless of their absolute
            position in the input stream.</p>
            <p>If the current executor already has offsets assigned to all
            position-dependent lexer actions, the method returns
            <c>this</c>
            .</p>
            </summary>
            <param name="offset">
            The current offset to assign to all position-dependent
            lexer actions which do not already have offsets assigned.
            </param>
            <returns>
            A
            <see cref="T:Antlr4.Runtime.Atn.LexerActionExecutor"/>
            which stores input stream offsets
            for all position-dependent lexer actions.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerActionExecutor.LexerActions">
            <summary>Gets the lexer actions to be executed by this executor.</summary>
            <remarks>Gets the lexer actions to be executed by this executor.</remarks>
            <returns>The lexer actions to be executed by this executor.</returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerActionExecutor.Execute(Antlr4.Runtime.Lexer,Antlr4.Runtime.ICharStream,System.Int32)">
             <summary>
             Execute the actions encapsulated by this executor within the context of a
             particular
             <see cref="T:Antlr4.Runtime.Lexer"/>
             .
             <p>This method calls
             <see cref="M:Antlr4.Runtime.IIntStream.Seek(System.Int32)"/>
             to set the position of the
             <paramref name="input"/>
            
             <see cref="T:Antlr4.Runtime.ICharStream"/>
             prior to calling
             <see cref="M:Antlr4.Runtime.Atn.ILexerAction.Execute(Antlr4.Runtime.Lexer)"/>
             on a position-dependent action. Before the
             method returns, the input position will be restored to the same position
             it was in when the method was invoked.</p>
             </summary>
             <param name="lexer">The lexer instance.</param>
             <param name="input">
             The input stream which is the source for the current token.
             When this method is called, the current
             <see cref="P:Antlr4.Runtime.IIntStream.Index"/>
             for
             <paramref name="input"/>
             should be the start of the following token, i.e. 1
             character past the end of the current token.
             </param>
             <param name="startIndex">
             The token start index. This value may be passed to
             <see cref="M:Antlr4.Runtime.IIntStream.Seek(System.Int32)"/>
             to set the
             <paramref name="input"/>
             position to the beginning
             of the token.
             </param>
        </member>
        <member name="T:Antlr4.Runtime.Atn.LexerActionType">
            <author>Sam Harwell</author>
            <since>4.2</since>
        </member>
        <member name="F:Antlr4.Runtime.Atn.LexerATNConfig.lexerActionExecutor">
            This is the backing field for {@link #getLexerActionExecutor}.
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerATNConfig.getLexerActionExecutor">
            Gets the {@link LexerActionExecutor} capable of executing the embedded
            action(s) for the current configuration.
        </member>
        <member name="T:Antlr4.Runtime.Atn.LexerATNSimulator">
            <summary>"dup" of ParserInterpreter</summary>
        </member>
        <member name="F:Antlr4.Runtime.Atn.LexerATNSimulator.startIndex">
            The current token's starting index into the character stream.
            Shared across DFA to ATN simulation in case the ATN fails and the
            DFA did not have a previous accept state. In this case, we use the
            ATN-generated exception object.
        </member>
        <member name="F:Antlr4.Runtime.Atn.LexerATNSimulator.thisLine">
            line number 1..n within the input 
        </member>
        <member name="F:Antlr4.Runtime.Atn.LexerATNSimulator.charPositionInLine">
            The index of the character relative to the beginning of the line 0..n-1 
        </member>
        <member name="F:Antlr4.Runtime.Atn.LexerATNSimulator.prevAccept">
            Used during DFA/ATN exec to record the most recent accept configuration info 
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerATNSimulator.GetExistingTargetState(Antlr4.Runtime.Dfa.DFAState,System.Int32)">
             Get an existing target state for an edge in the DFA. If the target state
             for the edge has not yet been computed or is otherwise not available,
             this method returns {@code null}.
            
             @param s The current DFA state
             @param t The next input symbol
             @return The existing target DFA state for the given input symbol
             {@code t}, or {@code null} if the target state for this edge is not
             already cached
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerATNSimulator.ComputeTargetState(Antlr4.Runtime.ICharStream,Antlr4.Runtime.Dfa.DFAState,System.Int32)">
             Compute a target state for an edge in the DFA, and attempt to add the
             computed state and corresponding edge to the DFA.
            
             @param input The input stream
             @param s The current DFA state
             @param t The next input symbol
            
             @return The computed target DFA state for the given input symbol
             {@code t}. If {@code t} does not lead to a valid DFA state, this method
             returns {@link #ERROR}.
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerATNSimulator.GetReachableConfigSet(Antlr4.Runtime.ICharStream,Antlr4.Runtime.Atn.ATNConfigSet,Antlr4.Runtime.Atn.ATNConfigSet,System.Int32)">
            Given a starting configuration set, figure out all ATN configurations
            we can reach upon input {@code t}. Parameter {@code reach} is a return
            parameter.
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerATNSimulator.Closure(Antlr4.Runtime.ICharStream,Antlr4.Runtime.Atn.LexerATNConfig,Antlr4.Runtime.Atn.ATNConfigSet,System.Boolean,System.Boolean,System.Boolean)">
             Since the alternatives within any lexer decision are ordered by
             preference, this method stops pursuing the closure as soon as an accept
             state is reached. After the first accept state is reached by depth-first
             search from {@code config}, all other (potentially reachable) states for
             this rule would have a lower priority.
            
             @return {@code true} if an accept state is reached, otherwise
             {@code false}.
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerATNSimulator.EvaluatePredicate(Antlr4.Runtime.ICharStream,System.Int32,System.Int32,System.Boolean)">
             Evaluate a predicate specified in the lexer.
            
             <p>If {@code speculative} is {@code true}, this method was called before
             {@link #consume} for the matched character. This method should call
             {@link #consume} before evaluating the predicate to ensure position
             sensitive values, including {@link Lexer#getText}, {@link Lexer#getLine},
             and {@link Lexer#getCharPositionInLine}, properly reflect the current
             lexer state. This method should restore {@code input} and the simulator
             to the original state before returning (i.e. undo the actions made by the
             call to {@link #consume}.</p>
            
             @param input The input stream.
             @param ruleIndex The rule containing the predicate.
             @param predIndex The index of the predicate within the rule.
             @param speculative {@code true} if the current index in {@code input} is
             one character before the predicate's location.
            
             @return {@code true} if the specified predicate evaluates to
             {@code true}.
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerATNSimulator.AddDFAState(Antlr4.Runtime.Atn.ATNConfigSet)">
            Add a new DFA state if there isn't one with this set of
            			configurations already. This method also detects the first
            			configuration containing an ATN rule stop state. Later, when
            			traversing the DFA, we will know which rule to accept.
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerATNSimulator.GetText(Antlr4.Runtime.ICharStream)">
            Get the text matched so far for the current token.
        </member>
        <member name="T:Antlr4.Runtime.Atn.SimState">
            When we hit an accept state in either the DFA or the ATN, we
              have to notify the character stream to start buffering characters
              via {@link IntStream#mark} and record the current state. The current sim state
              includes the current index into the input, the current line,
              and current character position in that line. Note that the Lexer is
              tracking the starting line and characterization of the token. These
              variables track the "state" of the simulator when it hits an accept state.
            
              <p>We track these variables separately for the DFA and ATN simulation
              because the DFA simulation often has to fail over to the ATN
              simulation. If the ATN simulation fails, we need the DFA to fall
              back to its previously accepted state, if any. If the ATN succeeds,
              then the ATN does the accept and the DFA simulator that invoked it
              can simply return the predicted token type.</p>
        </member>
        <member name="T:Antlr4.Runtime.Atn.LexerChannelAction">
            <summary>
            Implements the
            <c>channel</c>
            lexer action by calling
            <see cref="P:Antlr4.Runtime.Lexer.Channel"/>
            with the assigned channel.
            </summary>
            <author>Sam Harwell</author>
            <since>4.2</since>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerChannelAction.#ctor(System.Int32)">
            <summary>
            Constructs a new
            <paramref name="channel"/>
            action with the specified channel value.
            </summary>
            <param name="channel">
            The channel value to pass to
            <see cref="P:Antlr4.Runtime.Lexer.Channel"/>
            .
            </param>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerChannelAction.Channel">
            <summary>
            Gets the channel to use for the
            <see cref="T:Antlr4.Runtime.IToken"/>
            created by the lexer.
            </summary>
            <returns>
            The channel to use for the
            <see cref="T:Antlr4.Runtime.IToken"/>
            created by the lexer.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerChannelAction.ActionType">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns
            <see cref="F:Antlr4.Runtime.Atn.LexerActionType.Channel"/>
            .
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerChannelAction.IsPositionDependent">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns
            <see langword="false"/>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerChannelAction.Execute(Antlr4.Runtime.Lexer)">
            <summary>
            <inheritDoc/>
            <p>This action is implemented by calling
            <see cref="P:Antlr4.Runtime.Lexer.Channel"/>
            with the
            value provided by
            <see cref="P:Antlr4.Runtime.Atn.LexerChannelAction.Channel"/>
            .</p>
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.LexerCustomAction">
            <summary>
            Executes a custom lexer action by calling
            <see cref="M:Antlr4.Runtime.Recognizer`2.Action(Antlr4.Runtime.RuleContext,System.Int32,System.Int32)"/>
            with the
            rule and action indexes assigned to the custom action. The implementation of
            a custom action is added to the generated code for the lexer in an override
            of
            <see cref="M:Antlr4.Runtime.Recognizer`2.Action(Antlr4.Runtime.RuleContext,System.Int32,System.Int32)"/>
            when the grammar is compiled.
            <p>This class may represent embedded actions created with the <code>{...}</code>
            syntax in ANTLR 4, as well as actions created for lexer commands where the
            command argument could not be evaluated when the grammar was compiled.</p>
            </summary>
            <author>Sam Harwell</author>
            <since>4.2</since>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerCustomAction.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs a custom lexer action with the specified rule and action
            indexes.
            </summary>
            <remarks>
            Constructs a custom lexer action with the specified rule and action
            indexes.
            </remarks>
            <param name="ruleIndex">
            The rule index to use for calls to
            <see cref="M:Antlr4.Runtime.Recognizer`2.Action(Antlr4.Runtime.RuleContext,System.Int32,System.Int32)"/>
            .
            </param>
            <param name="actionIndex">
            The action index to use for calls to
            <see cref="M:Antlr4.Runtime.Recognizer`2.Action(Antlr4.Runtime.RuleContext,System.Int32,System.Int32)"/>
            .
            </param>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerCustomAction.RuleIndex">
            <summary>
            Gets the rule index to use for calls to
            <see cref="M:Antlr4.Runtime.Recognizer`2.Action(Antlr4.Runtime.RuleContext,System.Int32,System.Int32)"/>
            .
            </summary>
            <returns>The rule index for the custom action.</returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerCustomAction.ActionIndex">
            <summary>
            Gets the action index to use for calls to
            <see cref="M:Antlr4.Runtime.Recognizer`2.Action(Antlr4.Runtime.RuleContext,System.Int32,System.Int32)"/>
            .
            </summary>
            <returns>The action index for the custom action.</returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerCustomAction.ActionType">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns
            <see cref="F:Antlr4.Runtime.Atn.LexerActionType.Custom"/>
            .
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerCustomAction.IsPositionDependent">
            <summary>Gets whether the lexer action is position-dependent.</summary>
            <remarks>
            Gets whether the lexer action is position-dependent. Position-dependent
            actions may have different semantics depending on the
            <see cref="T:Antlr4.Runtime.ICharStream"/>
            index at the time the action is executed.
            <p>Custom actions are position-dependent since they may represent a
            user-defined embedded action which makes calls to methods like
            <see cref="P:Antlr4.Runtime.Lexer.Text"/>
            .</p>
            </remarks>
            <returns>
            This method returns
            <see langword="true"/>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerCustomAction.Execute(Antlr4.Runtime.Lexer)">
            <summary>
            <inheritDoc/>
            <p>Custom actions are implemented by calling
            <see cref="M:Antlr4.Runtime.Recognizer`2.Action(Antlr4.Runtime.RuleContext,System.Int32,System.Int32)"/>
            with the
            appropriate rule and action indexes.</p>
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.LexerIndexedCustomAction">
            <summary>
            This implementation of
            <see cref="T:Antlr4.Runtime.Atn.ILexerAction"/>
            is used for tracking input offsets
            for position-dependent actions within a
            <see cref="T:Antlr4.Runtime.Atn.LexerActionExecutor"/>
            .
            <p>This action is not serialized as part of the ATN, and is only required for
            position-dependent lexer actions which appear at a location other than the
            end of a rule. For more information about DFA optimizations employed for
            lexer actions, see
            <see cref="M:Antlr4.Runtime.Atn.LexerActionExecutor.Append(Antlr4.Runtime.Atn.LexerActionExecutor,Antlr4.Runtime.Atn.ILexerAction)"/>
            and
            <see cref="M:Antlr4.Runtime.Atn.LexerActionExecutor.FixOffsetBeforeMatch(System.Int32)"/>
            .</p>
            </summary>
            <author>Sam Harwell</author>
            <since>4.2</since>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerIndexedCustomAction.#ctor(System.Int32,Antlr4.Runtime.Atn.ILexerAction)">
            <summary>
            Constructs a new indexed custom action by associating a character offset
            with a
            <see cref="T:Antlr4.Runtime.Atn.ILexerAction"/>
            .
            <p>Note: This class is only required for lexer actions for which
            <see cref="P:Antlr4.Runtime.Atn.ILexerAction.IsPositionDependent"/>
            returns
            <see langword="true"/>
            .</p>
            </summary>
            <param name="offset">
            The offset into the input
            <see cref="T:Antlr4.Runtime.ICharStream"/>
            , relative to
            the token start index, at which the specified lexer action should be
            executed.
            </param>
            <param name="action">
            The lexer action to execute at a particular offset in the
            input
            <see cref="T:Antlr4.Runtime.ICharStream"/>
            .
            </param>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerIndexedCustomAction.Offset">
            <summary>
            Gets the location in the input
            <see cref="T:Antlr4.Runtime.ICharStream"/>
            at which the lexer
            action should be executed. The value is interpreted as an offset relative
            to the token start index.
            </summary>
            <returns>
            The location in the input
            <see cref="T:Antlr4.Runtime.ICharStream"/>
            at which the lexer
            action should be executed.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerIndexedCustomAction.Action">
            <summary>Gets the lexer action to execute.</summary>
            <remarks>Gets the lexer action to execute.</remarks>
            <returns>
            A
            <see cref="T:Antlr4.Runtime.Atn.ILexerAction"/>
            object which executes the lexer action.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerIndexedCustomAction.ActionType">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns the result of calling
            <see cref="P:Antlr4.Runtime.Atn.LexerIndexedCustomAction.ActionType"/>
            on the
            <see cref="T:Antlr4.Runtime.Atn.ILexerAction"/>
            returned by
            <see cref="P:Antlr4.Runtime.Atn.LexerIndexedCustomAction.Action"/>
            .
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerIndexedCustomAction.IsPositionDependent">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns
            <see langword="true"/>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerIndexedCustomAction.Execute(Antlr4.Runtime.Lexer)">
            <summary>
            <inheritDoc/>
            <p>This method calls
            <see cref="M:Antlr4.Runtime.Atn.LexerIndexedCustomAction.Execute(Antlr4.Runtime.Lexer)"/>
            on the result of
            <see cref="P:Antlr4.Runtime.Atn.LexerIndexedCustomAction.Action"/>
            using the provided
            <paramref name="lexer"/>
            .</p>
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.LexerModeAction">
            <summary>
            Implements the
            <c>mode</c>
            lexer action by calling
            <see cref="M:Antlr4.Runtime.Lexer.Mode(System.Int32)"/>
            with
            the assigned mode.
            </summary>
            <author>Sam Harwell</author>
            <since>4.2</since>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerModeAction.#ctor(System.Int32)">
            <summary>
            Constructs a new
            <paramref name="mode"/>
            action with the specified mode value.
            </summary>
            <param name="mode">
            The mode value to pass to
            <see cref="M:Antlr4.Runtime.Lexer.Mode(System.Int32)"/>
            .
            </param>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerModeAction.Mode">
            <summary>Get the lexer mode this action should transition the lexer to.</summary>
            <remarks>Get the lexer mode this action should transition the lexer to.</remarks>
            <returns>
            The lexer mode for this
            <c>mode</c>
            command.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerModeAction.ActionType">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns
            <see cref="F:Antlr4.Runtime.Atn.LexerActionType.Mode"/>
            .
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerModeAction.IsPositionDependent">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns
            <see langword="false"/>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerModeAction.Execute(Antlr4.Runtime.Lexer)">
            <summary>
            <inheritDoc/>
            <p>This action is implemented by calling
            <see cref="M:Antlr4.Runtime.Lexer.Mode(System.Int32)"/>
            with the
            value provided by
            <see cref="P:Antlr4.Runtime.Atn.LexerModeAction.Mode"/>
            .</p>
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.LexerMoreAction">
            <summary>
            Implements the
            <c>more</c>
            lexer action by calling
            <see cref="M:Antlr4.Runtime.Lexer.More"/>
            .
            <p>The
            <c>more</c>
            command does not have any parameters, so this action is
            implemented as a singleton instance exposed by
            <see cref="F:Antlr4.Runtime.Atn.LexerMoreAction.Instance"/>
            .</p>
            </summary>
            <author>Sam Harwell</author>
            <since>4.2</since>
        </member>
        <member name="F:Antlr4.Runtime.Atn.LexerMoreAction.Instance">
            <summary>Provides a singleton instance of this parameterless lexer action.</summary>
            <remarks>Provides a singleton instance of this parameterless lexer action.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerMoreAction.#ctor">
            <summary>
            Constructs the singleton instance of the lexer
            <c>more</c>
            command.
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerMoreAction.ActionType">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns
            <see cref="F:Antlr4.Runtime.Atn.LexerActionType.More"/>
            .
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerMoreAction.IsPositionDependent">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns
            <see langword="false"/>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerMoreAction.Execute(Antlr4.Runtime.Lexer)">
            <summary>
            <inheritDoc/>
            <p>This action is implemented by calling
            <see cref="M:Antlr4.Runtime.Lexer.More"/>
            .</p>
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.LexerPopModeAction">
            <summary>
            Implements the
            <c>popMode</c>
            lexer action by calling
            <see cref="M:Antlr4.Runtime.Lexer.PopMode"/>
            .
            <p>The
            <c>popMode</c>
            command does not have any parameters, so this action is
            implemented as a singleton instance exposed by
            <see cref="F:Antlr4.Runtime.Atn.LexerPopModeAction.Instance"/>
            .</p>
            </summary>
            <author>Sam Harwell</author>
            <since>4.2</since>
        </member>
        <member name="F:Antlr4.Runtime.Atn.LexerPopModeAction.Instance">
            <summary>Provides a singleton instance of this parameterless lexer action.</summary>
            <remarks>Provides a singleton instance of this parameterless lexer action.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerPopModeAction.#ctor">
            <summary>
            Constructs the singleton instance of the lexer
            <c>popMode</c>
            command.
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerPopModeAction.ActionType">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns
            <see cref="F:Antlr4.Runtime.Atn.LexerActionType.PopMode"/>
            .
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerPopModeAction.IsPositionDependent">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns
            <see langword="false"/>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerPopModeAction.Execute(Antlr4.Runtime.Lexer)">
            <summary>
            <inheritDoc/>
            <p>This action is implemented by calling
            <see cref="M:Antlr4.Runtime.Lexer.PopMode"/>
            .</p>
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.LexerPushModeAction">
            <summary>
            Implements the
            <c>pushMode</c>
            lexer action by calling
            <see cref="M:Antlr4.Runtime.Lexer.PushMode(System.Int32)"/>
            with the assigned mode.
            </summary>
            <author>Sam Harwell</author>
            <since>4.2</since>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerPushModeAction.#ctor(System.Int32)">
            <summary>
            Constructs a new
            <c>pushMode</c>
            action with the specified mode value.
            </summary>
            <param name="mode">
            The mode value to pass to
            <see cref="M:Antlr4.Runtime.Lexer.PushMode(System.Int32)"/>
            .
            </param>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerPushModeAction.Mode">
            <summary>Get the lexer mode this action should transition the lexer to.</summary>
            <remarks>Get the lexer mode this action should transition the lexer to.</remarks>
            <returns>
            The lexer mode for this
            <c>pushMode</c>
            command.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerPushModeAction.ActionType">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns
            <see cref="F:Antlr4.Runtime.Atn.LexerActionType.PushMode"/>
            .
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerPushModeAction.IsPositionDependent">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns
            <see langword="false"/>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerPushModeAction.Execute(Antlr4.Runtime.Lexer)">
            <summary>
            <inheritDoc/>
            <p>This action is implemented by calling
            <see cref="M:Antlr4.Runtime.Lexer.PushMode(System.Int32)"/>
            with the
            value provided by
            <see cref="P:Antlr4.Runtime.Atn.LexerPushModeAction.Mode"/>
            .</p>
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.LexerSkipAction">
            <summary>
            Implements the
            <c>skip</c>
            lexer action by calling
            <see cref="M:Antlr4.Runtime.Lexer.Skip"/>
            .
            <p>The
            <c>skip</c>
            command does not have any parameters, so this action is
            implemented as a singleton instance exposed by
            <see cref="F:Antlr4.Runtime.Atn.LexerSkipAction.Instance"/>
            .</p>
            </summary>
            <author>Sam Harwell</author>
            <since>4.2</since>
        </member>
        <member name="F:Antlr4.Runtime.Atn.LexerSkipAction.Instance">
            <summary>Provides a singleton instance of this parameterless lexer action.</summary>
            <remarks>Provides a singleton instance of this parameterless lexer action.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerSkipAction.#ctor">
            <summary>
            Constructs the singleton instance of the lexer
            <c>skip</c>
            command.
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerSkipAction.ActionType">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns
            <see cref="F:Antlr4.Runtime.Atn.LexerActionType.Skip"/>
            .
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerSkipAction.IsPositionDependent">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns
            <see langword="false"/>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerSkipAction.Execute(Antlr4.Runtime.Lexer)">
            <summary>
            <inheritDoc/>
            <p>This action is implemented by calling
            <see cref="M:Antlr4.Runtime.Lexer.Skip"/>
            .</p>
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.LexerTypeAction">
            <summary>
            Implements the
            <c>type</c>
            lexer action by calling
            <see cref="P:Antlr4.Runtime.Lexer.Type"/>
            with the assigned type.
            </summary>
            <author>Sam Harwell</author>
            <since>4.2</since>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerTypeAction.#ctor(System.Int32)">
            <summary>
            Constructs a new
            <paramref name="type"/>
            action with the specified token type value.
            </summary>
            <param name="type">
            The type to assign to the token using
            <see cref="P:Antlr4.Runtime.Lexer.Type"/>
            .
            </param>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerTypeAction.Type">
            <summary>Gets the type to assign to a token created by the lexer.</summary>
            <remarks>Gets the type to assign to a token created by the lexer.</remarks>
            <returns>The type to assign to a token created by the lexer.</returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerTypeAction.ActionType">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns
            <see cref="F:Antlr4.Runtime.Atn.LexerActionType.Type"/>
            .
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerTypeAction.IsPositionDependent">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns
            <see langword="false"/>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerTypeAction.Execute(Antlr4.Runtime.Lexer)">
            <summary>
            <inheritDoc/>
            <p>This action is implemented by calling
            <see cref="P:Antlr4.Runtime.Lexer.Type"/>
            with the
            value provided by
            <see cref="P:Antlr4.Runtime.Atn.LexerTypeAction.Type"/>
            .</p>
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Atn.LL1Analyzer.HitPred">
            <summary>
            Special value added to the lookahead sets to indicate that we hit
            a predicate during analysis if
            <c>seeThruPreds==false</c>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LL1Analyzer.GetDecisionLookahead(Antlr4.Runtime.Atn.ATNState)">
            <summary>
            Calculates the SLL(1) expected lookahead set for each outgoing transition
            of an
            <see cref="T:Antlr4.Runtime.Atn.ATNState"/>
            . The returned array has one element for each
            outgoing transition in
            <paramref name="s"/>
            . If the closure from transition
            <em>i</em> leads to a semantic predicate before matching a symbol, the
            element at index <em>i</em> of the result will be
            <see langword="null"/>
            .
            </summary>
            <param name="s">the ATN state</param>
            <returns>
            the expected symbols for each outgoing transition of
            <paramref name="s"/>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LL1Analyzer.Look(Antlr4.Runtime.Atn.ATNState,Antlr4.Runtime.RuleContext)">
            <summary>
            Compute set of tokens that can follow
            <paramref name="s"/>
            in the ATN in the
            specified
            <paramref name="ctx"/>
            .
            <p>If
            <paramref name="ctx"/>
            is
            <see langword="null"/>
            and the end of the rule containing
            <paramref name="s"/>
            is reached,
            <see cref="F:Antlr4.Runtime.TokenConstants.EPSILON"/>
            is added to the result set.
            If
            <paramref name="ctx"/>
            is not
            <see langword="null"/>
            and the end of the outermost rule is
            reached,
            <see cref="F:Antlr4.Runtime.TokenConstants.EOF"/>
            is added to the result set.</p>
            </summary>
            <param name="s">the ATN state</param>
            <param name="ctx">
            the complete parser context, or
            <see langword="null"/>
            if the context
            should be ignored
            </param>
            <returns>
            The set of tokens that can follow
            <paramref name="s"/>
            in the ATN in the
            specified
            <paramref name="ctx"/>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LL1Analyzer.Look(Antlr4.Runtime.Atn.ATNState,Antlr4.Runtime.Atn.ATNState,Antlr4.Runtime.RuleContext)">
            <summary>
            Compute set of tokens that can follow
            <paramref name="s"/>
            in the ATN in the
            specified
            <paramref name="ctx"/>
            .
            <p>If
            <paramref name="ctx"/>
            is
            <see langword="null"/>
            and the end of the rule containing
            <paramref name="s"/>
            is reached,
            <see cref="F:Antlr4.Runtime.TokenConstants.EPSILON"/>
            is added to the result set.
            If
            <paramref name="ctx"/>
            is not
            <c>PredictionContext#EMPTY_LOCAL</c>
            and the end of the outermost rule is
            reached,
            <see cref="F:Antlr4.Runtime.TokenConstants.EOF"/>
            is added to the result set.</p>
            </summary>
            <param name="s">the ATN state</param>
            <param name="stopState">
            the ATN state to stop at. This can be a
            <see cref="T:Antlr4.Runtime.Atn.BlockEndState"/>
            to detect epsilon paths through a closure.
            </param>
            <param name="ctx">
            the complete parser context, or
            <see langword="null"/>
            if the context
            should be ignored
            </param>
            <returns>
            The set of tokens that can follow
            <paramref name="s"/>
            in the ATN in the
            specified
            <paramref name="ctx"/>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LL1Analyzer.Look(Antlr4.Runtime.Atn.ATNState,Antlr4.Runtime.Atn.ATNState,Antlr4.Runtime.Atn.PredictionContext,Antlr4.Runtime.Misc.IntervalSet,System.Collections.Generic.HashSet{Antlr4.Runtime.Atn.ATNConfig},Antlr4.Runtime.Sharpen.BitSet,System.Boolean,System.Boolean)">
             <summary>
             Compute set of tokens that can follow
             <paramref name="s"/>
             in the ATN in the
             specified
             <paramref name="ctx"/>
             .
             <p/>
             If
             <paramref name="ctx"/>
             is
             <see cref="F:Antlr4.Runtime.Atn.PredictionContext.EMPTY"/>
             and
             <paramref name="stopState"/>
             or the end of the rule containing
             <paramref name="s"/>
             is reached,
             <see cref="F:Antlr4.Runtime.TokenConstants.EPSILON"/>
             is added to the result set. If
             <paramref name="ctx"/>
             is not
             <see cref="F:Antlr4.Runtime.Atn.PredictionContext.EMPTY"/>
             and
             <paramref name="addEOF"/>
             is
             <see langword="true"/>
             and
             <paramref name="stopState"/>
             or the end of the outermost rule is reached,
             <see cref="F:Antlr4.Runtime.TokenConstants.EOF"/>
             is added to the result set.
             </summary>
             <param name="s">the ATN state.</param>
             <param name="stopState">
             the ATN state to stop at. This can be a
             <see cref="T:Antlr4.Runtime.Atn.BlockEndState"/>
             to detect epsilon paths through a closure.
             </param>
             <param name="ctx">
             The outer context, or
             <see cref="F:Antlr4.Runtime.Atn.PredictionContext.EMPTY"/>
             if
             the outer context should not be used.
             </param>
             <param name="look">The result lookahead set.</param>
             <param name="lookBusy">
             A set used for preventing epsilon closures in the ATN
             from causing a stack overflow. Outside code should pass
             <c>new HashSet&lt;ATNConfig&gt;</c>
             for this argument.
             </param>
             <param name="calledRuleStack">
             A set used for preventing left recursion in the
             ATN from causing a stack overflow. Outside code should pass
             <c>new BitSet()</c>
             for this argument.
             </param>
             <param name="seeThruPreds">
            
             <see langword="true"/>
             to true semantic predicates as
             implicitly
             <see langword="true"/>
             and "see through them", otherwise
             <see langword="false"/>
             to treat semantic predicates as opaque and add
             <see cref="F:Antlr4.Runtime.Atn.LL1Analyzer.HitPred"/>
             to the
             result if one is encountered.
             </param>
             <param name="addEOF">
             Add
             <see cref="F:Antlr4.Runtime.TokenConstants.EOF"/>
             to the result if the end of the
             outermost context is reached. This parameter has no effect if
             <paramref name="ctx"/>
             is
             <see cref="F:Antlr4.Runtime.Atn.PredictionContext.EMPTY"/>
             .
             </param>
        </member>
        <member name="T:Antlr4.Runtime.Atn.LookaheadEventInfo">
            <summary>
            This class represents profiling event information for tracking the lookahead
            depth required in order to make a prediction.
            </summary>
            <remarks>
            This class represents profiling event information for tracking the lookahead
            depth required in order to make a prediction.
            </remarks>
            <since>4.3</since>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LookaheadEventInfo.#ctor(System.Int32,Antlr4.Runtime.Atn.SimulatorState,Antlr4.Runtime.ITokenStream,System.Int32,System.Int32,System.Boolean)">
             <summary>
             Constructs a new instance of the
             <see cref="T:Antlr4.Runtime.Atn.LookaheadEventInfo"/>
             class with
             the specified detailed lookahead information.
             </summary>
             <param name="decision">The decision number</param>
             <param name="state">
             The final simulator state containing the necessary
             information to determine the result of a prediction, or
             <see langword="null"/>
             if
             the final state is not available
             </param>
             <param name="input">The input token stream</param>
             <param name="startIndex">The start index for the current prediction</param>
             <param name="stopIndex">The index at which the prediction was finally made</param>
             <param name="fullCtx">
            
             <see langword="true"/>
             if the current lookahead is part of an LL
             prediction; otherwise,
             <see langword="false"/>
             if the current lookahead is part of
             an SLL prediction
             </param>
        </member>
        <member name="T:Antlr4.Runtime.Atn.LoopEndState">
            <summary>Mark the end of a * or + loop.</summary>
            <remarks>Mark the end of a * or + loop.</remarks>
        </member>
        <member name="T:Antlr4.Runtime.Atn.ParseInfo">
             This class provides access to specific and aggregate statistics gathered
             during profiling of a parser.
            
             @since 4.3
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParseInfo.getDecisionInfo">
             Gets an array of {@link DecisionInfo} instances containing the profiling
             information gathered for each decision in the ATN.
            
             @return An array of {@link DecisionInfo} instances, indexed by decision
             number.
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParseInfo.getLLDecisions">
             Gets the decision numbers for decisions that required one or more
             full-context predictions during parsing. These are decisions for which
             {@link DecisionInfo#LL_Fallback} is non-zero.
            
             @return A list of decision numbers which required one or more
             full-context predictions during parsing.
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParseInfo.getTotalTimeInPrediction">
            Gets the total time spent during prediction across all decisions made
            during parsing. This value is the sum of
            {@link DecisionInfo#timeInPrediction} for all decisions.
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParseInfo.getTotalSLLLookaheadOps">
            Gets the total number of SLL lookahead operations across all decisions
            made during parsing. This value is the sum of
            {@link DecisionInfo#SLL_TotalLook} for all decisions.
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParseInfo.getTotalLLLookaheadOps">
            Gets the total number of LL lookahead operations across all decisions
            made during parsing. This value is the sum of
            {@link DecisionInfo#LL_TotalLook} for all decisions.
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParseInfo.getTotalSLLATNLookaheadOps">
            Gets the total number of ATN lookahead operations for SLL prediction
            across all decisions made during parsing.
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParseInfo.getTotalLLATNLookaheadOps">
            Gets the total number of ATN lookahead operations for LL prediction
            across all decisions made during parsing.
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParseInfo.getTotalATNLookaheadOps">
             Gets the total number of ATN lookahead operations for SLL and LL
             prediction across all decisions made during parsing.
            
             <p>
             This value is the sum of {@link #getTotalSLLATNLookaheadOps} and
             {@link #getTotalLLATNLookaheadOps}.</p>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParseInfo.getDFASize">
            Gets the total number of DFA states stored in the DFA cache for all
            decisions in the ATN.
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParseInfo.getDFASize(System.Int32)">
            Gets the total number of DFA states stored in the DFA cache for a
            particular decision.
        </member>
        <member name="T:Antlr4.Runtime.Atn.ParserATNSimulator">
             The embodiment of the adaptive LL(*), ALL(*), parsing strategy.
            
             <p>
             The basic complexity of the adaptive strategy makes it harder to understand.
             We begin with ATN simulation to build paths in a DFA. Subsequent prediction
             requests go through the DFA first. If they reach a state without an edge for
             the current symbol, the algorithm fails over to the ATN simulation to
             complete the DFA path for the current input (until it finds a conflict state
             or uniquely predicting state).</p>
            
             <p>
             All of that is done without using the outer context because we want to create
             a DFA that is not dependent upon the rule invocation stack when we do a
             prediction. One DFA works in all contexts. We avoid using context not
             necessarily because it's slower, although it can be, but because of the DFA
             caching problem. The closure routine only considers the rule invocation stack
             created during prediction beginning in the decision rule. For example, if
             prediction occurs without invoking another rule's ATN, there are no context
             stacks in the configurations. When lack of context leads to a conflict, we
             don't know if it's an ambiguity or a weakness in the strong LL(*) parsing
             strategy (versus full LL(*)).</p>
            
             <p>
             When SLL yields a configuration set with conflict, we rewind the input and
             retry the ATN simulation, this time using full outer context without adding
             to the DFA. Configuration context stacks will be the full invocation stacks
             from the start rule. If we get a conflict using full context, then we can
             definitively say we have a true ambiguity for that input sequence. If we
             don't get a conflict, it implies that the decision is sensitive to the outer
             context. (It is not context-sensitive in the sense of context-sensitive
             grammars.)</p>
            
             <p>
             The next time we reach this DFA state with an SLL conflict, through DFA
             simulation, we will again retry the ATN simulation using full context mode.
             This is slow because we can't save the results and have to "interpret" the
             ATN each time we get that input.</p>
            
             <p>
             <strong>CACHING FULL CONTEXT PREDICTIONS</strong></p>
            
             <p>
             We could cache results from full context to predicted alternative easily and
             that saves a lot of time but doesn't work in presence of predicates. The set
             of visible predicates from the ATN start state changes depending on the
             context, because closure can fall off the end of a rule. I tried to cache
             tuples (stack context, semantic context, predicted alt) but it was slower
             than interpreting and much more complicated. Also required a huge amount of
             memory. The goal is not to create the world's fastest parser anyway. I'd like
             to keep this algorithm simple. By launching multiple threads, we can improve
             the speed of parsing across a large number of files.</p>
            
             <p>
             There is no strict ordering between the amount of input used by SLL vs LL,
             which makes it really hard to build a cache for full context. Let's say that
             we have input A B C that leads to an SLL conflict with full context X. That
             implies that using X we might only use A B but we could also use A B C D to
             resolve conflict. Input A B C D could predict alternative 1 in one position
             in the input and A B C E could predict alternative 2 in another position in
             input. The conflicting SLL configurations could still be non-unique in the
             full context prediction, which would lead us to requiring more input than the
             original A B C.	To make a	prediction cache work, we have to track	the exact
             input	used during the previous prediction. That amounts to a cache that maps
             X to a specific DFA for that context.</p>
            
             <p>
             Something should be done for left-recursive expression predictions. They are
             likely LL(1) + pred eval. Easier to do the whole SLL unless error and retry
             with full LL thing Sam does.</p>
            
             <p>
             <strong>AVOIDING FULL CONTEXT PREDICTION</strong></p>
            
             <p>
             We avoid doing full context retry when the outer context is empty, we did not
             dip into the outer context by falling off the end of the decision state rule,
             or when we force SLL mode.</p>
            
             <p>
             As an example of the not dip into outer context case, consider as super
             constructor calls versus function calls. One grammar might look like
             this:</p>
            
             <pre>
             ctorBody
               : '{' superCall? stat* '}'
               ;
             </pre>
            
             <p>
             Or, you might see something like</p>
            
             <pre>
             stat
               : superCall ';'
               | expression ';'
               | ...
               ;
             </pre>
            
             <p>
             In both cases I believe that no closure operations will dip into the outer
             context. In the first case ctorBody in the worst case will stop at the '}'.
             In the 2nd case it should stop at the ';'. Both cases should stay within the
             entry rule and not dip into the outer context.</p>
            
             <p>
             <strong>PREDICATES</strong></p>
            
             <p>
             Predicates are always evaluated if present in either SLL or LL both. SLL and
             LL simulation deals with predicates differently. SLL collects predicates as
             it performs closure operations like ANTLR v3 did. It delays predicate
             evaluation until it reaches and accept state. This allows us to cache the SLL
             ATN simulation whereas, if we had evaluated predicates on-the-fly during
             closure, the DFA state configuration sets would be different and we couldn't
             build up a suitable DFA.</p>
            
             <p>
             When building a DFA accept state during ATN simulation, we evaluate any
             predicates and return the sole semantically valid alternative. If there is
             more than 1 alternative, we report an ambiguity. If there are 0 alternatives,
             we throw an exception. Alternatives without predicates act like they have
             true predicates. The simple way to think about it is to strip away all
             alternatives with false predicates and choose the minimum alternative that
             remains.</p>
            
             <p>
             When we start in the DFA and reach an accept state that's predicated, we test
             those and return the minimum semantically viable alternative. If no
             alternatives are viable, we throw an exception.</p>
            
             <p>
             During full LL ATN simulation, closure always evaluates predicates and
             on-the-fly. This is crucial to reducing the configuration set size during
             closure. It hits a landmine when parsing with the Java grammar, for example,
             without this on-the-fly evaluation.</p>
            
             <p>
             <strong>SHARING DFA</strong></p>
            
             <p>
             All instances of the same parser share the same decision DFAs through a
             static field. Each instance gets its own ATN simulator but they share the
             same {@link #decisionToDFA} field. They also share a
             {@link PredictionContextCache} object that makes sure that all
             {@link PredictionContext} objects are shared among the DFA states. This makes
             a big size difference.</p>
            
             <p>
             <strong>THREAD SAFETY</strong></p>
            
             <p>
             The {@link ParserATNSimulator} locks on the {@link #decisionToDFA} field when
             it adds a new DFA object to that array. {@link #addDFAEdge}
             locks on the DFA for the current decision when setting the
             {@link DFAState#edges} field. {@link #addDFAState} locks on
             the DFA for the current decision when looking up a DFA state to see if it
             already exists. We must make sure that all requests to add DFA states that
             are equivalent result in the same shared DFA object. This is because lots of
             threads will be trying to update the DFA at once. The
             {@link #addDFAState} method also locks inside the DFA lock
             but this time on the shared context cache when it rebuilds the
             configurations' {@link PredictionContext} objects using cached
             subgraphs/nodes. No other locking occurs, even during DFA simulation. This is
             safe as long as we can guarantee that all threads referencing
             {@code s.edge[t]} get the same physical target {@link DFAState}, or
             {@code null}. Once into the DFA, the DFA simulation does not reference the
             {@link DFA#states} map. It follows the {@link DFAState#edges} field to new
             targets. The DFA simulator will either find {@link DFAState#edges} to be
             {@code null}, to be non-{@code null} and {@code dfa.edges[t]} null, or
             {@code dfa.edges[t]} to be non-null. The
             {@link #addDFAEdge} method could be racing to set the field
             but in either case the DFA simulator works; if {@code null}, and requests ATN
             simulation. It could also race trying to get {@code dfa.edges[t]}, but either
             way it will work because it's not doing a test and set operation.</p>
            
             <p>
             <strong>Starting with SLL then failing to combined SLL/LL (Two-Stage
             Parsing)</strong></p>
            
             <p>
             Sam pointed out that if SLL does not give a syntax error, then there is no
             point in doing full LL, which is slower. We only have to try LL if we get a
             syntax error. For maximum speed, Sam starts the parser set to pure SLL
             mode with the {@link BailErrorStrategy}:</p>
            
             <pre>
             parser.{@link Parser#getInterpreter() getInterpreter()}.{@link #setPredictionMode setPredictionMode}{@code (}{@link PredictionMode#SLL}{@code )};
             parser.{@link Parser#setErrorHandler setErrorHandler}(new {@link BailErrorStrategy}());
             </pre>
            
             <p>
             If it does not get a syntax error, then we're done. If it does get a syntax
             error, we need to retry with the combined SLL/LL strategy.</p>
            
             <p>
             The reason this works is as follows. If there are no SLL conflicts, then the
             grammar is SLL (at least for that input set). If there is an SLL conflict,
             the full LL analysis must yield a set of viable alternatives which is a
             subset of the alternatives reported by SLL. If the LL set is a singleton,
             then the grammar is LL but not SLL. If the LL set is the same size as the SLL
             set, the decision is SLL. If the LL set has size &gt; 1, then that decision
             is truly ambiguous on the current input. If the LL set is smaller, then the
             SLL conflict resolution might choose an alternative that the full LL would
             rule out as a possibility based upon better context information. If that's
             the case, then the SLL parse will definitely get an error because the full LL
             analysis says it's not viable. If SLL conflict resolution chooses an
             alternative within the LL set, them both SLL and LL would choose the same
             alternative because they both choose the minimum of multiple conflicting
             alternatives.</p>
            
             <p>
             Let's say we have a set of SLL conflicting alternatives {@code {1, 2, 3}} and
             a smaller LL set called <em>s</em>. If <em>s</em> is {@code {2, 3}}, then SLL
             parsing will get an error because SLL will pursue alternative 1. If
             <em>s</em> is {@code {1, 2}} or {@code {1, 3}} then both SLL and LL will
             choose the same alternative because alternative one is the minimum of either
             set. If <em>s</em> is {@code {2}} or {@code {3}} then SLL will get a syntax
             error. If <em>s</em> is {@code {1}} then SLL will succeed.</p>
            
             <p>
             Of course, if the input is invalid, then we will get an error for sure in
             both SLL and LL parsing. Erroneous input will therefore require 2 passes over
             the input.</p>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ParserATNSimulator.mode">
            SLL, LL, or LL + exact ambig detection? 
        </member>
        <member name="F:Antlr4.Runtime.Atn.ParserATNSimulator.mergeCache">
            Each prediction operation uses a cache for merge of prediction contexts.
            Don't keep around as it wastes huge amounts of memory. DoubleKeyMap
            isn't synchronized but we're ok since two threads shouldn't reuse same
            parser/atnsim object because it can only handle one input at a time.
            This maps graphs a and b to merged result c. (a,b)c. We can avoid
            the merge if we ever see a and b again.  Note that (b,a)c should
            also be examined during cache lookup.
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.#ctor(Antlr4.Runtime.Atn.ATN,Antlr4.Runtime.Dfa.DFA[],Antlr4.Runtime.Atn.PredictionContextCache)">
            Testing only! 
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.ExecATN(Antlr4.Runtime.Dfa.DFA,Antlr4.Runtime.Dfa.DFAState,Antlr4.Runtime.ITokenStream,System.Int32,Antlr4.Runtime.ParserRuleContext)">
            Performs ATN simulation to compute a predicted alternative based
            		 *  upon the remaining input, but also updates the DFA cache to avoid
            		 *  having to traverse the ATN again for the same input sequence.
            
            		 There are some key conditions we're looking for after computing a new
            		 set of ATN configs (proposed DFA state):
            			   * if the set is empty, there is no viable alternative for current symbol
            			   * does the state uniquely predict an alternative?
            			   * does the state have a conflict that would prevent us from
            				 putting it on the work list?
            
            		 We also have some key operations to do:
            			   * add an edge from previous DFA state to potentially new DFA state, D,
            				 upon current symbol but only if adding to work list, which means in all
            				 cases except no viable alternative (and possibly non-greedy decisions?)
            			   * collecting predicates and adding semantic context to DFA accept states
            			   * adding rule context to context-sensitive DFA accept states
            			   * consuming an input symbol
            			   * reporting a conflict
            			   * reporting an ambiguity
            			   * reporting a context sensitivity
            			   * reporting insufficient predicates
            
            		 cover these cases:
            			dead end
            			single alt
            			single alt + preds
            			conflict
            			conflict + preds
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.GetExistingTargetState(Antlr4.Runtime.Dfa.DFAState,System.Int32)">
             Get an existing target state for an edge in the DFA. If the target state
             for the edge has not yet been computed or is otherwise not available,
             this method returns {@code null}.
            
             @param previousD The current DFA state
             @param t The next input symbol
             @return The existing target DFA state for the given input symbol
             {@code t}, or {@code null} if the target state for this edge is not
             already cached
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.ComputeTargetState(Antlr4.Runtime.Dfa.DFA,Antlr4.Runtime.Dfa.DFAState,System.Int32)">
             Compute a target state for an edge in the DFA, and attempt to add the
             computed state and corresponding edge to the DFA.
            
             @param dfa The DFA
             @param previousD The current DFA state
             @param t The next input symbol
            
             @return The computed target DFA state for the given input symbol
             {@code t}. If {@code t} does not lead to a valid DFA state, this method
             returns {@link #ERROR}.
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.RemoveAllConfigsNotInRuleStopState(Antlr4.Runtime.Atn.ATNConfigSet,System.Boolean)">
             Return a configuration set containing only the configurations from
             {@code configs} which are in a {@link RuleStopState}. If all
             configurations in {@code configs} are already in a rule stop state, this
             method simply returns {@code configs}.
            
             <p>When {@code lookToEndOfRule} is true, this method uses
             {@link ATN#nextTokens} for each configuration in {@code configs} which is
             not already in a rule stop state to see if a rule stop state is reachable
             from the configuration via epsilon-only transitions.</p>
            
             @param configs the configuration set to update
             @param lookToEndOfRule when true, this method checks for rule stop states
             reachable by epsilon-only transitions from each configuration in
             {@code configs}.
            
             @return {@code configs} if all configurations in {@code configs} are in a
             rule stop state, otherwise return a new configuration set containing only
             the configurations from {@code configs} which are in a rule stop state
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.ApplyPrecedenceFilter(Antlr4.Runtime.Atn.ATNConfigSet)">
             This method transforms the start state computed by
             {@link #computeStartState} to the special start state used by a
             precedence DFA for a particular precedence value. The transformation
             process applies the following changes to the start state's configuration
             set.
            
             <ol>
             <li>Evaluate the precedence predicates for each configuration using
             {@link SemanticContext#evalPrecedence}.</li>
             <li>When {@link ATNConfig#isPrecedenceFilterSuppressed} is {@code false},
             remove all configurations which predict an alternative greater than 1,
             for which another configuration that predicts alternative 1 is in the
             same ATN state with the same prediction context. This transformation is
             valid for the following reasons:
             <ul>
             <li>The closure block cannot contain any epsilon transitions which bypass
             the body of the closure, so all states reachable via alternative 1 are
             part of the precedence alternatives of the transformed left-recursive
             rule.</li>
             <li>The "primary" portion of a left recursive rule cannot contain an
             epsilon transition, so the only way an alternative other than 1 can exist
             in a state that is also reachable via alternative 1 is by nesting calls
             to the left-recursive rule, with the outer calls not being at the
             preferred precedence level. The
             {@link ATNConfig#isPrecedenceFilterSuppressed} property marks ATN
             configurations which do not meet this condition, and therefore are not
             eligible for elimination during the filtering process.</li>
             </ul>
             </li>
             </ol>
            
             <p>
             The prediction context must be considered by this filter to address
             situations like the following.
             </p>
             <code>
             <pre>
             grammar TA;
             prog: statement* EOF;
             statement: letterA | statement letterA 'b' ;
             letterA: 'a';
             </pre>
             </code>
             <p>
             If the above grammar, the ATN state immediately before the token
             reference {@code 'a'} in {@code letterA} is reachable from the left edge
             of both the primary and closure blocks of the left-recursive rule
             {@code statement}. The prediction context associated with each of these
             configurations distinguishes between them, and prevents the alternative
             which stepped out to {@code prog} (and then back in to {@code statement}
             from being eliminated by the filter.
             </p>
            
             @param configs The configuration set computed by
             {@link #computeStartState} as the start state for the DFA.
             @return The transformed configuration set representing the start state
             for a precedence DFA at a particular precedence level (determined by
             calling {@link Parser#getPrecedence}).
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.GetSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(Antlr4.Runtime.Atn.ATNConfigSet,Antlr4.Runtime.ParserRuleContext)">
             This method is used to improve the localization of error messages by
             choosing an alternative rather than throwing a
             {@link NoViableAltException} in particular prediction scenarios where the
             {@link #ERROR} state was reached during ATN simulation.
            
             <p>
             The default implementation of this method uses the following
             algorithm to identify an ATN configuration which successfully parsed the
             decision entry rule. Choosing such an alternative ensures that the
             {@link ParserRuleContext} returned by the calling rule will be complete
             and valid, and the syntax error will be reported later at a more
             localized location.</p>
            
             <ul>
             <li>If a syntactically valid path or paths reach the end of the decision rule and
             they are semantically valid if predicated, return the min associated alt.</li>
             <li>Else, if a semantically invalid but syntactically valid path exist
             or paths exist, return the minimum associated alt.
             </li>
             <li>Otherwise, return {@link ATN#INVALID_ALT_NUMBER}.</li>
             </ul>
            
             <p>
             In some scenarios, the algorithm described above could predict an
             alternative which will result in a {@link FailedPredicateException} in
             the parser. Specifically, this could occur if the <em>only</em> configuration
             capable of successfully parsing to the end of the decision rule is
             blocked by a semantic predicate. By choosing this alternative within
             {@link #adaptivePredict} instead of throwing a
             {@link NoViableAltException}, the resulting
             {@link FailedPredicateException} in the parser will identify the specific
             predicate which is preventing the parser from successfully parsing the
             decision rule, which helps developers identify and correct logic errors
             in semantic predicates.
             </p>
            
             @param configs The ATN configurations which were valid immediately before
             the {@link #ERROR} state was reached
             @param outerContext The is the \gamma_0 initial parser context from the paper
             or the parser stack at the instant before prediction commences.
            
             @return The value to return from {@link #adaptivePredict}, or
             {@link ATN#INVALID_ALT_NUMBER} if a suitable alternative was not
             identified and {@link #adaptivePredict} should report an error instead.
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.SplitAccordingToSemanticValidity(Antlr4.Runtime.Atn.ATNConfigSet,Antlr4.Runtime.ParserRuleContext)">
            Walk the list of configurations and split them according to
              those that have preds evaluating to true/false.  If no pred, assume
              true pred and include in succeeded set.  Returns Pair of sets.
            
              Create a new set so as not to alter the incoming parameter.
            
              Assumption: the input stream has been restored to the starting point
              prediction, which is where predicates need to evaluate.
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.EvalSemanticContext(Antlr4.Runtime.Dfa.PredPrediction[],Antlr4.Runtime.ParserRuleContext,System.Boolean)">
            Look through a list of predicate/alt pairs, returning alts for the
            pairs that win. A {@code NONE} predicate indicates an alt containing an
            unpredicated config which behaves as "always true." If !complete
            then we stop at the first predicate that evaluates to true. This
            includes pairs with null predicates.
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.EvalSemanticContext(Antlr4.Runtime.Atn.SemanticContext,Antlr4.Runtime.ParserRuleContext,System.Int32,System.Boolean)">
             Evaluate a semantic context within a specific parser context.
            
             <p>
             This method might not be called for every semantic context evaluated
             during the prediction process. In particular, we currently do not
             evaluate the following but it may change in the future:</p>
            
             <ul>
             <li>Precedence predicates (represented by
             {@link SemanticContext.PrecedencePredicate}) are not currently evaluated
             through this method.</li>
             <li>Operator predicates (represented by {@link SemanticContext.AND} and
             {@link SemanticContext.OR}) are evaluated as a single semantic
             context, rather than evaluating the operands individually.
             Implementations which require evaluation results from individual
             predicates should override this method to explicitly handle evaluation of
             the operands within operator predicates.</li>
             </ul>
            
             @param pred The semantic context to evaluate
             @param parserCallStack The parser context in which to evaluate the
             semantic context
             @param alt The alternative which is guarded by {@code pred}
             @param fullCtx {@code true} if the evaluation is occurring during LL
             prediction; otherwise, {@code false} if the evaluation is occurring
             during SLL prediction
            
             @since 4.3
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.Closure_(Antlr4.Runtime.Atn.ATNConfig,Antlr4.Runtime.Atn.ATNConfigSet,System.Collections.Generic.HashSet{Antlr4.Runtime.Atn.ATNConfig},System.Boolean,System.Boolean,System.Int32,System.Boolean)">
            Do the actual work of walking epsilon edges 
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.CanDropLoopEntryEdgeInLeftRecursiveRule(Antlr4.Runtime.Atn.ATNConfig)">
            Implements first-edge (loop entry) elimination as an optimization
              during closure operations.  See antlr/antlr4#1398.
            
             The optimization is to avoid adding the loop entry config when
             the exit path can only lead back to the same
             StarLoopEntryState after popping context at the rule end state
             (traversing only epsilon edges, so we're still in closure, in
             this same rule).
            
             We need to detect any state that can reach loop entry on
             epsilon w/o exiting rule. We don't have to look at FOLLOW
             links, just ensure that all stack tops for config refer to key
             states in LR rule.
            
             To verify we are in the right situation we must first check
             closure is at a StarLoopEntryState generated during LR removal.
             Then we check that each stack top of context is a return state
             from one of these cases:
            
               1. 'not' expr, '(' type ')' expr. The return state points at loop entry state
               2. expr op expr. The return state is the block end of internal block of (...)*
               3. 'between' expr 'and' expr. The return state of 2nd expr reference.
                  That state points at block end of internal block of (...)*.
               4. expr '?' expr ':' expr. The return state points at block end,
                  which points at loop entry state.
            
             If any is true for each stack top, then closure does not add a
             config to the current config set for edge[0], the loop entry branch.
            
              Conditions fail if any context for the current config is:
            
               a. empty (we'd fall out of expr to do a global FOLLOW which could
                  even be to some weird spot in expr) or,
               b. lies outside of expr or,
               c. lies within expr but at a state not the BlockEndState
               generated during LR removal
            
             Do we need to evaluate predicates ever in closure for this case?
            
             No. Predicates, including precedence predicates, are only
             evaluated when computing a DFA start state. I.e., only before
             the lookahead (but not parser) consumes a token.
            
             There are no epsilon edges allowed in LR rule alt blocks or in
             the "primary" part (ID here). If closure is in
             StarLoopEntryState any lookahead operation will have consumed a
             token as there are no epsilon-paths that lead to
             StarLoopEntryState. We do not have to evaluate predicates
             therefore if we are in the generated StarLoopEntryState of a LR
             rule. Note that when making a prediction starting at that
             decision point, decision d=2, compute-start-state performs
             closure starting at edges[0], edges[1] emanating from
             StarLoopEntryState. That means it is not performing closure on
             StarLoopEntryState during compute-start-state.
            
             How do we know this always gives same prediction answer?
            
             Without predicates, loop entry and exit paths are ambiguous
             upon remaining input +b (in, say, a+b). Either paths lead to
             valid parses. Closure can lead to consuming + immediately or by
             falling out of this call to expr back into expr and loop back
             again to StarLoopEntryState to match +b. In this special case,
             we choose the more efficient path, which is to take the bypass
             path.
            
             The lookahead language has not changed because closure chooses
             one path over the other. Both paths lead to consuming the same
             remaining input during a lookahead operation. If the next token
             is an operator, lookahead will enter the choice block with
             operators. If it is not, lookahead will exit expr. Same as if
             closure had chosen to enter the choice block immediately.
            
             Closure is examining one config (some loopentrystate, some alt,
             context) which means it is considering exactly one alt. Closure
             always copies the same alt to any derived configs.
            
             How do we know this optimization doesn't mess up precedence in
             our parse trees?
            
             Looking through expr from left edge of stat only has to confirm
             that an input, say, a+b+c; begins with any valid interpretation
             of an expression. The precedence actually doesn't matter when
             making a decision in stat seeing through expr. It is only when
             parsing rule expr that we must use the precedence to get the
             right interpretation and, hence, parse tree.
            
             @since 4.6
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.GetConflictingAlts(Antlr4.Runtime.Atn.ATNConfigSet)">
             Gets a {@link BitSet} containing the alternatives in {@code configs}
             which are part of one or more conflicting alternative subsets.
            
             @param configs The {@link ATNConfigSet} to analyze.
             @return The alternatives in {@code configs} which are part of one or more
             conflicting alternative subsets. If {@code configs} does not contain any
             conflicting subsets, this method returns an empty {@link BitSet}.
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.GetConflictingAltsOrUniqueAlt(Antlr4.Runtime.Atn.ATNConfigSet)">
            		 Sam pointed out a problem with the previous definition, v3, of
            		 ambiguous states. If we have another state associated with conflicting
            		 alternatives, we should keep going. For example, the following grammar
            
            		 s : (ID | ID ID?) ';' ;
            
            		 When the ATN simulation reaches the state before ';', it has a DFA
            		 state that looks like: [12|1|[], 6|2|[], 12|2|[]]. Naturally
            		 12|1|[] and 12|2|[] conflict, but we cannot stop processing this node
            		 because alternative to has another way to continue, via [6|2|[]].
            		 The key is that we have a single state that has config's only associated
            		 with a single alternative, 2, and crucially the state transitions
            		 among the configurations are all non-epsilon transitions. That means
            		 we don't consider any conflicts that include alternative 2. So, we
            		 ignore the conflict between alts 1 and 2. We ignore a set of
            		 conflicting alts when there is an intersection with an alternative
            		 associated with a single alt state in the stateconfig-list map.
            
            		 It's also the case that we might have two conflicting configurations but
            		 also a 3rd nonconflicting configuration for a different alternative:
            		 [1|1|[], 1|2|[], 8|3|[]]. This can come about from grammar:
            
            		 a : A | A | A B ;
            
            		 After matching input A, we reach the stop state for rule A, state 1.
            		 State 8 is the state right before B. Clearly alternatives 1 and 2
            		 conflict and no amount of further lookahead will separate the two.
            		 However, alternative 3 will be able to continue and so we do not
            		 stop working on this state. In the previous example, we're concerned
            		 with states associated with the conflicting alternatives. Here alt
            		 3 is not associated with the conflicting configs, but since we can continue
            		 looking for input reasonably, I don't declare the state done. We
            		 ignore a set of conflicting alts when we have an alternative
            		 that we still need to pursue.
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.DumpDeadEndConfigs(Antlr4.Runtime.NoViableAltException)">
            Used for debugging in adaptivePredict around execATN but I cut
            it out for clarity now that alg. works well. We can leave this
            "dead" code for a bit.
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.AddDFAEdge(Antlr4.Runtime.Dfa.DFA,Antlr4.Runtime.Dfa.DFAState,System.Int32,Antlr4.Runtime.Dfa.DFAState)">
             Add an edge to the DFA, if possible. This method calls
             {@link #addDFAState} to ensure the {@code to} state is present in the
             DFA. If {@code from} is {@code null}, or if {@code t} is outside the
             range of edges that can be represented in the DFA tables, this method
             returns without adding the edge to the DFA.
            
             <p>If {@code to} is {@code null}, this method returns {@code null}.
             Otherwise, this method returns the {@link DFAState} returned by calling
             {@link #addDFAState} for the {@code to} state.</p>
            
             @param dfa The DFA
             @param from The source state for the edge
             @param t The input symbol
             @param to The target state for the edge
            
             @return If {@code to} is {@code null}, this method returns {@code null};
             otherwise this method returns the result of calling {@link #addDFAState}
             on {@code to}
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.AddDFAState(Antlr4.Runtime.Dfa.DFA,Antlr4.Runtime.Dfa.DFAState)">
             Add state {@code D} to the DFA if it is not already present, and return
             the actual instance stored in the DFA. If a state equivalent to {@code D}
             is already in the DFA, the existing state is returned. Otherwise this
             method returns {@code D} after adding it to the DFA.
            
             <p>If {@code D} is {@link #ERROR}, this method returns {@link #ERROR} and
             does not change the DFA.</p>
            
             @param dfa The dfa
             @param D The DFA state to add
             @return The state stored in the DFA. This will be either the existing
             state if {@code D} is already in the DFA, or {@code D} itself if the
             state was not already present.
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.ReportAmbiguity(Antlr4.Runtime.Dfa.DFA,Antlr4.Runtime.Dfa.DFAState,System.Int32,System.Int32,System.Boolean,Antlr4.Runtime.Sharpen.BitSet,Antlr4.Runtime.Atn.ATNConfigSet)">
            If context sensitive parsing, we know it's ambiguity not conflict 
        </member>
        <member name="T:Antlr4.Runtime.Atn.PlusBlockStartState">
            <summary>
            Start of
            <c>(A|B|...)+</c>
            loop. Technically a decision state, but
            we don't use for code generation; somebody might need it, so I'm defining
            it for completeness. In reality, the
            <see cref="T:Antlr4.Runtime.Atn.PlusLoopbackState"/>
            node is the
            real decision-making note for
            <c>A+</c>
            .
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.PlusLoopbackState">
            <summary>
            Decision state for
            <c>A+</c>
            and
            <c>(A|B)+</c>
            .  It has two transitions:
            one to the loop back to start of the block and one to exit.
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.PrecedencePredicateTransition">
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Atn.PredicateEvalInfo">
            <summary>
            This class represents profiling event information for semantic predicate
            evaluations which occur during prediction.
            </summary>
            <remarks>
            This class represents profiling event information for semantic predicate
            evaluations which occur during prediction.
            </remarks>
            <seealso cref="M:Antlr4.Runtime.Atn.ParserATNSimulator.EvalSemanticContext(Antlr4.Runtime.Dfa.PredPrediction[],Antlr4.Runtime.ParserRuleContext,System.Boolean)"/>
            <since>4.3</since>
        </member>
        <member name="F:Antlr4.Runtime.Atn.PredicateEvalInfo.semctx">
            <summary>The semantic context which was evaluated.</summary>
            <remarks>The semantic context which was evaluated.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.PredicateEvalInfo.predictedAlt">
            <summary>
            The alternative number for the decision which is guarded by the semantic
            context
            <see cref="F:Antlr4.Runtime.Atn.PredicateEvalInfo.semctx"/>
            . Note that other ATN
            configurations may predict the same alternative which are guarded by
            other semantic contexts and/or
            <see cref="F:Antlr4.Runtime.Atn.SemanticContext.NONE"/>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Atn.PredicateEvalInfo.evalResult">
            <summary>
            The result of evaluating the semantic context
            <see cref="F:Antlr4.Runtime.Atn.PredicateEvalInfo.semctx"/>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredicateEvalInfo.#ctor(Antlr4.Runtime.Atn.SimulatorState,System.Int32,Antlr4.Runtime.ITokenStream,System.Int32,System.Int32,Antlr4.Runtime.Atn.SemanticContext,System.Boolean,System.Int32)">
            <summary>
            Constructs a new instance of the
            <see cref="T:Antlr4.Runtime.Atn.PredicateEvalInfo"/>
            class with the
            specified detailed predicate evaluation information.
            </summary>
            <param name="state">The simulator state</param>
            <param name="decision">The decision number</param>
            <param name="input">The input token stream</param>
            <param name="startIndex">The start index for the current prediction</param>
            <param name="stopIndex">
            The index at which the predicate evaluation was
            triggered. Note that the input stream may be reset to other positions for
            the actual evaluation of individual predicates.
            </param>
            <param name="semctx">The semantic context which was evaluated</param>
            <param name="evalResult">The results of evaluating the semantic context</param>
            <param name="predictedAlt">
            The alternative number for the decision which is
            guarded by the semantic context
            <paramref name="semctx"/>
            . See
            <see cref="F:Antlr4.Runtime.Atn.PredicateEvalInfo.predictedAlt"/>
            for more information.
            </param>
            <seealso cref="M:Antlr4.Runtime.Atn.ParserATNSimulator.EvalSemanticContext(Antlr4.Runtime.Atn.SemanticContext,Antlr4.Runtime.ParserRuleContext,System.Int32,System.Boolean)"/>
            <seealso cref="M:Antlr4.Runtime.Atn.SemanticContext.Eval``2(Antlr4.Runtime.Recognizer{``0,``1},Antlr4.Runtime.RuleContext)"/>
        </member>
        <member name="T:Antlr4.Runtime.Atn.PredicateTransition">
            <summary>
            TODO: this is old comment:
            A tree of semantic predicates from the grammar AST if label==SEMPRED.
            </summary>
            <remarks>
            TODO: this is old comment:
            A tree of semantic predicates from the grammar AST if label==SEMPRED.
            In the ATN, labels will always be exactly one predicate, but the DFA
            may have to combine a bunch of them as it collects predicates from
            multiple ATN configurations into a single DFA state.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionContextCache.Add(Antlr4.Runtime.Atn.PredictionContext)">
            Add a context to the cache and return it. If the context already exists,
            return that one instead and do not add a new context to the cache.
            Protect shared cache from unsafe thread access.
        </member>
        <member name="T:Antlr4.Runtime.Atn.PredictionMode">
            <summary>
            This enumeration defines the prediction modes available in ANTLR 4 along with
            utility methods for analyzing configuration sets for conflicts and/or
            ambiguities.
            </summary>
            <remarks>
            This enumeration defines the prediction modes available in ANTLR 4 along with
            utility methods for analyzing configuration sets for conflicts and/or
            ambiguities.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.PredictionMode.SLL">
            <summary>The SLL(*) prediction mode.</summary>
            <remarks>
            The SLL(*) prediction mode. This prediction mode ignores the current
            parser context when making predictions. This is the fastest prediction
            mode, and provides correct results for many grammars. This prediction
            mode is more powerful than the prediction mode provided by ANTLR 3, but
            may result in syntax errors for grammar and input combinations which are
            not SLL.
            <p>
            When using this prediction mode, the parser will either return a correct
            parse tree (i.e. the same parse tree that would be returned with the
            <see cref="F:Antlr4.Runtime.Atn.PredictionMode.LL"/>
            prediction mode), or it will report a syntax error. If a
            syntax error is encountered when using the
            <see cref="F:Antlr4.Runtime.Atn.PredictionMode.SLL"/>
            prediction mode,
            it may be due to either an actual syntax error in the input or indicate
            that the particular combination of grammar and input requires the more
            powerful
            <see cref="F:Antlr4.Runtime.Atn.PredictionMode.LL"/>
            prediction abilities to complete successfully.</p>
            <p>
            This prediction mode does not provide any guarantees for prediction
            behavior for syntactically-incorrect inputs.</p>
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.PredictionMode.LL">
            <summary>The LL(*) prediction mode.</summary>
            <remarks>
            The LL(*) prediction mode. This prediction mode allows the current parser
            context to be used for resolving SLL conflicts that occur during
            prediction. This is the fastest prediction mode that guarantees correct
            parse results for all combinations of grammars with syntactically correct
            inputs.
            <p>
            When using this prediction mode, the parser will make correct decisions
            for all syntactically-correct grammar and input combinations. However, in
            cases where the grammar is truly ambiguous this prediction mode might not
            report a precise answer for <em>exactly which</em> alternatives are
            ambiguous.</p>
            <p>
            This prediction mode does not provide any guarantees for prediction
            behavior for syntactically-incorrect inputs.</p>
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.PredictionMode.LL_EXACT_AMBIG_DETECTION">
            <summary>The LL(*) prediction mode with exact ambiguity detection.</summary>
            <remarks>
            The LL(*) prediction mode with exact ambiguity detection. In addition to
            the correctness guarantees provided by the
            <see cref="F:Antlr4.Runtime.Atn.PredictionMode.LL"/>
            prediction mode,
            this prediction mode instructs the prediction algorithm to determine the
            complete and exact set of ambiguous alternatives for every ambiguous
            decision encountered while parsing.
            <p>
            This prediction mode may be used for diagnosing ambiguities during
            grammar development. Due to the performance overhead of calculating sets
            of ambiguous alternatives, this prediction mode should be avoided when
            the exact results are not necessary.</p>
            <p>
            This prediction mode does not provide any guarantees for prediction
            behavior for syntactically-incorrect inputs.</p>
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.Atn.PredictionMode.AltAndContextMap">
            <summary>A Map that uses just the state and the stack context as the key.</summary>
            <remarks>A Map that uses just the state and the stack context as the key.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionMode.AltAndContextConfigEqualityComparator.GetHashCode(Antlr4.Runtime.Atn.ATNConfig)">
            <summary>
            The hash code is only a function of the
            <see cref="F:Antlr4.Runtime.Atn.ATNState.stateNumber"/>
            and
            <see cref="F:Antlr4.Runtime.Atn.ATNConfig.context"/>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionMode.HasSLLConflictTerminatingPrediction(Antlr4.Runtime.Atn.PredictionMode,Antlr4.Runtime.Atn.ATNConfigSet)">
             <summary>Computes the SLL prediction termination condition.</summary>
             <remarks>
             Computes the SLL prediction termination condition.
             <p>
             This method computes the SLL prediction termination condition for both of
             the following cases.</p>
             <ul>
             <li>The usual SLL+LL fallback upon SLL conflict</li>
             <li>Pure SLL without LL fallback</li>
             </ul>
             <p><strong>COMBINED SLL+LL PARSING</strong></p>
             <p>When LL-fallback is enabled upon SLL conflict, correct predictions are
             ensured regardless of how the termination condition is computed by this
             method. Due to the substantially higher cost of LL prediction, the
             prediction should only fall back to LL when the additional lookahead
             cannot lead to a unique SLL prediction.</p>
             <p>Assuming combined SLL+LL parsing, an SLL configuration set with only
             conflicting subsets should fall back to full LL, even if the
             configuration sets don't resolve to the same alternative (e.g.
             <c/>
            
             1,2}} and
             <c/>
            
             3,4}}. If there is at least one non-conflicting
             configuration, SLL could continue with the hopes that more lookahead will
             resolve via one of those non-conflicting configurations.</p>
             <p>Here's the prediction termination rule them: SLL (for SLL+LL parsing)
             stops when it sees only conflicting configuration subsets. In contrast,
             full LL keeps going when there is uncertainty.</p>
             <p><strong>HEURISTIC</strong></p>
             <p>As a heuristic, we stop prediction when we see any conflicting subset
             unless we see a state that only has one alternative associated with it.
             The single-alt-state thing lets prediction continue upon rules like
             (otherwise, it would admit defeat too soon):</p>
             <p>
             <c>[12|1|[], 6|2|[], 12|2|[]]. s : (ID | ID ID?) ';' ;</c>
             </p>
             <p>When the ATN simulation reaches the state before
             <c>';'</c>
             , it has a
             DFA state that looks like:
             <c>[12|1|[], 6|2|[], 12|2|[]]</c>
             . Naturally
             <c>12|1|[]</c>
             and
             <c>12|2|[]</c>
             conflict, but we cannot stop
             processing this node because alternative to has another way to continue,
             via
             <c>[6|2|[]]</c>
             .</p>
             <p>It also let's us continue for this rule:</p>
             <p>
             <c>[1|1|[], 1|2|[], 8|3|[]] a : A | A | A B ;</c>
             </p>
             <p>After matching input A, we reach the stop state for rule A, state 1.
             State 8 is the state right before B. Clearly alternatives 1 and 2
             conflict and no amount of further lookahead will separate the two.
             However, alternative 3 will be able to continue and so we do not stop
             working on this state. In the previous example, we're concerned with
             states associated with the conflicting alternatives. Here alt 3 is not
             associated with the conflicting configs, but since we can continue
             looking for input reasonably, don't declare the state done.</p>
             <p><strong>PURE SLL PARSING</strong></p>
             <p>To handle pure SLL parsing, all we have to do is make sure that we
             combine stack contexts for configurations that differ only by semantic
             predicate. From there, we can do the usual SLL termination heuristic.</p>
             <p><strong>PREDICATES IN SLL+LL PARSING</strong></p>
             <p>SLL decisions don't evaluate predicates until after they reach DFA stop
             states because they need to create the DFA cache that works in all
             semantic situations. In contrast, full LL evaluates predicates collected
             during start state computation so it can ignore predicates thereafter.
             This means that SLL termination detection can totally ignore semantic
             predicates.</p>
             <p>Implementation-wise,
             <see cref="T:Antlr4.Runtime.Atn.ATNConfigSet"/>
             combines stack contexts but not
             semantic predicate contexts so we might see two configurations like the
             following.</p>
             <p>
             <c/>
             (s, 1, x,
             ), (s, 1, x', {p})}</p>
             <p>Before testing these configurations against others, we have to merge
             <c>x</c>
             and
             <c>x'</c>
             (without modifying the existing configurations).
             For example, we test
             <c>(x+x')==x''</c>
             when looking for conflicts in
             the following configurations.</p>
             <p>
             <c/>
             (s, 1, x,
             ), (s, 1, x', {p}), (s, 2, x'', {})}</p>
             <p>If the configuration set has predicates (as indicated by
             <see cref="F:Antlr4.Runtime.Atn.ATNConfigSet.hasSemanticContext"/>
             ), this algorithm makes a copy of
             the configurations to strip out all of the predicates so that a standard
             <see cref="T:Antlr4.Runtime.Atn.ATNConfigSet"/>
             will merge everything ignoring predicates.</p>
             </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionMode.HasConfigInRuleStopState(System.Collections.Generic.IEnumerable{Antlr4.Runtime.Atn.ATNConfig})">
             <summary>
             Checks if any configuration in
             <paramref name="configs"/>
             is in a
             <see cref="T:Antlr4.Runtime.Atn.RuleStopState"/>
             . Configurations meeting this condition have reached
             the end of the decision rule (local context) or end of start rule (full
             context).
             </summary>
             <param name="configs">the configuration set to test</param>
             <returns>
            
             <see langword="true"/>
             if any configuration in
             <paramref name="configs"/>
             is in a
             <see cref="T:Antlr4.Runtime.Atn.RuleStopState"/>
             , otherwise
             <see langword="false"/>
             </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionMode.AllConfigsInRuleStopStates(System.Collections.Generic.IEnumerable{Antlr4.Runtime.Atn.ATNConfig})">
             <summary>
             Checks if all configurations in
             <paramref name="configs"/>
             are in a
             <see cref="T:Antlr4.Runtime.Atn.RuleStopState"/>
             . Configurations meeting this condition have reached
             the end of the decision rule (local context) or end of start rule (full
             context).
             </summary>
             <param name="configs">the configuration set to test</param>
             <returns>
            
             <see langword="true"/>
             if all configurations in
             <paramref name="configs"/>
             are in a
             <see cref="T:Antlr4.Runtime.Atn.RuleStopState"/>
             , otherwise
             <see langword="false"/>
             </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionMode.ResolvesToJustOneViableAlt(System.Collections.Generic.IEnumerable{Antlr4.Runtime.Sharpen.BitSet})">
             <summary>Full LL prediction termination.</summary>
             <remarks>
             Full LL prediction termination.
             <p>Can we stop looking ahead during ATN simulation or is there some
             uncertainty as to which alternative we will ultimately pick, after
             consuming more input? Even if there are partial conflicts, we might know
             that everything is going to resolve to the same minimum alternative. That
             means we can stop since no more lookahead will change that fact. On the
             other hand, there might be multiple conflicts that resolve to different
             minimums. That means we need more look ahead to decide which of those
             alternatives we should predict.</p>
             <p>The basic idea is to split the set of configurations
             <c>C</c>
             , into
             conflicting subsets
             <c>(s, _, ctx, _)</c>
             and singleton subsets with
             non-conflicting configurations. Two configurations conflict if they have
             identical
             <see cref="F:Antlr4.Runtime.Atn.ATNConfig.state"/>
             and
             <see cref="F:Antlr4.Runtime.Atn.ATNConfig.context"/>
             values
             but different
             <see cref="F:Antlr4.Runtime.Atn.ATNConfig.alt"/>
             value, e.g.
             <c>(s, i, ctx, _)</c>
             and
             <c>(s, j, ctx, _)</c>
             for
             <c>i!=j</c>
             .</p>
             <p/>
             Reduce these configuration subsets to the set of possible alternatives.
             You can compute the alternative subsets in one pass as follows:
             <p/>
             <c/>
             A_s,ctx =
             i | (s, i, ctx, _)}} for each configuration in
             <c>C</c>
             holding
             <c>s</c>
             and
             <c>ctx</c>
             fixed.
             <p/>
             Or in pseudo-code, for each configuration
             <c>c</c>
             in
             <c>C</c>
             :
             <pre>
             map[c] U= c.
             <see cref="F:Antlr4.Runtime.Atn.ATNConfig.alt">getAlt()</see>
             # map hash/equals uses s and x, not
             alt and not pred
             </pre>
             <p>The values in
             <c>map</c>
             are the set of
             <c>A_s,ctx</c>
             sets.</p>
             <p>If
             <c>|A_s,ctx|=1</c>
             then there is no conflict associated with
             <c>s</c>
             and
             <c>ctx</c>
             .</p>
             <p>Reduce the subsets to singletons by choosing a minimum of each subset. If
             the union of these alternative subsets is a singleton, then no amount of
             more lookahead will help us. We will always pick that alternative. If,
             however, there is more than one alternative, then we are uncertain which
             alternative to predict and must continue looking for resolution. We may
             or may not discover an ambiguity in the future, even if there are no
             conflicting subsets this round.</p>
             <p>The biggest sin is to terminate early because it means we've made a
             decision but were uncertain as to the eventual outcome. We haven't used
             enough lookahead. On the other hand, announcing a conflict too late is no
             big deal; you will still have the conflict. It's just inefficient. It
             might even look until the end of file.</p>
             <p>No special consideration for semantic predicates is required because
             predicates are evaluated on-the-fly for full LL prediction, ensuring that
             no configuration contains a semantic context during the termination
             check.</p>
             <p><strong>CONFLICTING CONFIGS</strong></p>
             <p>Two configurations
             <c>(s, i, x)</c>
             and
             <c>(s, j, x')</c>
             , conflict
             when
             <c>i!=j</c>
             but
             <c>x=x'</c>
             . Because we merge all
             <c>(s, i, _)</c>
             configurations together, that means that there are at
             most
             <c>n</c>
             configurations associated with state
             <c>s</c>
             for
             <c>n</c>
             possible alternatives in the decision. The merged stacks
             complicate the comparison of configuration contexts
             <c>x</c>
             and
             <c>x'</c>
             . Sam checks to see if one is a subset of the other by calling
             merge and checking to see if the merged result is either
             <c>x</c>
             or
             <c>x'</c>
             . If the
             <c>x</c>
             associated with lowest alternative
             <c>i</c>
             is the superset, then
             <c>i</c>
             is the only possible prediction since the
             others resolve to
             <c>min(i)</c>
             as well. However, if
             <c>x</c>
             is
             associated with
             <c>j&gt;i</c>
             then at least one stack configuration for
             <c>j</c>
             is not in conflict with alternative
             <c>i</c>
             . The algorithm
             should keep going, looking for more lookahead due to the uncertainty.</p>
             <p>For simplicity, I'm doing a equality check between
             <c>x</c>
             and
             <c>x'</c>
             that lets the algorithm continue to consume lookahead longer
             than necessary. The reason I like the equality is of course the
             simplicity but also because that is the test you need to detect the
             alternatives that are actually in conflict.</p>
             <p><strong>CONTINUE/STOP RULE</strong></p>
             <p>Continue if union of resolved alternative sets from non-conflicting and
             conflicting alternative subsets has more than one alternative. We are
             uncertain about which alternative to predict.</p>
             <p>The complete set of alternatives,
             <c>[i for (_,i,_)]</c>
             , tells us which
             alternatives are still in the running for the amount of input we've
             consumed at this point. The conflicting sets let us to strip away
             configurations that won't lead to more states because we resolve
             conflicts to the configuration with a minimum alternate for the
             conflicting set.</p>
             <p><strong>CASES</strong></p>
             <ul>
             <li>no conflicts and more than 1 alternative in set =&gt; continue</li>
             <li>
             <c>(s, 1, x)</c>
             ,
             <c>(s, 2, x)</c>
             ,
             <c>(s, 3, z)</c>
             ,
             <c>(s', 1, y)</c>
             ,
             <c>(s', 2, y)</c>
             yields non-conflicting set
             <c/>
            
             3}} U conflicting sets
             <c/>
             min(
             1,2})} U
             <c/>
             min(
             1,2})} =
             <c/>
            
             1,3}} =&gt; continue
             </li>
             <li>
             <c>(s, 1, x)</c>
             ,
             <c>(s, 2, x)</c>
             ,
             <c>(s', 1, y)</c>
             ,
             <c>(s', 2, y)</c>
             ,
             <c>(s'', 1, z)</c>
             yields non-conflicting set
             <c/>
            
             1}} U conflicting sets
             <c/>
             min(
             1,2})} U
             <c/>
             min(
             1,2})} =
             <c/>
            
             1}} =&gt; stop and predict 1</li>
             <li>
             <c>(s, 1, x)</c>
             ,
             <c>(s, 2, x)</c>
             ,
             <c>(s', 1, y)</c>
             ,
             <c>(s', 2, y)</c>
             yields conflicting, reduced sets
             <c/>
            
             1}} U
             <c/>
            
             1}} =
             <c/>
            
             1}} =&gt; stop and predict 1, can announce
             ambiguity
             <c/>
            
             1,2}}</li>
             <li>
             <c>(s, 1, x)</c>
             ,
             <c>(s, 2, x)</c>
             ,
             <c>(s', 2, y)</c>
             ,
             <c>(s', 3, y)</c>
             yields conflicting, reduced sets
             <c/>
            
             1}} U
             <c/>
            
             2}} =
             <c/>
            
             1,2}} =&gt; continue</li>
             <li>
             <c>(s, 1, x)</c>
             ,
             <c>(s, 2, x)</c>
             ,
             <c>(s', 3, y)</c>
             ,
             <c>(s', 4, y)</c>
             yields conflicting, reduced sets
             <c/>
            
             1}} U
             <c/>
            
             3}} =
             <c/>
            
             1,3}} =&gt; continue</li>
             </ul>
             <p><strong>EXACT AMBIGUITY DETECTION</strong></p>
             <p>If all states report the same conflicting set of alternatives, then we
             know we have the exact ambiguity set.</p>
             <p><code>|A_<em>i</em>|&gt;1</code> and
             <code>A_<em>i</em> = A_<em>j</em></code> for all <em>i</em>, <em>j</em>.</p>
             <p>In other words, we continue examining lookahead until all
             <c>A_i</c>
             have more than one alternative and all
             <c>A_i</c>
             are the same. If
             <c/>
             A=
             {1,2}, {1,3}}}, then regular LL prediction would terminate
             because the resolved set is
             <c/>
            
             1}}. To determine what the real
             ambiguity is, we have to know whether the ambiguity is between one and
             two or one and three so we keep going. We can only stop prediction when
             we need exact ambiguity detection when the sets look like
             <c/>
             A=
             {1,2}}} or
             <c/>
            
             {1,2},{1,2}}}, etc...</p>
             </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionMode.AllSubsetsConflict(System.Collections.Generic.IEnumerable{Antlr4.Runtime.Sharpen.BitSet})">
             <summary>
             Determines if every alternative subset in
             <paramref name="altsets"/>
             contains more
             than one alternative.
             </summary>
             <param name="altsets">a collection of alternative subsets</param>
             <returns>
            
             <see langword="true"/>
             if every
             <see cref="T:Antlr4.Runtime.Sharpen.BitSet"/>
             in
             <paramref name="altsets"/>
             has
             <see cref="M:Antlr4.Runtime.Sharpen.BitSet.Cardinality">cardinality</see>
             &gt; 1, otherwise
             <see langword="false"/>
             </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionMode.HasNonConflictingAltSet(System.Collections.Generic.IEnumerable{Antlr4.Runtime.Sharpen.BitSet})">
             <summary>
             Determines if any single alternative subset in
             <paramref name="altsets"/>
             contains
             exactly one alternative.
             </summary>
             <param name="altsets">a collection of alternative subsets</param>
             <returns>
            
             <see langword="true"/>
             if
             <paramref name="altsets"/>
             contains a
             <see cref="T:Antlr4.Runtime.Sharpen.BitSet"/>
             with
             <see cref="M:Antlr4.Runtime.Sharpen.BitSet.Cardinality">cardinality</see>
             1, otherwise
             <see langword="false"/>
             </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionMode.HasConflictingAltSet(System.Collections.Generic.IEnumerable{Antlr4.Runtime.Sharpen.BitSet})">
             <summary>
             Determines if any single alternative subset in
             <paramref name="altsets"/>
             contains
             more than one alternative.
             </summary>
             <param name="altsets">a collection of alternative subsets</param>
             <returns>
            
             <see langword="true"/>
             if
             <paramref name="altsets"/>
             contains a
             <see cref="T:Antlr4.Runtime.Sharpen.BitSet"/>
             with
             <see cref="M:Antlr4.Runtime.Sharpen.BitSet.Cardinality">cardinality</see>
             &gt; 1, otherwise
             <see langword="false"/>
             </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionMode.AllSubsetsEqual(System.Collections.Generic.IEnumerable{Antlr4.Runtime.Sharpen.BitSet})">
             <summary>
             Determines if every alternative subset in
             <paramref name="altsets"/>
             is equivalent.
             </summary>
             <param name="altsets">a collection of alternative subsets</param>
             <returns>
            
             <see langword="true"/>
             if every member of
             <paramref name="altsets"/>
             is equal to the
             others, otherwise
             <see langword="false"/>
             </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionMode.GetUniqueAlt(System.Collections.Generic.IEnumerable{Antlr4.Runtime.Sharpen.BitSet})">
            <summary>
            Returns the unique alternative predicted by all alternative subsets in
            <paramref name="altsets"/>
            . If no such alternative exists, this method returns
            <see cref="F:Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER"/>
            .
            </summary>
            <param name="altsets">a collection of alternative subsets</param>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionMode.GetAlts(System.Collections.Generic.IEnumerable{Antlr4.Runtime.Sharpen.BitSet})">
            <summary>
            Gets the complete set of represented alternatives for a collection of
            alternative subsets.
            </summary>
            <remarks>
            Gets the complete set of represented alternatives for a collection of
            alternative subsets. This method returns the union of each
            <see cref="T:Antlr4.Runtime.Sharpen.BitSet"/>
            in
            <paramref name="altsets"/>
            .
            </remarks>
            <param name="altsets">a collection of alternative subsets</param>
            <returns>
            the set of represented alternatives in
            <paramref name="altsets"/>
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionMode.GetConflictingAltSubsets(System.Collections.Generic.IEnumerable{Antlr4.Runtime.Atn.ATNConfig})">
            <summary>This function gets the conflicting alt subsets from a configuration set.</summary>
            <remarks>
            This function gets the conflicting alt subsets from a configuration set.
            For each configuration
            <c>c</c>
            in
            <paramref name="configs"/>
            :
            <pre>
            map[c] U= c.
            <see cref="F:Antlr4.Runtime.Atn.ATNConfig.alt">getAlt()</see>
            # map hash/equals uses s and x, not
            alt and not pred
            </pre>
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionMode.GetStateToAltMap(System.Collections.Generic.IEnumerable{Antlr4.Runtime.Atn.ATNConfig})">
            <summary>Get a map from state to alt subset from a configuration set.</summary>
            <remarks>
            Get a map from state to alt subset from a configuration set. For each
            configuration
            <c>c</c>
            in
            <paramref name="configs"/>
            :
            <pre>
            map[c.
            <see cref="F:Antlr4.Runtime.Atn.ATNConfig.state"/>
            ] U= c.
            <see cref="F:Antlr4.Runtime.Atn.ATNConfig.alt"/>
            </pre>
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.Atn.ProfilingATNSimulator">
            @since 4.3
        </member>
        <member name="F:Antlr4.Runtime.Atn.ProfilingATNSimulator.conflictingAltResolvedBySLL">
            At the point of LL failover, we record how SLL would resolve the conflict so that
            we can determine whether or not a decision / input pair is context-sensitive.
            If LL gives a different result than SLL's predicted alternative, we have a
            context sensitivity for sure. The converse is not necessarily true, however.
            It's possible that after conflict resolution chooses minimum alternatives,
            SLL could get the same answer as LL. Regardless of whether or not the result indicates
            an ambiguity, it is not treated as a context sensitivity because LL prediction
            was not required in order to produce a correct prediction for this decision and input sequence.
            It may in fact still be a context sensitivity but we don't know by looking at the
            minimum alternatives for the current input.
        </member>
        <member name="T:Antlr4.Runtime.Atn.RuleStopState">
            <summary>The last node in the ATN for a rule, unless that rule is the start symbol.</summary>
            <remarks>
            The last node in the ATN for a rule, unless that rule is the start symbol.
            In that case, there is one transition to EOF. Later, we might encode
            references to all calls to this rule to compute FOLLOW sets for
            error handling.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.RuleTransition.ruleIndex">
            <summary>Ptr to the rule definition object for this rule ref</summary>
        </member>
        <member name="F:Antlr4.Runtime.Atn.RuleTransition.followState">
            <summary>What node to begin computations following ref to rule</summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.SetTransition">
            <summary>A transition containing a set of values.</summary>
            <remarks>A transition containing a set of values.</remarks>
        </member>
        <member name="T:Antlr4.Runtime.Atn.SimulatorState">
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Atn.StarBlockStartState">
            <summary>The block that begins a closure loop.</summary>
            <remarks>The block that begins a closure loop.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.StarLoopEntryState.isPrecedenceDecision">
            <summary>
            Indicates whether this state can benefit from a precedence DFA during SLL
            decision making.
            </summary>
            <remarks>
            Indicates whether this state can benefit from a precedence DFA during SLL
            decision making.
            <p>This is a computed property that is calculated during ATN deserialization
            and stored for use in
            <see cref="T:Antlr4.Runtime.Atn.ParserATNSimulator"/>
            and
            <see cref="T:Antlr4.Runtime.ParserInterpreter"/>
            .</p>
            </remarks>
            <seealso cref="P:Antlr4.Runtime.Dfa.DFA.IsPrecedenceDfa"/>
        </member>
        <member name="T:Antlr4.Runtime.Atn.TokensStartState">
            <summary>The Tokens rule start state linking to each lexer rule start state</summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.Transition">
            <summary>An ATN transition between any two ATN states.</summary>
            <remarks>
            An ATN transition between any two ATN states.  Subclasses define
            atom, set, epsilon, action, predicate, rule transitions.
            <p>This is a one way link.  It emanates from a state (usually via a list of
            transitions) and has a target state.</p>
            <p>Since we never have to change the ATN transitions once we construct it,
            we can fix these transitions as specific classes. The DFA transitions
            on the other hand need to update the labels as it adds transitions to
            the states. We'll use the term Edge for the DFA to distinguish them from
            ATN transitions.</p>
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.Transition.target">
            <summary>The target of this transition.</summary>
            <remarks>The target of this transition.</remarks>
        </member>
        <member name="P:Antlr4.Runtime.Atn.Transition.IsEpsilon">
             <summary>Determines if the transition is an "epsilon" transition.</summary>
             <remarks>
             Determines if the transition is an "epsilon" transition.
             <p>The default implementation returns
             <see langword="false"/>
             .</p>
             </remarks>
             <returns>
            
             <see langword="true"/>
             if traversing this transition in the ATN does not
             consume an input symbol; otherwise,
             <see langword="false"/>
             if traversing this
             transition consumes (matches) an input symbol.
             </returns>
        </member>
        <member name="T:Antlr4.Runtime.BailErrorStrategy">
            <summary>
            This implementation of
            <see cref="T:Antlr4.Runtime.IAntlrErrorStrategy"/>
            responds to syntax errors
            by immediately canceling the parse operation with a
            <see cref="T:Antlr4.Runtime.Misc.ParseCanceledException"/>
            . The implementation ensures that the
            <see cref="F:Antlr4.Runtime.ParserRuleContext.exception"/>
            field is set for all parse tree nodes
            that were not completed prior to encountering the error.
            <p>
            This error strategy is useful in the following scenarios.</p>
            <ul>
            <li><strong>Two-stage parsing:</strong> This error strategy allows the first
            stage of two-stage parsing to immediately terminate if an error is
            encountered, and immediately fall back to the second stage. In addition to
            avoiding wasted work by attempting to recover from errors here, the empty
            implementation of
            <see cref="M:Antlr4.Runtime.BailErrorStrategy.Sync(Antlr4.Runtime.Parser)"/>
            improves the performance of
            the first stage.</li>
            <li><strong>Silent validation:</strong> When syntax errors are not being
            reported or logged, and the parse result is simply ignored if errors occur,
            the
            <see cref="T:Antlr4.Runtime.BailErrorStrategy"/>
            avoids wasting work on recovering from errors
            when the result will be ignored either way.</li>
            </ul>
            <p>
            <c>myparser.setErrorHandler(new BailErrorStrategy());</c>
            </p>
            </summary>
            <seealso cref="P:Antlr4.Runtime.Parser.ErrorHandler"/>
        </member>
        <member name="M:Antlr4.Runtime.BailErrorStrategy.Recover(Antlr4.Runtime.Parser,Antlr4.Runtime.RecognitionException)">
            <summary>
            Instead of recovering from exception
            <paramref name="e"/>
            , re-throw it wrapped
            in a
            <see cref="T:Antlr4.Runtime.Misc.ParseCanceledException"/>
            so it is not caught by the
            rule function catches.  Use
            <see cref="P:System.Exception.InnerException"/>
            to get the
            original
            <see cref="T:Antlr4.Runtime.RecognitionException"/>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.BailErrorStrategy.RecoverInline(Antlr4.Runtime.Parser)">
            <summary>
            Make sure we don't attempt to recover inline; if the parser
            successfully recovers, it won't throw an exception.
            </summary>
            <remarks>
            Make sure we don't attempt to recover inline; if the parser
            successfully recovers, it won't throw an exception.
            </remarks>
            <exception cref="T:Antlr4.Runtime.RecognitionException"/>
        </member>
        <member name="M:Antlr4.Runtime.BailErrorStrategy.Sync(Antlr4.Runtime.Parser)">
            <summary>Make sure we don't attempt to recover from problems in subrules.</summary>
            <remarks>Make sure we don't attempt to recover from problems in subrules.</remarks>
        </member>
        <member name="T:Antlr4.Runtime.BaseErrorListener">
            <summary>
            Provides an empty default implementation of
            <see cref="T:Antlr4.Runtime.IAntlrErrorListener`1"/>
            . The
            default implementation of each method does nothing, but can be overridden as
            necessary.
            </summary>
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.BufferedTokenStream">
            <summary>
            This implementation of
            <see cref="T:Antlr4.Runtime.ITokenStream"/>
            loads tokens from a
            <see cref="T:Antlr4.Runtime.ITokenSource"/>
            on-demand, and places the tokens in a buffer to provide
            access to any previous token by index.
            <p>
            This token stream ignores the value of
            <see cref="P:Antlr4.Runtime.IToken.Channel"/>
            . If your
            parser requires the token stream filter tokens to only those on a particular
            channel, such as
            <see cref="F:Antlr4.Runtime.TokenConstants.DefaultChannel"/>
            or
            <see cref="F:Antlr4.Runtime.TokenConstants.HiddenChannel"/>
            , use a filtering token stream such a
            <see cref="T:Antlr4.Runtime.CommonTokenStream"/>
            .</p>
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.BufferedTokenStream._tokenSource">
            <summary>
            The
            <see cref="T:Antlr4.Runtime.ITokenSource"/>
            from which tokens for this stream are fetched.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.BufferedTokenStream.tokens">
            <summary>A collection of all tokens fetched from the token source.</summary>
            <remarks>
            A collection of all tokens fetched from the token source. The list is
            considered a complete view of the input once
            <see cref="F:Antlr4.Runtime.BufferedTokenStream.fetchedEOF"/>
            is set
            to
            <see langword="true"/>
            .
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.BufferedTokenStream.p">
            <summary>
            The index into
            <see cref="F:Antlr4.Runtime.BufferedTokenStream.tokens"/>
            of the current token (next token to
            <see cref="M:Antlr4.Runtime.BufferedTokenStream.Consume"/>
            ).
            <see cref="F:Antlr4.Runtime.BufferedTokenStream.tokens"/>
            <c>[</c>
            <see cref="F:Antlr4.Runtime.BufferedTokenStream.p"/>
            <c>]</c>
            should be
            <see cref="M:Antlr4.Runtime.BufferedTokenStream.LT(System.Int32)">LT(1)</see>
            .
            <p>This field is set to -1 when the stream is first constructed or when
            <see cref="M:Antlr4.Runtime.BufferedTokenStream.SetTokenSource(Antlr4.Runtime.ITokenSource)"/>
            is called, indicating that the first token has
            not yet been fetched from the token source. For additional information,
            see the documentation of
            <see cref="T:Antlr4.Runtime.IIntStream"/>
            for a description of
            Initializing Methods.</p>
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.BufferedTokenStream.fetchedEOF">
            <summary>
            Indicates whether the
            <see cref="F:Antlr4.Runtime.TokenConstants.EOF"/>
            token has been fetched from
            <see cref="F:Antlr4.Runtime.BufferedTokenStream._tokenSource"/>
            and added to
            <see cref="F:Antlr4.Runtime.BufferedTokenStream.tokens"/>
            . This field improves
            performance for the following cases:
            <ul>
            <li>
            <see cref="M:Antlr4.Runtime.BufferedTokenStream.Consume"/>
            : The lookahead check in
            <see cref="M:Antlr4.Runtime.BufferedTokenStream.Consume"/>
            to prevent
            consuming the EOF symbol is optimized by checking the values of
            <see cref="F:Antlr4.Runtime.BufferedTokenStream.fetchedEOF"/>
            and
            <see cref="F:Antlr4.Runtime.BufferedTokenStream.p"/>
            instead of calling
            <see cref="M:Antlr4.Runtime.BufferedTokenStream.LA(System.Int32)"/>
            .</li>
            <li>
            <see cref="M:Antlr4.Runtime.BufferedTokenStream.Fetch(System.Int32)"/>
            : The check to prevent adding multiple EOF symbols into
            <see cref="F:Antlr4.Runtime.BufferedTokenStream.tokens"/>
            is trivial with this field.</li>
            </ul>
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.Sync(System.Int32)">
             <summary>
             Make sure index
             <paramref name="i"/>
             in tokens has a token.
             </summary>
             <returns>
            
             <see langword="true"/>
             if a token is located at index
             <paramref name="i"/>
             , otherwise
             <see langword="false"/>
             .
             </returns>
             <seealso cref="M:Antlr4.Runtime.BufferedTokenStream.Get(System.Int32)"/>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.Fetch(System.Int32)">
            <summary>
            Add
            <paramref name="n"/>
            elements to buffer.
            </summary>
            <returns>The actual number of elements added to the buffer.</returns>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.Get(System.Int32,System.Int32)">
            <summary>Get all tokens from start..stop inclusively.</summary>
            <remarks>Get all tokens from start..stop inclusively.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.AdjustSeekIndex(System.Int32)">
            <summary>
            Allowed derived classes to modify the behavior of operations which change
            the current stream position by adjusting the target token index of a seek
            operation.
            </summary>
            <remarks>
            Allowed derived classes to modify the behavior of operations which change
            the current stream position by adjusting the target token index of a seek
            operation. The default implementation simply returns
            <paramref name="i"/>
            . If an
            exception is thrown in this method, the current stream index should not be
            changed.
            <p>For example,
            <see cref="T:Antlr4.Runtime.CommonTokenStream"/>
            overrides this method to ensure that
            the seek target is always an on-channel token.</p>
            </remarks>
            <param name="i">The target token index.</param>
            <returns>The adjusted target token index.</returns>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.SetTokenSource(Antlr4.Runtime.ITokenSource)">
            <summary>Reset this token stream by setting its token source.</summary>
            <remarks>Reset this token stream by setting its token source.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.GetTokens(System.Int32,System.Int32,Antlr4.Runtime.Sharpen.BitSet)">
            <summary>
            Given a start and stop index, return a
            <c>List</c>
            of all tokens in
            the token type
            <c>BitSet</c>
            .  Return
            <see langword="null"/>
            if no tokens were found.  This
            method looks at both on and off channel tokens.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.NextTokenOnChannel(System.Int32,System.Int32)">
            <summary>Given a starting index, return the index of the next token on channel.</summary>
            <remarks>
            Given a starting index, return the index of the next token on channel.
            Return
            <paramref name="i"/>
            if
            <c>tokens[i]</c>
            is on channel. Return the index of
            the EOF token if there are no tokens on channel between
            <paramref name="i"/>
            and
            EOF.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.PreviousTokenOnChannel(System.Int32,System.Int32)">
            <summary>
            Given a starting index, return the index of the previous token on
            channel.
            </summary>
            <remarks>
            Given a starting index, return the index of the previous token on
            channel. Return
            <paramref name="i"/>
            if
            <c>tokens[i]</c>
            is on channel. Return -1
            if there are no tokens on channel between
            <paramref name="i"/>
            and 0.
            <p>
            If
            <paramref name="i"/>
            specifies an index at or after the EOF token, the EOF token
            index is returned. This is due to the fact that the EOF token is treated
            as though it were on every channel.</p>
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.GetHiddenTokensToRight(System.Int32,System.Int32)">
            <summary>
            Collect all tokens on specified channel to the right of
            the current token up until we see a token on
            <see cref="F:Antlr4.Runtime.Lexer.DefaultTokenChannel"/>
            or
            EOF. If
            <paramref name="channel"/>
            is
            <c>-1</c>
            , find any non default channel token.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.GetHiddenTokensToRight(System.Int32)">
            <summary>
            Collect all hidden tokens (any off-default channel) to the right of
            the current token up until we see a token on
            <see cref="F:Antlr4.Runtime.Lexer.DefaultTokenChannel"/>
            or EOF.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.GetHiddenTokensToLeft(System.Int32,System.Int32)">
            <summary>
            Collect all tokens on specified channel to the left of
            the current token up until we see a token on
            <see cref="F:Antlr4.Runtime.Lexer.DefaultTokenChannel"/>
            .
            If
            <paramref name="channel"/>
            is
            <c>-1</c>
            , find any non default channel token.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.GetHiddenTokensToLeft(System.Int32)">
            <summary>
            Collect all hidden tokens (any off-default channel) to the left of
            the current token up until we see a token on
            <see cref="F:Antlr4.Runtime.Lexer.DefaultTokenChannel"/>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.GetText">
            <summary>Get the text of all tokens in this buffer.</summary>
            <remarks>Get the text of all tokens in this buffer.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.Fill">
            <summary>Get all tokens from lexer until EOF.</summary>
            <remarks>Get all tokens from lexer until EOF.</remarks>
        </member>
        <member name="T:Antlr4.Runtime.CharStreams">
             <summary>Utility class to create <see cref="T:Antlr4.Runtime.ICharStream"/>s from various sources of
             string data.
            
             The methods in this utility class support the full range of
             Unicode code points up to U+10FFFF, unlike <see cref="T:Antlr4.Runtime.AntlrInputStream"/>,
             which is limited to 16-bit Unicode code units up to U+FFFF.
             </summary>
        </member>
        <member name="M:Antlr4.Runtime.CharStreams.fromPath(System.String)">
             <summary>Creates an <see cref="T:Antlr4.Runtime.ICharStream"/> given a path to a UTF-8
             encoded file on disk.
            
             Reads the entire contents of the file into the result before returning.
             </summary>
        </member>
        <member name="M:Antlr4.Runtime.CharStreams.fromPath(System.String,System.Text.Encoding)">
             <summary>Creates an <see cref="T:Antlr4.Runtime.ICharStream"/> given a path to a
             file on disk and the encoding of the bytes contained in the file.
            
             Reads the entire contents of the file into the result before returning.
             </summary>
        </member>
        <member name="M:Antlr4.Runtime.CharStreams.fromTextReader(System.IO.TextReader)">
             <summary>Creates an <see cref="T:Antlr4.Runtime.ICharStream"/> given an opened
             <see cref="T:System.IO.TextReader"/>.
            
             Reads the entire contents of the TextReader then closes the reader before returning.
             </summary>
        </member>
        <member name="M:Antlr4.Runtime.CharStreams.fromStream(System.IO.Stream)">
             <summary>Creates an <see cref="T:Antlr4.Runtime.ICharStream"/> given an opened
             <see cref="T:System.IO.Stream"/> from which UTF-8 encoded bytes can be read.
            
             Reads the entire contents of the stream into the result then
             closes the stream before returning.
             </summary>
        </member>
        <member name="M:Antlr4.Runtime.CharStreams.fromStream(System.IO.Stream,System.Text.Encoding)">
             <summary>Creates an <see cref="T:Antlr4.Runtime.ICharStream"/> given an opened
             <see cref="T:System.IO.Stream"/> as well as the encoding of the bytes
             to be read from the stream.
            
             Reads the entire contents of the stream into the result then
             closes the stream before returning.
             </summary>
        </member>
        <member name="M:Antlr4.Runtime.CharStreams.fromstring(System.String)">
            <summary>Creates an <see cref="T:Antlr4.Runtime.ICharStream"/> given a <see cref="T:System.String"/>.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.CommonToken.EmptySource">
            <summary>
            An empty
            <see cref="T:Antlr4.Runtime.Sharpen.Tuple`2"/>
            which is used as the default value of
            <see cref="F:Antlr4.Runtime.CommonToken.source"/>
            for tokens that do not have a source.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.CommonToken._type">
            <summary>
            This is the backing field for the <see cref="P:Antlr4.Runtime.CommonToken.Type"/> property.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.CommonToken._line">
            <summary>
            This is the backing field for the <see cref="P:Antlr4.Runtime.CommonToken.Line"/> property.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.CommonToken.charPositionInLine">
            <summary>
            This is the backing field for the <see cref="P:Antlr4.Runtime.CommonToken.Column"/> property.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.CommonToken._channel">
            <summary>
            This is the backing field for the <see cref="P:Antlr4.Runtime.CommonToken.Channel"/> property.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.CommonToken.source">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.CommonToken.TokenSource"/>
            and
            <see cref="P:Antlr4.Runtime.CommonToken.InputStream"/>
            .
            <p>
            These properties share a field to reduce the memory footprint of
            <see cref="T:Antlr4.Runtime.CommonToken"/>
            . Tokens created by a
            <see cref="T:Antlr4.Runtime.CommonTokenFactory"/>
            from
            the same source and input stream share a reference to the same
            <see cref="T:Antlr4.Runtime.Sharpen.Tuple`2"/>
            containing these values.</p>
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.CommonToken._text">
            <summary>
            This is the backing field for the <see cref="P:Antlr4.Runtime.CommonToken.Text"/> property.
            </summary>
            <seealso cref="P:Antlr4.Runtime.CommonToken.Text"/>
        </member>
        <member name="F:Antlr4.Runtime.CommonToken.index">
            <summary>
            This is the backing field for the <see cref="P:Antlr4.Runtime.CommonToken.TokenIndex"/> property.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.CommonToken.start">
            <summary>
            This is the backing field for the <see cref="P:Antlr4.Runtime.CommonToken.StartIndex"/> property.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.CommonToken.stop">
            <summary>
            This is the backing field for the <see cref="P:Antlr4.Runtime.CommonToken.StopIndex"/> property.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.CommonToken.#ctor(System.Int32)">
            <summary>
            Constructs a new
            <see cref="T:Antlr4.Runtime.CommonToken"/>
            with the specified token type.
            </summary>
            <param name="type">The token type.</param>
        </member>
        <member name="M:Antlr4.Runtime.CommonToken.#ctor(System.Int32,System.String)">
            <summary>
            Constructs a new
            <see cref="T:Antlr4.Runtime.CommonToken"/>
            with the specified token type and
            text.
            </summary>
            <param name="type">The token type.</param>
            <param name="text">The text of the token.</param>
        </member>
        <member name="M:Antlr4.Runtime.CommonToken.#ctor(Antlr4.Runtime.IToken)">
            <summary>
            Constructs a new
            <see cref="T:Antlr4.Runtime.CommonToken"/>
            as a copy of another
            <see cref="T:Antlr4.Runtime.IToken"/>
            .
            <p>
            If
            <paramref name="oldToken"/>
            is also a
            <see cref="T:Antlr4.Runtime.CommonToken"/>
            instance, the newly
            constructed token will share a reference to the
            <see cref="P:Antlr4.Runtime.CommonToken.Text"/>
            field and
            the
            <see cref="T:Antlr4.Runtime.Sharpen.Tuple`2"/>
            stored in
            <see cref="F:Antlr4.Runtime.CommonToken.source"/>
            . Otherwise,
            <see cref="P:Antlr4.Runtime.CommonToken.Text"/>
            will
            be assigned the result of calling
            <see cref="P:Antlr4.Runtime.CommonToken.Text"/>
            , and
            <see cref="F:Antlr4.Runtime.CommonToken.source"/>
            will be constructed from the result of
            <see cref="P:Antlr4.Runtime.IToken.TokenSource"/>
            and
            <see cref="P:Antlr4.Runtime.IToken.InputStream"/>
            .</p>
            </summary>
            <param name="oldToken">The token to copy.</param>
        </member>
        <member name="P:Antlr4.Runtime.CommonToken.Text">
            <summary>Explicitly set the text for this token.</summary>
            <remarks>
            Explicitly set the text for this token. If {code text} is not
            <see langword="null"/>
            , then
            <see cref="P:Antlr4.Runtime.CommonToken.Text"/>
            will return this value rather than
            extracting the text from the input.
            </remarks>
            <value>
            The explicit text of the token, or
            <see langword="null"/>
            if the text
            should be obtained from the input along with the start and stop indexes
            of the token.
            </value>
        </member>
        <member name="T:Antlr4.Runtime.CommonTokenFactory">
            <summary>
            This default implementation of
            <see cref="T:Antlr4.Runtime.ITokenFactory"/>
            creates
            <see cref="T:Antlr4.Runtime.CommonToken"/>
            objects.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.CommonTokenFactory.Default">
            <summary>
            The default
            <see cref="T:Antlr4.Runtime.CommonTokenFactory"/>
            instance.
            <p>
            This token factory does not explicitly copy token text when constructing
            tokens.</p>
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.CommonTokenFactory.copyText">
            <summary>
            Indicates whether
            <see cref="P:Antlr4.Runtime.CommonToken.Text"/>
            should be called after
            constructing tokens to explicitly set the text. This is useful for cases
            where the input stream might not be able to provide arbitrary substrings
            of text from the input after the lexer creates a token (e.g. the
            implementation of
            <see cref="M:Antlr4.Runtime.ICharStream.GetText(Antlr4.Runtime.Misc.Interval)"/>
            in
            <see cref="T:Antlr4.Runtime.UnbufferedCharStream"/>
            throws an
            <see cref="T:System.NotSupportedException"/>
            ). Explicitly setting the token text
            allows
            <see cref="P:Antlr4.Runtime.IToken.Text"/>
            to be called at any time regardless of the
            input stream implementation.
            <p>
            The default value is
            <see langword="false"/>
            to avoid the performance and memory
            overhead of copying text for every token unless explicitly requested.</p>
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.CommonTokenFactory.#ctor(System.Boolean)">
            <summary>
            Constructs a
            <see cref="T:Antlr4.Runtime.CommonTokenFactory"/>
            with the specified value for
            <see cref="F:Antlr4.Runtime.CommonTokenFactory.copyText"/>
            .
            <p>
            When
            <paramref name="copyText"/>
            is
            <see langword="false"/>
            , the
            <see cref="F:Antlr4.Runtime.CommonTokenFactory.Default"/>
            instance
            should be used instead of constructing a new instance.</p>
            </summary>
            <param name="copyText">
            The value for
            <see cref="F:Antlr4.Runtime.CommonTokenFactory.copyText"/>
            .
            </param>
        </member>
        <member name="M:Antlr4.Runtime.CommonTokenFactory.#ctor">
            <summary>
            Constructs a
            <see cref="T:Antlr4.Runtime.CommonTokenFactory"/>
            with
            <see cref="F:Antlr4.Runtime.CommonTokenFactory.copyText"/>
            set to
            <see langword="false"/>
            .
            <p>
            The
            <see cref="F:Antlr4.Runtime.CommonTokenFactory.Default"/>
            instance should be used instead of calling this
            directly.</p>
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.CommonTokenStream">
            <summary>
            This class extends
            <see cref="T:Antlr4.Runtime.BufferedTokenStream"/>
            with functionality to filter
            token streams to tokens on a particular channel (tokens where
            <see cref="P:Antlr4.Runtime.IToken.Channel"/>
            returns a particular value).
            <p>
            This token stream provides access to all tokens by index or when calling
            methods like
            <see cref="M:Antlr4.Runtime.BufferedTokenStream.GetText"/>
            . The channel filtering is only used for code
            accessing tokens via the lookahead methods
            <see cref="M:Antlr4.Runtime.BufferedTokenStream.LA(System.Int32)"/>
            ,
            <see cref="M:Antlr4.Runtime.CommonTokenStream.LT(System.Int32)"/>
            , and
            <see cref="M:Antlr4.Runtime.CommonTokenStream.Lb(System.Int32)"/>
            .</p>
            <p>
            By default, tokens are placed on the default channel
            (
            <see cref="F:Antlr4.Runtime.TokenConstants.DefaultChannel"/>
            ), but may be reassigned by using the
            <c>-&gt;channel(HIDDEN)</c>
            lexer command, or by using an embedded action to
            call
            <see cref="P:Antlr4.Runtime.Lexer.Channel"/>
            .
            </p>
            <p>
            Note: lexer rules which use the
            <c>-&gt;skip</c>
            lexer command or call
            <see cref="M:Antlr4.Runtime.Lexer.Skip"/>
            do not produce tokens at all, so input text matched by
            such a rule will not be available as part of the token stream, regardless of
            channel.</p>
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.CommonTokenStream.channel">
            <summary>Specifies the channel to use for filtering tokens.</summary>
            <remarks>
            Specifies the channel to use for filtering tokens.
            <p>
            The default value is
            <see cref="F:Antlr4.Runtime.TokenConstants.DefaultChannel"/>
            , which matches the
            default channel assigned to tokens created by the lexer.</p>
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.CommonTokenStream.#ctor(Antlr4.Runtime.ITokenSource)">
            <summary>
            Constructs a new
            <see cref="T:Antlr4.Runtime.CommonTokenStream"/>
            using the specified token
            source and the default token channel (
            <see cref="F:Antlr4.Runtime.TokenConstants.DefaultChannel"/>
            ).
            </summary>
            <param name="tokenSource">The token source.</param>
        </member>
        <member name="M:Antlr4.Runtime.CommonTokenStream.#ctor(Antlr4.Runtime.ITokenSource,System.Int32)">
            <summary>
            Constructs a new
            <see cref="T:Antlr4.Runtime.CommonTokenStream"/>
            using the specified token
            source and filtering tokens to the specified channel. Only tokens whose
            <see cref="P:Antlr4.Runtime.IToken.Channel"/>
            matches
            <paramref name="channel"/>
            or have the
            <see cref="P:Antlr4.Runtime.IToken.Type"/>
            equal to
            <see cref="F:Antlr4.Runtime.TokenConstants.EOF"/>
            will be returned by the
            token stream lookahead methods.
            </summary>
            <param name="tokenSource">The token source.</param>
            <param name="channel">The channel to use for filtering tokens.</param>
        </member>
        <member name="M:Antlr4.Runtime.CommonTokenStream.GetNumberOfOnChannelTokens">
            <summary>Count EOF just once.</summary>
            <remarks>Count EOF just once.</remarks>
        </member>
        <member name="T:Antlr4.Runtime.ConsoleErrorListener`1">
            <author>Sam Harwell</author>
        </member>
        <member name="F:Antlr4.Runtime.ConsoleErrorListener`1.Instance">
            <summary>
            Provides a default instance of
            <see cref="T:Antlr4.Runtime.ConsoleErrorListener`1"/>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.ConsoleErrorListener`1.SyntaxError(System.IO.TextWriter,Antlr4.Runtime.IRecognizer,`0,System.Int32,System.Int32,System.String,Antlr4.Runtime.RecognitionException)">
            <summary>
            <inheritDoc/>
            <p>
            This implementation prints messages to
            <see cref="P:System.Console.Error"/>
            containing the
            values of
            <paramref name="line"/>
            ,
            <paramref name="charPositionInLine"/>
            , and
            <paramref name="msg"/>
            using
            the following format.</p>
            <pre>
            line <em>line</em>:<em>charPositionInLine</em> <em>msg</em>
            </pre>
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.DefaultErrorStrategy">
            <summary>
            This is the default implementation of
            <see cref="T:Antlr4.Runtime.IAntlrErrorStrategy"/>
            used for
            error reporting and recovery in ANTLR parsers.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.DefaultErrorStrategy.errorRecoveryMode">
            <summary>
            Indicates whether the error strategy is currently "recovering from an
            error".
            </summary>
            <remarks>
            Indicates whether the error strategy is currently "recovering from an
            error". This is used to suppress reporting multiple error messages while
            attempting to recover from a detected syntax error.
            </remarks>
            <seealso cref="M:Antlr4.Runtime.DefaultErrorStrategy.InErrorRecoveryMode(Antlr4.Runtime.Parser)"/>
        </member>
        <member name="F:Antlr4.Runtime.DefaultErrorStrategy.lastErrorIndex">
            <summary>The index into the input stream where the last error occurred.</summary>
            <remarks>
            The index into the input stream where the last error occurred.
            This is used to prevent infinite loops where an error is found
            but no token is consumed during recovery...another error is found,
            ad nauseum.  This is a failsafe mechanism to guarantee that at least
            one token/tree node is consumed for two errors.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.Reset(Antlr4.Runtime.Parser)">
            <summary>
            <inheritDoc/>
            <p>The default implementation simply calls
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.EndErrorCondition(Antlr4.Runtime.Parser)"/>
            to
            ensure that the handler is not in error recovery mode.</p>
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.BeginErrorCondition(Antlr4.Runtime.Parser)">
            <summary>
            This method is called to enter error recovery mode when a recognition
            exception is reported.
            </summary>
            <remarks>
            This method is called to enter error recovery mode when a recognition
            exception is reported.
            </remarks>
            <param name="recognizer">the parser instance</param>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.InErrorRecoveryMode(Antlr4.Runtime.Parser)">
            <summary><inheritDoc/></summary>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.EndErrorCondition(Antlr4.Runtime.Parser)">
            <summary>
            This method is called to leave error recovery mode after recovering from
            a recognition exception.
            </summary>
            <remarks>
            This method is called to leave error recovery mode after recovering from
            a recognition exception.
            </remarks>
            <param name="recognizer"/>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.ReportMatch(Antlr4.Runtime.Parser)">
            <summary>
            <inheritDoc/>
            <p>The default implementation simply calls
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.EndErrorCondition(Antlr4.Runtime.Parser)"/>
            .</p>
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.ReportError(Antlr4.Runtime.Parser,Antlr4.Runtime.RecognitionException)">
            <summary>
            <inheritDoc/>
            <p>The default implementation returns immediately if the handler is already
            in error recovery mode. Otherwise, it calls
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.BeginErrorCondition(Antlr4.Runtime.Parser)"/>
            and dispatches the reporting task based on the runtime type of
            <paramref name="e"/>
            according to the following table.</p>
            <ul>
            <li>
            <see cref="T:Antlr4.Runtime.NoViableAltException"/>
            : Dispatches the call to
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.ReportNoViableAlternative(Antlr4.Runtime.Parser,Antlr4.Runtime.NoViableAltException)"/>
            </li>
            <li>
            <see cref="T:Antlr4.Runtime.InputMismatchException"/>
            : Dispatches the call to
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.ReportInputMismatch(Antlr4.Runtime.Parser,Antlr4.Runtime.InputMismatchException)"/>
            </li>
            <li>
            <see cref="T:Antlr4.Runtime.FailedPredicateException"/>
            : Dispatches the call to
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.ReportFailedPredicate(Antlr4.Runtime.Parser,Antlr4.Runtime.FailedPredicateException)"/>
            </li>
            <li>All other types: calls
            <see cref="M:Antlr4.Runtime.Parser.NotifyErrorListeners(System.String)"/>
            to report
            the exception</li>
            </ul>
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.Recover(Antlr4.Runtime.Parser,Antlr4.Runtime.RecognitionException)">
            <summary>
            <inheritDoc/>
            <p>The default implementation resynchronizes the parser by consuming tokens
            until we find one in the resynchronization set--loosely the set of tokens
            that can follow the current rule.</p>
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.Sync(Antlr4.Runtime.Parser)">
            <summary>
            The default implementation of
            <see cref="M:Antlr4.Runtime.IAntlrErrorStrategy.Sync(Antlr4.Runtime.Parser)"/>
            makes sure
            that the current lookahead symbol is consistent with what were expecting
            at this point in the ATN. You can call this anytime but ANTLR only
            generates code to check before subrules/loops and each iteration.
            <p>Implements Jim Idle's magic sync mechanism in closures and optional
            subrules. E.g.,</p>
            <pre>
            a : sync ( stuff sync )* ;
            sync : {consume to what can follow sync} ;
            </pre>
            At the start of a sub rule upon error,
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.Sync(Antlr4.Runtime.Parser)"/>
            performs single
            token deletion, if possible. If it can't do that, it bails on the current
            rule and uses the default error recovery, which consumes until the
            resynchronization set of the current rule.
            <p>If the sub rule is optional (
            <c>(...)?</c>
            ,
            <c>(...)*</c>
            , or block
            with an empty alternative), then the expected set includes what follows
            the subrule.</p>
            <p>During loop iteration, it consumes until it sees a token that can start a
            sub rule or what follows loop. Yes, that is pretty aggressive. We opt to
            stay in the loop as long as possible.</p>
            <p><strong>ORIGINS</strong></p>
            <p>Previous versions of ANTLR did a poor job of their recovery within loops.
            A single mismatch token or missing token would force the parser to bail
            out of the entire rules surrounding the loop. So, for rule</p>
            <pre>
            classDef : 'class' ID '{' member* '}'
            </pre>
            input with an extra token between members would force the parser to
            consume until it found the next class definition rather than the next
            member definition of the current class.
            <p>This functionality cost a little bit of effort because the parser has to
            compare token set at the start of the loop and at each iteration. If for
            some reason speed is suffering for you, you can turn off this
            functionality by simply overriding this method as a blank { }.</p>
            </summary>
            <exception cref="T:Antlr4.Runtime.RecognitionException"/>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.ReportNoViableAlternative(Antlr4.Runtime.Parser,Antlr4.Runtime.NoViableAltException)">
            <summary>
            This is called by
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.ReportError(Antlr4.Runtime.Parser,Antlr4.Runtime.RecognitionException)"/>
            when the exception is a
            <see cref="T:Antlr4.Runtime.NoViableAltException"/>
            .
            </summary>
            <seealso cref="M:Antlr4.Runtime.DefaultErrorStrategy.ReportError(Antlr4.Runtime.Parser,Antlr4.Runtime.RecognitionException)"/>
            <param name="recognizer">the parser instance</param>
            <param name="e">the recognition exception</param>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.ReportInputMismatch(Antlr4.Runtime.Parser,Antlr4.Runtime.InputMismatchException)">
            <summary>
            This is called by
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.ReportError(Antlr4.Runtime.Parser,Antlr4.Runtime.RecognitionException)"/>
            when the exception is an
            <see cref="T:Antlr4.Runtime.InputMismatchException"/>
            .
            </summary>
            <seealso cref="M:Antlr4.Runtime.DefaultErrorStrategy.ReportError(Antlr4.Runtime.Parser,Antlr4.Runtime.RecognitionException)"/>
            <param name="recognizer">the parser instance</param>
            <param name="e">the recognition exception</param>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.ReportFailedPredicate(Antlr4.Runtime.Parser,Antlr4.Runtime.FailedPredicateException)">
            <summary>
            This is called by
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.ReportError(Antlr4.Runtime.Parser,Antlr4.Runtime.RecognitionException)"/>
            when the exception is a
            <see cref="T:Antlr4.Runtime.FailedPredicateException"/>
            .
            </summary>
            <seealso cref="M:Antlr4.Runtime.DefaultErrorStrategy.ReportError(Antlr4.Runtime.Parser,Antlr4.Runtime.RecognitionException)"/>
            <param name="recognizer">the parser instance</param>
            <param name="e">the recognition exception</param>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.ReportUnwantedToken(Antlr4.Runtime.Parser)">
            <summary>
            This method is called to report a syntax error which requires the removal
            of a token from the input stream.
            </summary>
            <remarks>
            This method is called to report a syntax error which requires the removal
            of a token from the input stream. At the time this method is called, the
            erroneous symbol is current
            <c>LT(1)</c>
            symbol and has not yet been
            removed from the input stream. When this method returns,
            <paramref name="recognizer"/>
            is in error recovery mode.
            <p>This method is called when
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.SingleTokenDeletion(Antlr4.Runtime.Parser)"/>
            identifies
            single-token deletion as a viable recovery strategy for a mismatched
            input error.</p>
            <p>The default implementation simply returns if the handler is already in
            error recovery mode. Otherwise, it calls
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.BeginErrorCondition(Antlr4.Runtime.Parser)"/>
            to
            enter error recovery mode, followed by calling
            <see cref="M:Antlr4.Runtime.Parser.NotifyErrorListeners(System.String)"/>
            .</p>
            </remarks>
            <param name="recognizer">the parser instance</param>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.ReportMissingToken(Antlr4.Runtime.Parser)">
            <summary>
            This method is called to report a syntax error which requires the
            insertion of a missing token into the input stream.
            </summary>
            <remarks>
            This method is called to report a syntax error which requires the
            insertion of a missing token into the input stream. At the time this
            method is called, the missing token has not yet been inserted. When this
            method returns,
            <paramref name="recognizer"/>
            is in error recovery mode.
            <p>This method is called when
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.SingleTokenInsertion(Antlr4.Runtime.Parser)"/>
            identifies
            single-token insertion as a viable recovery strategy for a mismatched
            input error.</p>
            <p>The default implementation simply returns if the handler is already in
            error recovery mode. Otherwise, it calls
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.BeginErrorCondition(Antlr4.Runtime.Parser)"/>
            to
            enter error recovery mode, followed by calling
            <see cref="M:Antlr4.Runtime.Parser.NotifyErrorListeners(System.String)"/>
            .</p>
            </remarks>
            <param name="recognizer">the parser instance</param>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.RecoverInline(Antlr4.Runtime.Parser)">
            <summary>
            <inheritDoc/>
            <p>The default implementation attempts to recover from the mismatched input
            by using single token insertion and deletion as described below. If the
            recovery attempt fails, this method throws an
            <see cref="T:Antlr4.Runtime.InputMismatchException"/>
            .</p>
            <p><strong>EXTRA TOKEN</strong> (single token deletion)</p>
            <p>
            <c>LA(1)</c>
            is not what we are looking for. If
            <c>LA(2)</c>
            has the
            right token, however, then assume
            <c>LA(1)</c>
            is some extra spurious
            token and delete it. Then consume and return the next token (which was
            the
            <c>LA(2)</c>
            token) as the successful result of the match operation.</p>
            <p>This recovery strategy is implemented by
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.SingleTokenDeletion(Antlr4.Runtime.Parser)"/>
            .</p>
            <p><strong>MISSING TOKEN</strong> (single token insertion)</p>
            <p>If current token (at
            <c>LA(1)</c>
            ) is consistent with what could come
            after the expected
            <c>LA(1)</c>
            token, then assume the token is missing
            and use the parser's
            <see cref="T:Antlr4.Runtime.ITokenFactory"/>
            to create it on the fly. The
            "insertion" is performed by returning the created token as the successful
            result of the match operation.</p>
            <p>This recovery strategy is implemented by
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.SingleTokenInsertion(Antlr4.Runtime.Parser)"/>
            .</p>
            <p><strong>EXAMPLE</strong></p>
            <p>For example, Input
            <c>i=(3;</c>
            is clearly missing the
            <c>')'</c>
            . When
            the parser returns from the nested call to
            <c>expr</c>
            , it will have
            call chain:</p>
            <pre>
            stat &#x2192; expr &#x2192; atom
            </pre>
            and it will be trying to match the
            <c>')'</c>
            at this point in the
            derivation:
            <pre>
            =&gt; ID '=' '(' INT ')' ('+' atom)* ';'
            ^
            </pre>
            The attempt to match
            <c>')'</c>
            will fail when it sees
            <c>';'</c>
            and
            call
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.RecoverInline(Antlr4.Runtime.Parser)"/>
            . To recover, it sees that
            <c>LA(1)==';'</c>
            is in the set of tokens that can follow the
            <c>')'</c>
            token reference
            in rule
            <c>atom</c>
            . It can assume that you forgot the
            <c>')'</c>
            .
            </summary>
            <exception cref="T:Antlr4.Runtime.RecognitionException"/>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.SingleTokenInsertion(Antlr4.Runtime.Parser)">
             <summary>
             This method implements the single-token insertion inline error recovery
             strategy.
             </summary>
             <remarks>
             This method implements the single-token insertion inline error recovery
             strategy. It is called by
             <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.RecoverInline(Antlr4.Runtime.Parser)"/>
             if the single-token
             deletion strategy fails to recover from the mismatched input. If this
             method returns
             <see langword="true"/>
             ,
             <paramref name="recognizer"/>
             will be in error recovery
             mode.
             <p>This method determines whether or not single-token insertion is viable by
             checking if the
             <c>LA(1)</c>
             input symbol could be successfully matched
             if it were instead the
             <c>LA(2)</c>
             symbol. If this method returns
             <see langword="true"/>
             , the caller is responsible for creating and inserting a
             token with the correct type to produce this behavior.</p>
             </remarks>
             <param name="recognizer">the parser instance</param>
             <returns>
            
             <see langword="true"/>
             if single-token insertion is a viable recovery
             strategy for the current mismatched input, otherwise
             <see langword="false"/>
             </returns>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.SingleTokenDeletion(Antlr4.Runtime.Parser)">
            <summary>
            This method implements the single-token deletion inline error recovery
            strategy.
            </summary>
            <remarks>
            This method implements the single-token deletion inline error recovery
            strategy. It is called by
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.RecoverInline(Antlr4.Runtime.Parser)"/>
            to attempt to recover
            from mismatched input. If this method returns null, the parser and error
            handler state will not have changed. If this method returns non-null,
            <paramref name="recognizer"/>
            will <em>not</em> be in error recovery mode since the
            returned token was a successful match.
            <p>If the single-token deletion is successful, this method calls
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.ReportUnwantedToken(Antlr4.Runtime.Parser)"/>
            to report the error, followed by
            <see cref="M:Antlr4.Runtime.Parser.Consume"/>
            to actually "delete" the extraneous token. Then,
            before returning
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.ReportMatch(Antlr4.Runtime.Parser)"/>
            is called to signal a successful
            match.</p>
            </remarks>
            <param name="recognizer">the parser instance</param>
            <returns>
            the successfully matched
            <see cref="T:Antlr4.Runtime.IToken"/>
            instance if single-token
            deletion successfully recovers from the mismatched input, otherwise
            <see langword="null"/>
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.GetMissingSymbol(Antlr4.Runtime.Parser)">
            <summary>Conjure up a missing token during error recovery.</summary>
            <remarks>
            Conjure up a missing token during error recovery.
            The recognizer attempts to recover from single missing
            symbols. But, actions might refer to that missing symbol.
            For example, x=ID {f($x);}. The action clearly assumes
            that there has been an identifier matched previously and that
            $x points at that token. If that token is missing, but
            the next token in the stream is what we want we assume that
            this token is missing and we keep going. Because we
            have to return some token to replace the missing token,
            we have to conjure one up. This method gives the user control
            over the tokens returned for missing tokens. Mostly,
            you will want to create something special for identifier
            tokens. For literals such as '{' and ',', the default
            action in the parser or tree parser works. It simply creates
            a CommonToken of the appropriate type. The text will be the token.
            If you change what tokens must be created by the lexer,
            override this method to create the appropriate tokens.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.GetTokenErrorDisplay(Antlr4.Runtime.IToken)">
            <summary>
            How should a token be displayed in an error message? The default
            is to display just the text, but during development you might
            want to have a lot of information spit out.
            </summary>
            <remarks>
            How should a token be displayed in an error message? The default
            is to display just the text, but during development you might
            want to have a lot of information spit out.  Override in that case
            to use t.toString() (which, for CommonToken, dumps everything about
            the token). This is better than forcing you to override a method in
            your token objects because you don't have to go modify your lexer
            so that it creates a new Java type.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.ConsumeUntil(Antlr4.Runtime.Parser,Antlr4.Runtime.Misc.IntervalSet)">
            <summary>Consume tokens until one matches the given token set.</summary>
            <remarks>Consume tokens until one matches the given token set.</remarks>
        </member>
        <member name="T:Antlr4.Runtime.Dependents">
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Dfa.AbstractEdgeMap`1">
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Dfa.AcceptStateInfo">
            <summary>
            Stores information about a
            <see cref="T:Antlr4.Runtime.Dfa.DFAState"/>
            which is an accept state under
            some condition. Certain settings, such as
            <see cref="P:Antlr4.Runtime.Atn.ParserATNSimulator.PredictionMode"/>
            , may be used in addition to
            this information to determine whether or not a particular state is an accept
            state.
            </summary>
            <author>Sam Harwell</author>
        </member>
        <member name="P:Antlr4.Runtime.Dfa.AcceptStateInfo.Prediction">
            <summary>Gets the prediction made by this accept state.</summary>
            <remarks>
            Gets the prediction made by this accept state. Note that this value
            assumes the predicates, if any, in the
            <see cref="T:Antlr4.Runtime.Dfa.DFAState"/>
            evaluate to
            <see langword="true"/>
            . If predicate evaluation is enabled, the final prediction of
            the accept state will be determined by the result of predicate
            evaluation.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Dfa.AcceptStateInfo.LexerActionExecutor">
            <summary>
            Gets the
            <see cref="T:Antlr4.Runtime.Atn.LexerActionExecutor"/>
            which can be used to execute actions
            and/or commands after the lexer matches a token.
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Dfa.ArrayEdgeMap`1">
            <author>Sam Harwell</author>
        </member>
        <member name="F:Antlr4.Runtime.Dfa.DFA.states">
            A set of all DFA states. Use {@link Map} so we can get old state back
            ({@link Set} only allows you to see if it's there).
        </member>
        <member name="F:Antlr4.Runtime.Dfa.DFA.atnStartState">
            From which ATN state did we create this DFA? 
        </member>
        <member name="F:Antlr4.Runtime.Dfa.DFA.precedenceDfa">
            {@code true} if this DFA is for a precedence decision; otherwise,
            {@code false}. This is the backing field for {@link #isPrecedenceDfa}.
        </member>
        <member name="P:Antlr4.Runtime.Dfa.DFA.IsPrecedenceDfa">
             Gets whether this DFA is a precedence DFA. Precedence DFAs use a special
             start state {@link #s0} which is not stored in {@link #states}. The
             {@link DFAState#edges} array for this start state contains outgoing edges
             supplying individual start states corresponding to specific precedence
             values.
            
             @return {@code true} if this is a precedence DFA; otherwise,
             {@code false}.
             @see Parser#getPrecedence()
        </member>
        <member name="M:Antlr4.Runtime.Dfa.DFA.GetPrecedenceStartState(System.Int32)">
             Get the start state for a specific precedence value.
            
             @param precedence The current precedence.
             @return The start state corresponding to the specified precedence, or
             {@code null} if no start state exists for the specified precedence.
            
             @throws IllegalStateException if this is not a precedence DFA.
             @see #isPrecedenceDfa()
        </member>
        <member name="M:Antlr4.Runtime.Dfa.DFA.SetPrecedenceStartState(System.Int32,Antlr4.Runtime.Dfa.DFAState)">
             Set the start state for a specific precedence value.
            
             @param precedence The current precedence.
             @param startState The start state corresponding to the specified
             precedence.
            
             @throws IllegalStateException if this is not a precedence DFA.
             @see #isPrecedenceDfa()
        </member>
        <member name="M:Antlr4.Runtime.Dfa.DFA.GetStates">
            Return a list of all states in this DFA, ordered by state number.
        </member>
        <member name="T:Antlr4.Runtime.Dfa.DFASerializer">
            <summary>A DFA walker that knows how to dump them to serialized strings.</summary>
            <remarks>A DFA walker that knows how to dump them to serialized strings.</remarks>
        </member>
        <member name="T:Antlr4.Runtime.Dfa.DFAState">
            <summary>A DFA state represents a set of possible ATN configurations.</summary>
            <remarks>
            A DFA state represents a set of possible ATN configurations.
            As Aho, Sethi, Ullman p. 117 says "The DFA uses its state
            to keep track of all possible states the ATN can be in after
            reading each input symbol.  That is to say, after reading
            input a1a2..an, the DFA is in a state that represents the
            subset T of the states of the ATN that are reachable from the
            ATN's start state along some path labeled a1a2..an."
            In conventional NFA&#x2192;DFA conversion, therefore, the subset T
            would be a bitset representing the set of states the
            ATN could be in.  We need to track the alt predicted by each
            state as well, however.  More importantly, we need to maintain
            a stack of states, tracking the closure operations as they
            jump from rule to rule, emulating rule invocations (method calls).
            I have to add a stack to simulate the proper lookahead sequences for
            the underlying LL grammar from which the ATN was derived.
            <p>I use a set of ATNConfig objects not simple states.  An ATNConfig
            is both a state (ala normal conversion) and a RuleContext describing
            the chain of rules (if any) followed to arrive at that state.</p>
            <p>A DFA state may have multiple references to a particular state,
            but with different ATN contexts (with same or different alts)
            meaning that state was reached via a different set of rule invocations.</p>
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Dfa.DFAState.edges">
            {@code edges[symbol]} points to target of symbol. Shift up by 1 so (-1)
            {@link Token#EOF} maps to {@code edges[0]}.
        </member>
        <member name="F:Antlr4.Runtime.Dfa.DFAState.prediction">
            if accept state, what ttype do we match or alt do we predict?
            This is set to {@link ATN#INVALID_ALT_NUMBER} when {@link #predicates}{@code !=null} or
            {@link #requiresFullContext}.
        </member>
        <member name="F:Antlr4.Runtime.Dfa.DFAState.requiresFullContext">
            Indicates that this state was created during SLL prediction that
            discovered a conflict between the configurations in the state. Future
            {@link ParserATNSimulator#execATN} invocations immediately jumped doing
            full context prediction if this field is true.
        </member>
        <member name="F:Antlr4.Runtime.Dfa.DFAState.predicates">
            During SLL parsing, this is a list of predicates associated with the
              ATN configurations of the DFA state. When we have predicates,
              {@link #requiresFullContext} is {@code false} since full context prediction evaluates predicates
              on-the-fly. If this is not null, then {@link #prediction} is
              {@link ATN#INVALID_ALT_NUMBER}.
            
              <p>We only use these for non-{@link #requiresFullContext} but conflicting states. That
              means we know from the context (it's $ or we don't dip into outer
              context) that it's an ambiguity not a conflict.</p>
            
              <p>This list is computed by {@link ParserATNSimulator#predicateDFAState}.</p>
        </member>
        <member name="M:Antlr4.Runtime.Dfa.DFAState.getAltSet">
            Get the set of all alts mentioned by all ATN configurations in this
            DFA state.
        </member>
        <member name="M:Antlr4.Runtime.Dfa.DFAState.Equals(System.Object)">
             Two {@link DFAState} instances are equal if their ATN configuration sets
             are the same. This method is used to see if a state already exists.
            
             <p>Because the number of alternatives and number of ATN configurations are
             finite, there is a finite number of DFA states that can be processed.
             This is necessary to show that the algorithm terminates.</p>
            
             <p>Cannot test the DFA state numbers here because in
             {@link ParserATNSimulator#addDFAState} we need to know if any other state
             exists that has this exact set of ATN configurations. The
             {@link #stateNumber} is irrelevant.</p>
        </member>
        <member name="T:Antlr4.Runtime.Dfa.PredPrediction">
            Map a predicate to a predicted alternative. 
        </member>
        <member name="T:Antlr4.Runtime.Dfa.EmptyEdgeMap`1">
            <summary>
            This implementation of
            <see cref="T:Antlr4.Runtime.Dfa.AbstractEdgeMap`1"/>
            represents an empty edge map.
            </summary>
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Dfa.IEdgeMap`1">
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Dfa.SingletonEdgeMap`1">
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Dfa.SparseEdgeMap`1">
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.DiagnosticErrorListener">
            <summary>
            This implementation of
            <see cref="T:Antlr4.Runtime.IAntlrErrorListener`1"/>
            can be used to identify
            certain potential correctness and performance problems in grammars. "Reports"
            are made by calling
            <see cref="M:Antlr4.Runtime.Parser.NotifyErrorListeners(System.String)"/>
            with the appropriate
            message.
            <ul>
            <li><b>Ambiguities</b>: These are cases where more than one path through the
            grammar can match the input.</li>
            <li><b>Weak context sensitivity</b>: These are cases where full-context
            prediction resolved an SLL conflict to a unique alternative which equaled the
            minimum alternative of the SLL conflict.</li>
            <li><b>Strong (forced) context sensitivity</b>: These are cases where the
            full-context prediction resolved an SLL conflict to a unique alternative,
            <em>and</em> the minimum alternative of the SLL conflict was found to not be
            a truly viable alternative. Two-stage parsing cannot be used for inputs where
            this situation occurs.</li>
            </ul>
            </summary>
            <author>Sam Harwell</author>
        </member>
        <member name="F:Antlr4.Runtime.DiagnosticErrorListener.exactOnly">
            <summary>
            When
            <see langword="true"/>
            , only exactly known ambiguities are reported.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.DiagnosticErrorListener.#ctor">
            <summary>
            Initializes a new instance of
            <see cref="T:Antlr4.Runtime.DiagnosticErrorListener"/>
            which only
            reports exact ambiguities.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.DiagnosticErrorListener.#ctor(System.Boolean)">
             <summary>
             Initializes a new instance of
             <see cref="T:Antlr4.Runtime.DiagnosticErrorListener"/>
             , specifying
             whether all ambiguities or only exact ambiguities are reported.
             </summary>
             <param name="exactOnly">
            
             <see langword="true"/>
             to report only exact ambiguities, otherwise
             <see langword="false"/>
             to report all ambiguities.
             </param>
        </member>
        <member name="M:Antlr4.Runtime.DiagnosticErrorListener.GetConflictingAlts(Antlr4.Runtime.Sharpen.BitSet,Antlr4.Runtime.Atn.ATNConfigSet)">
            <summary>
            Computes the set of conflicting or ambiguous alternatives from a
            configuration set, if that information was not already provided by the
            parser.
            </summary>
            <remarks>
            Computes the set of conflicting or ambiguous alternatives from a
            configuration set, if that information was not already provided by the
            parser.
            </remarks>
            <param name="reportedAlts">
            The set of conflicting or ambiguous alternatives, as
            reported by the parser.
            </param>
            <param name="configSet">The conflicting or ambiguous configuration set.</param>
            <returns>
            Returns
            <paramref name="reportedAlts"/>
            if it is not
            <see langword="null"/>
            , otherwise
            returns the set of alternatives represented in
            <paramref name="configSet"/>
            .
            </returns>
        </member>
        <member name="T:Antlr4.Runtime.FailedPredicateException">
            <summary>A semantic predicate failed during validation.</summary>
            <remarks>
            A semantic predicate failed during validation.  Validation of predicates
            occurs when normally parsing the alternative just like matching a token.
            Disambiguating predicate evaluation occurs when we test a predicate during
            prediction.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.IAntlrErrorListener`1">
            <summary>How to emit recognition errors.</summary>
            <remarks>How to emit recognition errors.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.IAntlrErrorListener`1.SyntaxError(System.IO.TextWriter,Antlr4.Runtime.IRecognizer,`0,System.Int32,System.Int32,System.String,Antlr4.Runtime.RecognitionException)">
            <summary>Upon syntax error, notify any interested parties.</summary>
            <remarks>
            Upon syntax error, notify any interested parties. This is not how to
            recover from errors or compute error messages.
            <see cref="T:Antlr4.Runtime.IAntlrErrorStrategy"/>
            specifies how to recover from syntax errors and how to compute error
            messages. This listener's job is simply to emit a computed message,
            though it has enough information to create its own message in many cases.
            <p>The
            <see cref="T:Antlr4.Runtime.RecognitionException"/>
            is non-null for all syntax errors except
            when we discover mismatched token errors that we can recover from
            in-line, without returning from the surrounding rule (via the single
            token insertion and deletion mechanism).</p>
            </remarks>
            <param name="output">
            Where the error should be written.
            </param>
            <param name="recognizer">
            What parser got the error. From this
            object, you can access the context as well
            as the input stream.
            </param>
            <param name="offendingSymbol">
            The offending token in the input token
            stream, unless recognizer is a lexer (then it's null). If
            no viable alternative error,
            <paramref name="e"/>
            has token at which we
            started production for the decision.
            </param>
            <param name="line">The line number in the input where the error occurred.</param>
            <param name="charPositionInLine">The character position within that line where the error occurred.</param>
            <param name="msg">The message to emit.</param>
            <param name="e">
            The exception generated by the parser that led to
            the reporting of an error. It is null in the case where
            the parser was able to recover in line without exiting the
            surrounding rule.
            </param>
        </member>
        <member name="T:Antlr4.Runtime.IAntlrErrorStrategy">
            <summary>
            The interface for defining strategies to deal with syntax errors encountered
            during a parse by ANTLR-generated parsers.
            </summary>
            <remarks>
            The interface for defining strategies to deal with syntax errors encountered
            during a parse by ANTLR-generated parsers. We distinguish between three
            different kinds of errors:
            <ul>
            <li>The parser could not figure out which path to take in the ATN (none of
            the available alternatives could possibly match)</li>
            <li>The current input does not match what we were looking for</li>
            <li>A predicate evaluated to false</li>
            </ul>
            Implementations of this interface report syntax errors by calling
            <see cref="M:Antlr4.Runtime.Parser.NotifyErrorListeners(System.String)"/>
            .
            <p>TODO: what to do about lexers</p>
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.IAntlrErrorStrategy.Reset(Antlr4.Runtime.Parser)">
            <summary>
            Reset the error handler state for the specified
            <paramref name="recognizer"/>
            .
            </summary>
            <param name="recognizer">the parser instance</param>
        </member>
        <member name="M:Antlr4.Runtime.IAntlrErrorStrategy.RecoverInline(Antlr4.Runtime.Parser)">
            <summary>
            This method is called when an unexpected symbol is encountered during an
            inline match operation, such as
            <see cref="M:Antlr4.Runtime.Parser.Match(System.Int32)"/>
            . If the error
            strategy successfully recovers from the match failure, this method
            returns the
            <see cref="T:Antlr4.Runtime.IToken"/>
            instance which should be treated as the
            successful result of the match.
            <p>Note that the calling code will not report an error if this method
            returns successfully. The error strategy implementation is responsible
            for calling
            <see cref="M:Antlr4.Runtime.Parser.NotifyErrorListeners(System.String)"/>
            as appropriate.</p>
            </summary>
            <param name="recognizer">the parser instance</param>
            <exception cref="T:Antlr4.Runtime.RecognitionException">
            if the error strategy was not able to
            recover from the unexpected input symbol
            </exception>
            <exception cref="T:Antlr4.Runtime.RecognitionException"/>
        </member>
        <member name="M:Antlr4.Runtime.IAntlrErrorStrategy.Recover(Antlr4.Runtime.Parser,Antlr4.Runtime.RecognitionException)">
            <summary>
            This method is called to recover from exception
            <paramref name="e"/>
            . This method is
            called after
            <see cref="M:Antlr4.Runtime.IAntlrErrorStrategy.ReportError(Antlr4.Runtime.Parser,Antlr4.Runtime.RecognitionException)"/>
            by the default exception handler
            generated for a rule method.
            </summary>
            <seealso cref="M:Antlr4.Runtime.IAntlrErrorStrategy.ReportError(Antlr4.Runtime.Parser,Antlr4.Runtime.RecognitionException)"/>
            <param name="recognizer">the parser instance</param>
            <param name="e">the recognition exception to recover from</param>
            <exception cref="T:Antlr4.Runtime.RecognitionException">
            if the error strategy could not recover from
            the recognition exception
            </exception>
            <exception cref="T:Antlr4.Runtime.RecognitionException"/>
        </member>
        <member name="M:Antlr4.Runtime.IAntlrErrorStrategy.Sync(Antlr4.Runtime.Parser)">
            <summary>
            This method provides the error handler with an opportunity to handle
            syntactic or semantic errors in the input stream before they result in a
            <see cref="T:Antlr4.Runtime.RecognitionException"/>
            .
            <p>The generated code currently contains calls to
            <see cref="M:Antlr4.Runtime.IAntlrErrorStrategy.Sync(Antlr4.Runtime.Parser)"/>
            after
            entering the decision state of a closure block (
            <c>(...)*</c>
            or
            <c>(...)+</c>
            ).</p>
            <p>For an implementation based on Jim Idle's "magic sync" mechanism, see
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.Sync(Antlr4.Runtime.Parser)"/>
            .</p>
            </summary>
            <seealso cref="M:Antlr4.Runtime.DefaultErrorStrategy.Sync(Antlr4.Runtime.Parser)"/>
            <param name="recognizer">the parser instance</param>
            <exception cref="T:Antlr4.Runtime.RecognitionException">
            if an error is detected by the error
            strategy but cannot be automatically recovered at the current state in
            the parsing process
            </exception>
            <exception cref="T:Antlr4.Runtime.RecognitionException"/>
        </member>
        <member name="M:Antlr4.Runtime.IAntlrErrorStrategy.InErrorRecoveryMode(Antlr4.Runtime.Parser)">
             <summary>
             Tests whether or not
             <paramref name="recognizer"/>
             is in the process of recovering
             from an error. In error recovery mode,
             <see cref="M:Antlr4.Runtime.Parser.Consume"/>
             adds
             symbols to the parse tree by calling
             <see cref="M:Antlr4.Runtime.ParserRuleContext.AddErrorNode(Antlr4.Runtime.IToken)"/>
             instead of
             <see cref="M:Antlr4.Runtime.ParserRuleContext.AddChild(Antlr4.Runtime.IToken)"/>
             .
             </summary>
             <param name="recognizer">the parser instance</param>
             <returns>
            
             <see langword="true"/>
             if the parser is currently recovering from a parse
             error, otherwise
             <see langword="false"/>
             </returns>
        </member>
        <member name="M:Antlr4.Runtime.IAntlrErrorStrategy.ReportMatch(Antlr4.Runtime.Parser)">
            <summary>
            This method is called by when the parser successfully matches an input
            symbol.
            </summary>
            <remarks>
            This method is called by when the parser successfully matches an input
            symbol.
            </remarks>
            <param name="recognizer">the parser instance</param>
        </member>
        <member name="M:Antlr4.Runtime.IAntlrErrorStrategy.ReportError(Antlr4.Runtime.Parser,Antlr4.Runtime.RecognitionException)">
            <summary>
            Report any kind of
            <see cref="T:Antlr4.Runtime.RecognitionException"/>
            . This method is called by
            the default exception handler generated for a rule method.
            </summary>
            <param name="recognizer">the parser instance</param>
            <param name="e">the recognition exception to report</param>
        </member>
        <member name="T:Antlr4.Runtime.ICharStream">
            <summary>A source of characters for an ANTLR lexer.</summary>
            <remarks>A source of characters for an ANTLR lexer.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.ICharStream.GetText(Antlr4.Runtime.Misc.Interval)">
            <summary>
            This method returns the text for a range of characters within this input
            stream.
            </summary>
            <remarks>
            This method returns the text for a range of characters within this input
            stream. This method is guaranteed to not throw an exception if the
            specified
            <paramref name="interval"/>
            lies entirely within a marked range. For more
            information about marked ranges, see
            <see cref="M:Antlr4.Runtime.IIntStream.Mark"/>
            .
            </remarks>
            <param name="interval">an interval within the stream</param>
            <returns>the text of the specified interval</returns>
            <exception cref="T:System.ArgumentNullException">
            if
            <paramref name="interval"/>
            is
            <see langword="null"/>
            </exception>
            <exception cref="T:System.ArgumentException">
            if
            <c>interval.a &lt; 0</c>
            , or if
            <c>interval.b &lt; interval.a - 1</c>
            , or if
            <c>interval.b</c>
            lies at or
            past the end of the stream
            </exception>
            <exception cref="T:System.NotSupportedException">
            if the stream does not support
            getting the text of the specified interval
            </exception>
        </member>
        <member name="T:Antlr4.Runtime.IIntStream">
            <summary>A simple stream of symbols whose values are represented as integers.</summary>
            <remarks>
            A simple stream of symbols whose values are represented as integers. This
            interface provides <em>marked ranges</em> with support for a minimum level
            of buffering necessary to implement arbitrary lookahead during prediction.
            For more information on marked ranges, see
            <see cref="M:Antlr4.Runtime.IIntStream.Mark"/>
            .
            <p><strong>Initializing Methods:</strong> Some methods in this interface have
            unspecified behavior if no call to an initializing method has occurred after
            the stream was constructed. The following is a list of initializing methods:</p>
            <ul>
            <li>
            <see cref="M:Antlr4.Runtime.IIntStream.LA(System.Int32)"/>
            </li>
            <li>
            <see cref="M:Antlr4.Runtime.IIntStream.Consume"/>
            </li>
            <li>
            <see cref="P:Antlr4.Runtime.IIntStream.Size"/>
            </li>
            </ul>
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.IIntStream.Consume">
            <summary>Consumes the current symbol in the stream.</summary>
            <remarks>
            Consumes the current symbol in the stream. This method has the following
            effects:
            <ul>
            <li><strong>Forward movement:</strong> The value of
            <see cref="P:Antlr4.Runtime.IIntStream.Index">index()</see>
            before calling this method is less than the value of
            <c>index()</c>
            after calling this method.</li>
            <li><strong>Ordered lookahead:</strong> The value of
            <c>LA(1)</c>
            before
            calling this method becomes the value of
            <c>LA(-1)</c>
            after calling
            this method.</li>
            </ul>
            Note that calling this method does not guarantee that
            <c>index()</c>
            is
            incremented by exactly 1, as that would preclude the ability to implement
            filtering streams (e.g.
            <see cref="T:Antlr4.Runtime.CommonTokenStream"/>
            which distinguishes
            between "on-channel" and "off-channel" tokens).
            </remarks>
            <exception cref="T:System.InvalidOperationException">
            if an attempt is made to consume the the
            end of the stream (i.e. if
            <c>LA(1)==</c>
            <see cref="F:Antlr4.Runtime.IntStreamConstants.EOF">EOF</see>
            before calling
            <c>consume</c>
            ).
            </exception>
        </member>
        <member name="M:Antlr4.Runtime.IIntStream.LA(System.Int32)">
            <summary>
            Gets the value of the symbol at offset
            <paramref name="i"/>
            from the current
            position. When
            <c>i==1</c>
            , this method returns the value of the current
            symbol in the stream (which is the next symbol to be consumed). When
            <c>i==-1</c>
            , this method returns the value of the previously read
            symbol in the stream. It is not valid to call this method with
            <c>i==0</c>
            , but the specific behavior is unspecified because this
            method is frequently called from performance-critical code.
            <p>This method is guaranteed to succeed if any of the following are true:</p>
            <ul>
            <li>
            <c>i&gt;0</c>
            </li>
            <li>
            <c>i==-1</c>
            and
            <see cref="P:Antlr4.Runtime.IIntStream.Index">index()</see>
            returns a value greater
            than the value of
            <c>index()</c>
            after the stream was constructed
            and
            <c>LA(1)</c>
            was called in that order. Specifying the current
            <c>index()</c>
            relative to the index after the stream was created
            allows for filtering implementations that do not return every symbol
            from the underlying source. Specifying the call to
            <c>LA(1)</c>
            allows for lazily initialized streams.</li>
            <li>
            <c>LA(i)</c>
            refers to a symbol consumed within a marked region
            that has not yet been released.</li>
            </ul>
            <p>If
            <paramref name="i"/>
            represents a position at or beyond the end of the stream,
            this method returns
            <see cref="F:Antlr4.Runtime.IntStreamConstants.EOF"/>
            .</p>
            <p>The return value is unspecified if
            <c>i&lt;0</c>
            and fewer than
            <c>-i</c>
            calls to
            <see cref="M:Antlr4.Runtime.IIntStream.Consume">consume()</see>
            have occurred from the beginning of
            the stream before calling this method.</p>
            </summary>
            <exception cref="T:System.NotSupportedException">
            if the stream does not support
            retrieving the value of the specified symbol
            </exception>
        </member>
        <member name="M:Antlr4.Runtime.IIntStream.Mark">
            <summary>
            A mark provides a guarantee that
            <see cref="M:Antlr4.Runtime.IIntStream.Seek(System.Int32)">seek()</see>
            operations will be
            valid over a "marked range" extending from the index where
            <c>mark()</c>
            was called to the current
            <see cref="P:Antlr4.Runtime.IIntStream.Index">index()</see>
            . This allows the use of
            streaming input sources by specifying the minimum buffering requirements
            to support arbitrary lookahead during prediction.
            <p>The returned mark is an opaque handle (type
            <c>int</c>
            ) which is passed
            to
            <see cref="M:Antlr4.Runtime.IIntStream.Release(System.Int32)">release()</see>
            when the guarantees provided by the marked
            range are no longer necessary. When calls to
            <c>mark()</c>
            /
            <c>release()</c>
            are nested, the marks must be released
            in reverse order of which they were obtained. Since marked regions are
            used during performance-critical sections of prediction, the specific
            behavior of invalid usage is unspecified (i.e. a mark is not released, or
            a mark is released twice, or marks are not released in reverse order from
            which they were created).</p>
            <p>The behavior of this method is unspecified if no call to an
            <see cref="T:Antlr4.Runtime.IIntStream">initializing method</see>
            has occurred after this stream was
            constructed.</p>
            <p>This method does not change the current position in the input stream.</p>
            <p>The following example shows the use of
            <see cref="M:Antlr4.Runtime.IIntStream.Mark">mark()</see>
            ,
            <see cref="M:Antlr4.Runtime.IIntStream.Release(System.Int32)">release(mark)</see>
            ,
            <see cref="P:Antlr4.Runtime.IIntStream.Index">index()</see>
            , and
            <see cref="M:Antlr4.Runtime.IIntStream.Seek(System.Int32)">seek(index)</see>
            as part of an operation to safely work within a
            marked region, then restore the stream position to its original value and
            release the mark.</p>
            <pre>
            IntStream stream = ...;
            int index = -1;
            int mark = stream.mark();
            try {
            index = stream.index();
            // perform work here...
            } finally {
            if (index != -1) {
            stream.seek(index);
            }
            stream.release(mark);
            }
            </pre>
            </summary>
            <returns>
            An opaque marker which should be passed to
            <see cref="M:Antlr4.Runtime.IIntStream.Release(System.Int32)">release()</see>
            when the marked range is no longer required.
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.IIntStream.Release(System.Int32)">
            <summary>
            This method releases a marked range created by a call to
            <see cref="M:Antlr4.Runtime.IIntStream.Mark">mark()</see>
            . Calls to
            <c>release()</c>
            must appear in the
            reverse order of the corresponding calls to
            <c>mark()</c>
            . If a mark is
            released twice, or if marks are not released in reverse order of the
            corresponding calls to
            <c>mark()</c>
            , the behavior is unspecified.
            <p>For more information and an example, see
            <see cref="M:Antlr4.Runtime.IIntStream.Mark"/>
            .</p>
            </summary>
            <param name="marker">
            A marker returned by a call to
            <c>mark()</c>
            .
            </param>
            <seealso cref="M:Antlr4.Runtime.IIntStream.Mark"/>
        </member>
        <member name="P:Antlr4.Runtime.IIntStream.Index">
            <summary>
            Return the index into the stream of the input symbol referred to by
            <c>LA(1)</c>
            .
            <p>The behavior of this method is unspecified if no call to an
            <see cref="T:Antlr4.Runtime.IIntStream">initializing method</see>
            has occurred after this stream was
            constructed.</p>
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.IIntStream.Seek(System.Int32)">
            <summary>
            Set the input cursor to the position indicated by
            <paramref name="index"/>
            . If the
            specified index lies past the end of the stream, the operation behaves as
            though
            <paramref name="index"/>
            was the index of the EOF symbol. After this method
            returns without throwing an exception, the at least one of the following
            will be true.
            <ul>
            <li>
            <see cref="P:Antlr4.Runtime.IIntStream.Index">index()</see>
            will return the index of the first symbol
            appearing at or after the specified
            <paramref name="index"/>
            . Specifically,
            implementations which filter their sources should automatically
            adjust
            <paramref name="index"/>
            forward the minimum amount required for the
            operation to target a non-ignored symbol.</li>
            <li>
            <c>LA(1)</c>
            returns
            <see cref="F:Antlr4.Runtime.IntStreamConstants.EOF"/>
            </li>
            </ul>
            This operation is guaranteed to not throw an exception if
            <paramref name="index"/>
            lies within a marked region. For more information on marked regions, see
            <see cref="M:Antlr4.Runtime.IIntStream.Mark"/>
            . The behavior of this method is unspecified if no call to
            an
            <see cref="T:Antlr4.Runtime.IIntStream">initializing method</see>
            has occurred after this stream
            was constructed.
            </summary>
            <param name="index">The absolute index to seek to.</param>
            <exception cref="T:System.ArgumentException">
            if
            <paramref name="index"/>
            is less than 0
            </exception>
            <exception cref="T:System.NotSupportedException">
            if the stream does not support
            seeking to the specified index
            </exception>
        </member>
        <member name="P:Antlr4.Runtime.IIntStream.Size">
            <summary>
            Returns the total number of symbols in the stream, including a single EOF
            symbol.
            </summary>
            <remarks>
            Returns the total number of symbols in the stream, including a single EOF
            symbol.
            </remarks>
            <exception cref="T:System.NotSupportedException">
            if the size of the stream is
            unknown.
            </exception>
        </member>
        <member name="P:Antlr4.Runtime.IIntStream.SourceName">
            <summary>Gets the name of the underlying symbol source.</summary>
            <remarks>
            Gets the name of the underlying symbol source. This method returns a
            non-null, non-empty string. If such a name is not known, this method
            returns
            <see cref="F:Antlr4.Runtime.IntStreamConstants.UnknownSourceName"/>
            .
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.IntStreamConstants.EOF">
            <summary>
            The value returned by
            <see cref="M:Antlr4.Runtime.IIntStream.LA(System.Int32)">LA()</see>
            when the end of the stream is
            reached.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.IntStreamConstants.UnknownSourceName">
            <summary>
            The value returned by
            <see cref="P:Antlr4.Runtime.IIntStream.SourceName"/>
            when the actual name of the
            underlying source is not known.
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.InputMismatchException">
            <summary>
            This signifies any kind of mismatched input exceptions such as
            when the current input does not match the expected token.
            </summary>
            <remarks>
            This signifies any kind of mismatched input exceptions such as
            when the current input does not match the expected token.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.InterpreterRuleContext">
            <summary>
            This class extends
            <see cref="T:Antlr4.Runtime.ParserRuleContext"/>
            by allowing the value of
            <see cref="P:Antlr4.Runtime.InterpreterRuleContext.RuleIndex"/>
            to be explicitly set for the context.
            <p>
            <see cref="T:Antlr4.Runtime.ParserRuleContext"/>
            does not include field storage for the rule index
            since the context classes created by the code generator override the
            <see cref="P:Antlr4.Runtime.InterpreterRuleContext.RuleIndex"/>
            method to return the correct value for that context.
            Since the parser interpreter does not use the context classes generated for a
            parser, this class (with slightly more memory overhead per node) is used to
            provide equivalent functionality.</p>
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.InterpreterRuleContext.ruleIndex">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.InterpreterRuleContext.RuleIndex"/>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.InterpreterRuleContext.#ctor(Antlr4.Runtime.ParserRuleContext,System.Int32,System.Int32)">
            <summary>
            Constructs a new
            <see cref="T:Antlr4.Runtime.InterpreterRuleContext"/>
            with the specified
            parent, invoking state, and rule index.
            </summary>
            <param name="parent">The parent context.</param>
            <param name="invokingStateNumber">The invoking state number.</param>
            <param name="ruleIndex">The rule index for the current context.</param>
        </member>
        <member name="T:Antlr4.Runtime.IParserErrorListener">
            <summary>How to emit recognition errors for parsers.</summary>
            <remarks>How to emit recognition errors for parsers.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.IParserErrorListener.ReportAmbiguity(Antlr4.Runtime.Parser,Antlr4.Runtime.Dfa.DFA,System.Int32,System.Int32,System.Boolean,Antlr4.Runtime.Sharpen.BitSet,Antlr4.Runtime.Atn.ATNConfigSet)">
             <summary>
             This method is called by the parser when a full-context prediction
             results in an ambiguity.
             </summary>
             <remarks>
             This method is called by the parser when a full-context prediction
             results in an ambiguity.
             <p>Each full-context prediction which does not result in a syntax error
             will call either
             <see cref="M:Antlr4.Runtime.IParserErrorListener.ReportContextSensitivity(Antlr4.Runtime.Parser,Antlr4.Runtime.Dfa.DFA,System.Int32,System.Int32,System.Int32,Antlr4.Runtime.Atn.SimulatorState)"/>
             or
             <see cref="M:Antlr4.Runtime.IParserErrorListener.ReportAmbiguity(Antlr4.Runtime.Parser,Antlr4.Runtime.Dfa.DFA,System.Int32,System.Int32,System.Boolean,Antlr4.Runtime.Sharpen.BitSet,Antlr4.Runtime.Atn.ATNConfigSet)"/>
             .</p>
             <p>
             When
             <paramref name="ambigAlts"/>
             is not null, it contains the set of potentially
             viable alternatives identified by the prediction algorithm. When
             <paramref name="ambigAlts"/>
             is null, use
             <see cref="M:Antlr4.Runtime.Atn.ATNConfigSet.GetAlts"/>
             to obtain the represented
             alternatives from the
             <paramref name="configs"/>
             argument.</p>
             <p>When
             <paramref name="exact"/>
             is
             <see langword="true"/>
             , <em>all</em> of the potentially
             viable alternatives are truly viable, i.e. this is reporting an exact
             ambiguity. When
             <paramref name="exact"/>
             is
             <see langword="false"/>
             , <em>at least two</em> of
             the potentially viable alternatives are viable for the current input, but
             the prediction algorithm terminated as soon as it determined that at
             least the <em>minimum</em> potentially viable alternative is truly
             viable.</p>
             <p>When the
             <see cref="F:Antlr4.Runtime.Atn.PredictionMode.LL_EXACT_AMBIG_DETECTION"/>
             prediction
             mode is used, the parser is required to identify exact ambiguities so
             <paramref name="exact"/>
             will always be
             <see langword="true"/>
             .</p>
             </remarks>
             <param name="recognizer">the parser instance</param>
             <param name="dfa">the DFA for the current decision</param>
             <param name="startIndex">the input index where the decision started</param>
             <param name="stopIndex">the input input where the ambiguity was identified</param>
             <param name="exact">
            
             <see langword="true"/>
             if the ambiguity is exactly known, otherwise
             <see langword="false"/>
             . This is always
             <see langword="true"/>
             when
             <see cref="F:Antlr4.Runtime.Atn.PredictionMode.LL_EXACT_AMBIG_DETECTION"/>
             is used.
             </param>
             <param name="ambigAlts">
             the potentially ambiguous alternatives, or
             <see langword="null"/>
             to indicate that the potentially ambiguous alternatives are the complete
             set of represented alternatives in
             <paramref name="configs"/>
             </param>
             <param name="configs">
             the ATN configuration set where the ambiguity was
             identified
             </param>
        </member>
        <member name="M:Antlr4.Runtime.IParserErrorListener.ReportAttemptingFullContext(Antlr4.Runtime.Parser,Antlr4.Runtime.Dfa.DFA,System.Int32,System.Int32,Antlr4.Runtime.Sharpen.BitSet,Antlr4.Runtime.Atn.SimulatorState)">
            <summary>
            This method is called when an SLL conflict occurs and the parser is about
            to use the full context information to make an LL decision.
            </summary>
            <remarks>
            This method is called when an SLL conflict occurs and the parser is about
            to use the full context information to make an LL decision.
            <p>If one or more configurations in
            <c>configs</c>
            contains a semantic
            predicate, the predicates are evaluated before this method is called. The
            subset of alternatives which are still viable after predicates are
            evaluated is reported in
            <paramref name="conflictingAlts"/>
            .</p>
            </remarks>
            <param name="recognizer">the parser instance</param>
            <param name="dfa">the DFA for the current decision</param>
            <param name="startIndex">the input index where the decision started</param>
            <param name="stopIndex">the input index where the SLL conflict occurred</param>
            <param name="conflictingAlts">
            The specific conflicting alternatives. If this is
            <see langword="null"/>
            , the conflicting alternatives are all alternatives
            represented in
            <c>configs</c>
            .
            </param>
            <param name="conflictState">
            the simulator state when the SLL conflict was
            detected
            </param>
        </member>
        <member name="M:Antlr4.Runtime.IParserErrorListener.ReportContextSensitivity(Antlr4.Runtime.Parser,Antlr4.Runtime.Dfa.DFA,System.Int32,System.Int32,System.Int32,Antlr4.Runtime.Atn.SimulatorState)">
            <summary>
            This method is called by the parser when a full-context prediction has a
            unique result.
            </summary>
            <remarks>
            This method is called by the parser when a full-context prediction has a
            unique result.
            <p>Each full-context prediction which does not result in a syntax error
            will call either
            <see cref="M:Antlr4.Runtime.IParserErrorListener.ReportContextSensitivity(Antlr4.Runtime.Parser,Antlr4.Runtime.Dfa.DFA,System.Int32,System.Int32,System.Int32,Antlr4.Runtime.Atn.SimulatorState)"/>
            or
            <see cref="M:Antlr4.Runtime.IParserErrorListener.ReportAmbiguity(Antlr4.Runtime.Parser,Antlr4.Runtime.Dfa.DFA,System.Int32,System.Int32,System.Boolean,Antlr4.Runtime.Sharpen.BitSet,Antlr4.Runtime.Atn.ATNConfigSet)"/>
            .</p>
            <p>For prediction implementations that only evaluate full-context
            predictions when an SLL conflict is found (including the default
            <see cref="T:Antlr4.Runtime.Atn.ParserATNSimulator"/>
            implementation), this method reports cases
            where SLL conflicts were resolved to unique full-context predictions,
            i.e. the decision was context-sensitive. This report does not necessarily
            indicate a problem, and it may appear even in completely unambiguous
            grammars.</p>
            <p>
            <c>configs</c>
            may have more than one represented alternative if the
            full-context prediction algorithm does not evaluate predicates before
            beginning the full-context prediction. In all cases, the final prediction
            is passed as the
            <paramref name="prediction"/>
            argument.</p>
            <p>Note that the definition of "context sensitivity" in this method
            differs from the concept in
            <see cref="F:Antlr4.Runtime.Atn.DecisionInfo.contextSensitivities"/>
            .
            This method reports all instances where an SLL conflict occurred but LL
            parsing produced a unique result, whether or not that unique result
            matches the minimum alternative in the SLL conflicting set.</p>
            </remarks>
            <param name="recognizer">the parser instance</param>
            <param name="dfa">the DFA for the current decision</param>
            <param name="startIndex">the input index where the decision started</param>
            <param name="stopIndex">
            the input index where the context sensitivity was
            finally determined
            </param>
            <param name="prediction">the unambiguous result of the full-context prediction</param>
            <param name="acceptState">
            the simulator state when the unambiguous prediction
            was determined
            </param>
        </member>
        <member name="T:Antlr4.Runtime.IToken">
            <summary>
            A token has properties: text, type, line, character position in the line
            (so we can ignore tabs), token channel, index, and source from which
            we obtained this token.
            </summary>
            <remarks>
            A token has properties: text, type, line, character position in the line
            (so we can ignore tabs), token channel, index, and source from which
            we obtained this token.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.IToken.Text">
            <summary>Get the text of the token.</summary>
            <remarks>Get the text of the token.</remarks>
        </member>
        <member name="P:Antlr4.Runtime.IToken.Type">
            <summary>Get the token type of the token.</summary>
            <remarks>Get the token type of the token.</remarks>
        </member>
        <member name="P:Antlr4.Runtime.IToken.Line">
            <summary>
            The line number on which the 1st character of this token was matched,
            line=1..n
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.IToken.Column">
            <summary>
            The index of the first character of this token relative to the
            beginning of the line at which it occurs, 0..n-1
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.IToken.Channel">
            <summary>Return the channel this token.</summary>
            <remarks>
            Return the channel this token. Each token can arrive at the parser
            on a different channel, but the parser only "tunes" to a single channel.
            The parser ignores everything not on DEFAULT_CHANNEL.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.IToken.TokenIndex">
            <summary>An index from 0..n-1 of the token object in the input stream.</summary>
            <remarks>
            An index from 0..n-1 of the token object in the input stream.
            This must be valid in order to print token streams and
            use TokenRewriteStream.
            Return -1 to indicate that this token was conjured up since
            it doesn't have a valid index.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.IToken.StartIndex">
            <summary>
            The starting character index of the token
            This method is optional; return -1 if not implemented.
            </summary>
            <remarks>
            The starting character index of the token
            This method is optional; return -1 if not implemented.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.IToken.StopIndex">
            <summary>The last character index of the token.</summary>
            <remarks>
            The last character index of the token.
            This method is optional; return -1 if not implemented.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.IToken.TokenSource">
            <summary>
            Gets the
            <see cref="T:Antlr4.Runtime.ITokenSource"/>
            which created this token.
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.IToken.InputStream">
            <summary>
            Gets the
            <see cref="T:Antlr4.Runtime.ICharStream"/>
            from which this token was derived.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.TokenConstants.EPSILON">
            <summary>
            During lookahead operations, this "token" signifies we hit rule end ATN state
            and did not follow it despite needing to.
            </summary>
            <remarks>
            During lookahead operations, this "token" signifies we hit rule end ATN state
            and did not follow it despite needing to.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.TokenConstants.DefaultChannel">
            <summary>
            All tokens go to the parser (unless skip() is called in that rule)
            on a particular "channel".
            </summary>
            <remarks>
            All tokens go to the parser (unless skip() is called in that rule)
            on a particular "channel".  The parser tunes to a particular channel
            so that whitespace etc... can go to the parser on a "hidden" channel.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.TokenConstants.HiddenChannel">
            <summary>
            Anything on different channel than DEFAULT_CHANNEL is not parsed
            by parser.
            </summary>
            <remarks>
            Anything on different channel than DEFAULT_CHANNEL is not parsed
            by parser.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.TokenConstants.MinUserChannelValue">
            <summary>
            This is the minimum constant value which can be assigned to a
            user-defined token channel.
            </summary>
            <remarks>
            This is the minimum constant value which can be assigned to a
            user-defined token channel.
            <p>
            The non-negative numbers less than
            <see cref="F:Antlr4.Runtime.TokenConstants.MinUserChannelValue"/>
            are
            assigned to the predefined channels
            <see cref="F:Antlr4.Runtime.TokenConstants.DefaultChannel"/>
            and
            <see cref="F:Antlr4.Runtime.TokenConstants.HiddenChannel"/>
            .</p>
            </remarks>
            <seealso cref="P:Antlr4.Runtime.IToken.Channel"/>
        </member>
        <member name="T:Antlr4.Runtime.ITokenFactory">
            <summary>The default mechanism for creating tokens.</summary>
            <remarks>
            The default mechanism for creating tokens. It's used by default in Lexer and
            the error handling strategy (to create missing tokens).  Notifying the parser
            of a new factory means that it notifies it's token source and error strategy.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.ITokenFactory.Create(Antlr4.Runtime.Sharpen.Tuple{Antlr4.Runtime.ITokenSource,Antlr4.Runtime.ICharStream},System.Int32,System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            This is the method used to create tokens in the lexer and in the
            error handling strategy.
            </summary>
            <remarks>
            This is the method used to create tokens in the lexer and in the
            error handling strategy. If text!=null, than the start and stop positions
            are wiped to -1 in the text override is set in the CommonToken.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.ITokenFactory.Create(System.Int32,System.String)">
            <summary>Generically useful</summary>
        </member>
        <member name="T:Antlr4.Runtime.ITokenSource">
            <summary>
            A source of tokens must provide a sequence of tokens via
            <see cref="M:Antlr4.Runtime.ITokenSource.NextToken"/>
            and also must reveal it's source of characters;
            <see cref="T:Antlr4.Runtime.CommonToken"/>
            's text is
            computed from a
            <see cref="T:Antlr4.Runtime.ICharStream"/>
            ; it only store indices into the char
            stream.
            <p>Errors from the lexer are never passed to the parser. Either you want to keep
            going or you do not upon token recognition error. If you do not want to
            continue lexing then you do not want to continue parsing. Just throw an
            exception not under
            <see cref="T:Antlr4.Runtime.RecognitionException"/>
            and Java will naturally toss
            you all the way out of the recognizers. If you want to continue lexing then
            you should not throw an exception to the parser--it has already requested a
            token. Keep lexing until you get a valid one. Just report errors and keep
            going, looking for a valid token.</p>
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.ITokenSource.NextToken">
            <summary>
            Return a
            <see cref="T:Antlr4.Runtime.IToken"/>
            object from your input stream (usually a
            <see cref="T:Antlr4.Runtime.ICharStream"/>
            ). Do not fail/return upon lexing error; keep chewing
            on the characters until you get a good one; errors are not passed through
            to the parser.
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.ITokenSource.Line">
            <summary>Get the line number for the current position in the input stream.</summary>
            <remarks>
            Get the line number for the current position in the input stream. The
            first line in the input is line 1.
            </remarks>
            <returns>
            The line number for the current position in the input stream, or
            0 if the current token source does not track line numbers.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.ITokenSource.Column">
            <summary>
            Get the index into the current line for the current position in the input
            stream.
            </summary>
            <remarks>
            Get the index into the current line for the current position in the input
            stream. The first character on a line has position 0.
            </remarks>
            <returns>
            The line number for the current position in the input stream, or
            -1 if the current token source does not track character positions.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.ITokenSource.InputStream">
            <summary>
            Get the
            <see cref="T:Antlr4.Runtime.ICharStream"/>
            from which this token source is currently
            providing tokens.
            </summary>
            <returns>
            The
            <see cref="T:Antlr4.Runtime.ICharStream"/>
            associated with the current position in
            the input, or
            <see langword="null"/>
            if no input stream is available for the token
            source.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.ITokenSource.SourceName">
            <summary>Gets the name of the underlying input source.</summary>
            <remarks>
            Gets the name of the underlying input source. This method returns a
            non-null, non-empty string. If such a name is not known, this method
            returns
            <see cref="F:Antlr4.Runtime.IntStreamConstants.UnknownSourceName"/>
            .
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.ITokenSource.TokenFactory">
            <summary>
            Set the
            <see cref="T:Antlr4.Runtime.ITokenFactory"/>
            this token source should use for creating
            <see cref="T:Antlr4.Runtime.IToken"/>
            objects from the input.
            </summary>
            <value>
            The
            <see cref="T:Antlr4.Runtime.ITokenFactory"/>
            to use for creating tokens.
            </value>
            <summary>
            Gets the
            <see cref="T:Antlr4.Runtime.ITokenFactory"/>
            this token source is currently using for
            creating
            <see cref="T:Antlr4.Runtime.IToken"/>
            objects from the input.
            </summary>
            <returns>
            The
            <see cref="T:Antlr4.Runtime.ITokenFactory"/>
            currently used by this token source.
            </returns>
        </member>
        <member name="T:Antlr4.Runtime.ITokenStream">
            <summary>
            An
            <see cref="T:Antlr4.Runtime.IIntStream"/>
            whose symbols are
            <see cref="T:Antlr4.Runtime.IToken"/>
            instances.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.ITokenStream.LT(System.Int32)">
            <summary>
            Get the
            <see cref="T:Antlr4.Runtime.IToken"/>
            instance associated with the value returned by
            <see cref="M:Antlr4.Runtime.IIntStream.LA(System.Int32)">LA(k)</see>
            . This method has the same pre- and post-conditions as
            <see cref="M:Antlr4.Runtime.IIntStream.LA(System.Int32)"/>
            . In addition, when the preconditions of this method
            are met, the return value is non-null and the value of
            <c>LT(k).getType()==LA(k)</c>
            .
            </summary>
            <seealso cref="M:Antlr4.Runtime.IIntStream.LA(System.Int32)"/>
        </member>
        <member name="M:Antlr4.Runtime.ITokenStream.Get(System.Int32)">
            <summary>
            Gets the
            <see cref="T:Antlr4.Runtime.IToken"/>
            at the specified
            <c>index</c>
            in the stream. When
            the preconditions of this method are met, the return value is non-null.
            <p>The preconditions for this method are the same as the preconditions of
            <see cref="M:Antlr4.Runtime.IIntStream.Seek(System.Int32)"/>
            . If the behavior of
            <c>seek(index)</c>
            is
            unspecified for the current state and given
            <c>index</c>
            , then the
            behavior of this method is also unspecified.</p>
            <p>The symbol referred to by
            <c>index</c>
            differs from
            <c>seek()</c>
            only
            in the case of filtering streams where
            <c>index</c>
            lies before the end
            of the stream. Unlike
            <c>seek()</c>
            , this method does not adjust
            <c>index</c>
            to point to a non-ignored symbol.</p>
            </summary>
            <exception cref="T:System.ArgumentException">if {code index} is less than 0</exception>
            <exception cref="T:System.NotSupportedException">
            if the stream does not support
            retrieving the token at the specified index
            </exception>
        </member>
        <member name="P:Antlr4.Runtime.ITokenStream.TokenSource">
            <summary>
            Gets the underlying
            <see cref="T:Antlr4.Runtime.ITokenSource"/>
            which provides tokens for this
            stream.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.ITokenStream.GetText(Antlr4.Runtime.Misc.Interval)">
            <summary>
            Return the text of all tokens within the specified
            <paramref name="interval"/>
            . This
            method behaves like the following code (including potential exceptions
            for violating preconditions of
            <see cref="M:Antlr4.Runtime.ITokenStream.Get(System.Int32)"/>
            , but may be optimized by the
            specific implementation.
            <pre>
            TokenStream stream = ...;
            String text = "";
            for (int i = interval.a; i &lt;= interval.b; i++) {
            text += stream.get(i).getText();
            }
            </pre>
            </summary>
            <param name="interval">
            The interval of tokens within this stream to get text
            for.
            </param>
            <returns>
            The text of all tokens within the specified interval in this
            stream.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            if
            <paramref name="interval"/>
            is
            <see langword="null"/>
            </exception>
        </member>
        <member name="M:Antlr4.Runtime.ITokenStream.GetText">
            <summary>Return the text of all tokens in the stream.</summary>
            <remarks>
            Return the text of all tokens in the stream. This method behaves like the
            following code, including potential exceptions from the calls to
            <see cref="P:Antlr4.Runtime.IIntStream.Size"/>
            and
            <see cref="M:Antlr4.Runtime.ITokenStream.GetText(Antlr4.Runtime.Misc.Interval)"/>
            , but may be
            optimized by the specific implementation.
            <pre>
            TokenStream stream = ...;
            String text = stream.getText(new Interval(0, stream.size()));
            </pre>
            </remarks>
            <returns>The text of all tokens in the stream.</returns>
        </member>
        <member name="M:Antlr4.Runtime.ITokenStream.GetText(Antlr4.Runtime.RuleContext)">
            <summary>
            Return the text of all tokens in the source interval of the specified
            context.
            </summary>
            <remarks>
            Return the text of all tokens in the source interval of the specified
            context. This method behaves like the following code, including potential
            exceptions from the call to
            <see cref="M:Antlr4.Runtime.ITokenStream.GetText(Antlr4.Runtime.Misc.Interval)"/>
            , but may be
            optimized by the specific implementation.
            <p>If
            <c>ctx.getSourceInterval()</c>
            does not return a valid interval of
            tokens provided by this stream, the behavior is unspecified.</p>
            <pre>
            TokenStream stream = ...;
            String text = stream.getText(ctx.getSourceInterval());
            </pre>
            </remarks>
            <param name="ctx">
            The context providing the source interval of tokens to get
            text for.
            </param>
            <returns>
            The text of all tokens within the source interval of
            <paramref name="ctx"/>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.ITokenStream.GetText(Antlr4.Runtime.IToken,Antlr4.Runtime.IToken)">
            <summary>
            Return the text of all tokens in this stream between
            <paramref name="start"/>
            and
            <paramref name="stop"/>
            (inclusive).
            <p>If the specified
            <paramref name="start"/>
            or
            <paramref name="stop"/>
            token was not provided by
            this stream, or if the
            <paramref name="stop"/>
            occurred before the
            <paramref name="start"/>
            token, the behavior is unspecified.</p>
            <p>For streams which ensure that the
            <see cref="P:Antlr4.Runtime.IToken.TokenIndex"/>
            method is
            accurate for all of its provided tokens, this method behaves like the
            following code. Other streams may implement this method in other ways
            provided the behavior is consistent with this at a high level.</p>
            <pre>
            TokenStream stream = ...;
            String text = "";
            for (int i = start.getTokenIndex(); i &lt;= stop.getTokenIndex(); i++) {
            text += stream.get(i).getText();
            }
            </pre>
            </summary>
            <param name="start">The first token in the interval to get text for.</param>
            <param name="stop">The last token in the interval to get text for (inclusive).</param>
            <returns>
            The text of all tokens lying between the specified
            <paramref name="start"/>
            and
            <paramref name="stop"/>
            tokens.
            </returns>
            <exception cref="T:System.NotSupportedException">
            if this stream does not support
            this method for the specified tokens
            </exception>
        </member>
        <member name="T:Antlr4.Runtime.IVocabulary">
            <summary>
            This interface provides information about the vocabulary used by a
            recognizer.
            </summary>
            <remarks>
            This interface provides information about the vocabulary used by a
            recognizer.
            </remarks>
            <seealso cref="P:Antlr4.Runtime.Recognizer`2.Vocabulary"/>
            <author>Sam Harwell</author>
        </member>
        <member name="M:Antlr4.Runtime.IVocabulary.GetLiteralName(System.Int32)">
            <summary>Gets the string literal associated with a token type.</summary>
            <remarks>
            Gets the string literal associated with a token type. The string returned
            by this method, when not
            <see langword="null"/>
            , can be used unaltered in a parser
            grammar to represent this token type.
            <p>The following table shows examples of lexer rules and the literal
            names assigned to the corresponding token types.</p>
            <table>
            <tr>
            <th>Rule</th>
            <th>Literal Name</th>
            <th>Java String Literal</th>
            </tr>
            <tr>
            <td>
            <c>THIS : 'this';</c>
            </td>
            <td>
            <c>'this'</c>
            </td>
            <td>
            <c>"'this'"</c>
            </td>
            </tr>
            <tr>
            <td>
            <c>SQUOTE : '\'';</c>
            </td>
            <td>
            <c>'\''</c>
            </td>
            <td>
            <c>"'\\''"</c>
            </td>
            </tr>
            <tr>
            <td>
            <c>ID : [A-Z]+;</c>
            </td>
            <td>n/a</td>
            <td>
            <see langword="null"/>
            </td>
            </tr>
            </table>
            </remarks>
            <param name="tokenType">The token type.</param>
            <returns>
            The string literal associated with the specified token type, or
            <see langword="null"/>
            if no string literal is associated with the type.
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.IVocabulary.GetSymbolicName(System.Int32)">
            <summary>Gets the symbolic name associated with a token type.</summary>
            <remarks>
            Gets the symbolic name associated with a token type. The string returned
            by this method, when not
            <see langword="null"/>
            , can be used unaltered in a parser
            grammar to represent this token type.
            <p>This method supports token types defined by any of the following
            methods:</p>
            <ul>
            <li>Tokens created by lexer rules.</li>
            <li>Tokens defined in a
            <c/>
            tokens
            block in a lexer or parser
            grammar.</li>
            <li>The implicitly defined
            <c>EOF</c>
            token, which has the token type
            <see cref="F:Antlr4.Runtime.TokenConstants.EOF"/>
            .</li>
            </ul>
            <p>The following table shows examples of lexer rules and the literal
            names assigned to the corresponding token types.</p>
            <table>
            <tr>
            <th>Rule</th>
            <th>Symbolic Name</th>
            </tr>
            <tr>
            <td>
            <c>THIS : 'this';</c>
            </td>
            <td>
            <c>THIS</c>
            </td>
            </tr>
            <tr>
            <td>
            <c>SQUOTE : '\'';</c>
            </td>
            <td>
            <c>SQUOTE</c>
            </td>
            </tr>
            <tr>
            <td>
            <c>ID : [A-Z]+;</c>
            </td>
            <td>
            <c>ID</c>
            </td>
            </tr>
            </table>
            </remarks>
            <param name="tokenType">The token type.</param>
            <returns>
            The symbolic name associated with the specified token type, or
            <see langword="null"/>
            if no symbolic name is associated with the type.
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.IVocabulary.GetDisplayName(System.Int32)">
            <summary>Gets the display name of a token type.</summary>
            <remarks>
            Gets the display name of a token type.
            <p>ANTLR provides a default implementation of this method, but
            applications are free to override the behavior in any manner which makes
            sense for the application. The default implementation returns the first
            result from the following list which produces a non-
            <see langword="null"/>
            result.</p>
            <ol>
            <li>The result of
            <see cref="M:Antlr4.Runtime.IVocabulary.GetLiteralName(System.Int32)"/>
            </li>
            <li>The result of
            <see cref="M:Antlr4.Runtime.IVocabulary.GetSymbolicName(System.Int32)"/>
            </li>
            <li>The result of
            <see cref="M:System.Int32.ToString"/>
            </li>
            </ol>
            </remarks>
            <param name="tokenType">The token type.</param>
            <returns>
            The display name of the token type, for use in error reporting or
            other user-visible messages which reference specific token types.
            </returns>
        </member>
        <member name="T:Antlr4.Runtime.Lexer">
            <summary>A lexer is recognizer that draws input symbols from a character stream.</summary>
            <remarks>
            A lexer is recognizer that draws input symbols from a character stream.
            lexer grammars result in a subclass of this object. A Lexer object
            uses simplified match() and error recovery mechanisms in the interest
            of speed.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Lexer._factory">
            <summary>How to create token objects</summary>
        </member>
        <member name="F:Antlr4.Runtime.Lexer._token">
            <summary>The goal of all lexer rules/methods is to create a token object.</summary>
            <remarks>
            The goal of all lexer rules/methods is to create a token object.
            This is an instance variable as multiple rules may collaborate to
            create a single token.  nextToken will return this object after
            matching lexer rule(s).  If you subclass to allow multiple token
            emissions, then set this to the last token to be matched or
            something nonnull so that the auto token emit mechanism will not
            emit another token.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Lexer._tokenStartCharIndex">
            <summary>
            What character index in the stream did the current token start at?
            Needed, for example, to get the text for current token.
            </summary>
            <remarks>
            What character index in the stream did the current token start at?
            Needed, for example, to get the text for current token.  Set at
            the start of nextToken.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Lexer._tokenStartLine">
            <summary>The line on which the first character of the token resides</summary>
        </member>
        <member name="F:Antlr4.Runtime.Lexer._tokenStartColumn">
            <summary>The character position of first character within the line</summary>
        </member>
        <member name="F:Antlr4.Runtime.Lexer._hitEOF">
            <summary>Once we see EOF on char stream, next token will be EOF.</summary>
            <remarks>
            Once we see EOF on char stream, next token will be EOF.
            If you have DONE : EOF ; then you see DONE EOF.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Lexer._channel">
            <summary>The channel number for the current token</summary>
        </member>
        <member name="F:Antlr4.Runtime.Lexer._type">
            <summary>The token type for the current token</summary>
        </member>
        <member name="F:Antlr4.Runtime.Lexer._text">
            <summary>
            You can set the text for the current token to override what is in
            the input char buffer.
            </summary>
            <remarks>
            You can set the text for the current token to override what is in
            the input char buffer.  Use setText() or can set this instance var.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Lexer.NextToken">
            <summary>
            Return a token from this source; i.e., match a token on the char
            stream.
            </summary>
            <remarks>
            Return a token from this source; i.e., match a token on the char
            stream.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Lexer.Skip">
            <summary>
            Instruct the lexer to skip creating a token for current lexer rule
            and look for another token.
            </summary>
            <remarks>
            Instruct the lexer to skip creating a token for current lexer rule
            and look for another token.  nextToken() knows to keep looking when
            a lexer rule finishes with token set to SKIP_TOKEN.  Recall that
            if token==null at end of any token rule, it creates one for you
            and emits it.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Lexer.SetInputStream(Antlr4.Runtime.ICharStream)">
            <summary>Set the char stream and reset the lexer</summary>
        </member>
        <member name="M:Antlr4.Runtime.Lexer.Emit(Antlr4.Runtime.IToken)">
            <summary>
            By default does not support multiple emits per nextToken invocation
            for efficiency reasons.
            </summary>
            <remarks>
            By default does not support multiple emits per nextToken invocation
            for efficiency reasons.  Subclass and override this method, nextToken,
            and getToken (to push tokens into a list and pull from that list
            rather than a single variable as this implementation does).
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Lexer.Emit">
            <summary>
            The standard method called to automatically emit a token at the
            outermost lexical rule.
            </summary>
            <remarks>
            The standard method called to automatically emit a token at the
            outermost lexical rule.  The token object should point into the
            char buffer start..stop.  If there is a text override in 'text',
            use that to set the token's text.  Override this method to emit
            custom Token objects or provide a new factory.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Lexer.CharIndex">
            <summary>What is the index of the current character of lookahead?</summary>
        </member>
        <member name="P:Antlr4.Runtime.Lexer.Text">
            <summary>
            Return the text matched so far for the current token or any text
            override.
            </summary>
            <remarks>
            Return the text matched so far for the current token or any text
            override.
            </remarks>
            <summary>
            Set the complete text of this token; it wipes any previous changes to the
            text.
            </summary>
            <remarks>
            Set the complete text of this token; it wipes any previous changes to the
            text.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Lexer.Token">
            <summary>Override if emitting multiple tokens.</summary>
            <remarks>Override if emitting multiple tokens.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.Lexer.GetAllTokens">
            <summary>Return a list of all Token objects in input char stream.</summary>
            <remarks>
            Return a list of all Token objects in input char stream.
            Forces load of all tokens. Does not include EOF token.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Lexer.Recover(Antlr4.Runtime.RecognitionException)">
            <summary>
            Lexers can normally match any char in it's vocabulary after matching
            a token, so do the easy thing and just kill a character and hope
            it all works out.
            </summary>
            <remarks>
            Lexers can normally match any char in it's vocabulary after matching
            a token, so do the easy thing and just kill a character and hope
            it all works out.  You can instead use the rule invocation stack
            to do sophisticated error recovery if you are in a fragment rule.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.LexerNoViableAltException.startIndex">
            <summary>Matching attempted at what input index?</summary>
        </member>
        <member name="F:Antlr4.Runtime.LexerNoViableAltException.deadEndConfigs">
            <summary>Which configurations did we try at input.index() that couldn't match input.LA(1)?</summary>
        </member>
        <member name="T:Antlr4.Runtime.ListTokenSource">
            <summary>
            Provides an implementation of
            <see cref="T:Antlr4.Runtime.ITokenSource"/>
            as a wrapper around a list
            of
            <see cref="T:Antlr4.Runtime.IToken"/>
            objects.
            <p>If the final token in the list is an
            <see cref="F:Antlr4.Runtime.TokenConstants.EOF"/>
            token, it will be used
            as the EOF token for every call to
            <see cref="M:Antlr4.Runtime.ListTokenSource.NextToken"/>
            after the end of the
            list is reached. Otherwise, an EOF token will be created.</p>
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.ListTokenSource.tokens">
            <summary>
            The wrapped collection of
            <see cref="T:Antlr4.Runtime.IToken"/>
            objects to return.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.ListTokenSource.sourceName">
            <summary>The name of the input source.</summary>
            <remarks>
            The name of the input source. If this value is
            <see langword="null"/>
            , a call to
            <see cref="P:Antlr4.Runtime.ListTokenSource.SourceName"/>
            should return the source name used to create the
            the next token in
            <see cref="F:Antlr4.Runtime.ListTokenSource.tokens"/>
            (or the previous token if the end of
            the input has been reached).
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.ListTokenSource.i">
            <summary>
            The index into
            <see cref="F:Antlr4.Runtime.ListTokenSource.tokens"/>
            of token to return by the next call to
            <see cref="M:Antlr4.Runtime.ListTokenSource.NextToken"/>
            . The end of the input is indicated by this value
            being greater than or equal to the number of items in
            <see cref="F:Antlr4.Runtime.ListTokenSource.tokens"/>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.ListTokenSource.eofToken">
            <summary>This field caches the EOF token for the token source.</summary>
            <remarks>This field caches the EOF token for the token source.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.ListTokenSource._factory">
            <summary>
            This is the backing field for the <see cref="P:Antlr4.Runtime.ListTokenSource.TokenFactory"/> property.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.ListTokenSource.#ctor(System.Collections.Generic.IList{Antlr4.Runtime.IToken})">
            <summary>
            Constructs a new
            <see cref="T:Antlr4.Runtime.ListTokenSource"/>
            instance from the specified
            collection of
            <see cref="T:Antlr4.Runtime.IToken"/>
            objects.
            </summary>
            <param name="tokens">
            The collection of
            <see cref="T:Antlr4.Runtime.IToken"/>
            objects to provide as a
            <see cref="T:Antlr4.Runtime.ITokenSource"/>
            .
            </param>
            <exception>
            NullPointerException
            if
            <paramref name="tokens"/>
            is
            <see langword="null"/>
            </exception>
        </member>
        <member name="M:Antlr4.Runtime.ListTokenSource.#ctor(System.Collections.Generic.IList{Antlr4.Runtime.IToken},System.String)">
            <summary>
            Constructs a new
            <see cref="T:Antlr4.Runtime.ListTokenSource"/>
            instance from the specified
            collection of
            <see cref="T:Antlr4.Runtime.IToken"/>
            objects and source name.
            </summary>
            <param name="tokens">
            The collection of
            <see cref="T:Antlr4.Runtime.IToken"/>
            objects to provide as a
            <see cref="T:Antlr4.Runtime.ITokenSource"/>
            .
            </param>
            <param name="sourceName">
            The name of the
            <see cref="T:Antlr4.Runtime.ITokenSource"/>
            . If this value is
            <see langword="null"/>
            ,
            <see cref="P:Antlr4.Runtime.ListTokenSource.SourceName"/>
            will attempt to infer the name from
            the next
            <see cref="T:Antlr4.Runtime.IToken"/>
            (or the previous token if the end of the input has
            been reached).
            </param>
            <exception>
            NullPointerException
            if
            <paramref name="tokens"/>
            is
            <see langword="null"/>
            </exception>
        </member>
        <member name="P:Antlr4.Runtime.ListTokenSource.Column">
            <summary><inheritDoc/></summary>
        </member>
        <member name="M:Antlr4.Runtime.ListTokenSource.NextToken">
            <summary><inheritDoc/></summary>
        </member>
        <member name="P:Antlr4.Runtime.ListTokenSource.Line">
            <summary><inheritDoc/></summary>
        </member>
        <member name="P:Antlr4.Runtime.ListTokenSource.InputStream">
            <summary><inheritDoc/></summary>
        </member>
        <member name="P:Antlr4.Runtime.ListTokenSource.SourceName">
            <summary><inheritDoc/></summary>
        </member>
        <member name="P:Antlr4.Runtime.ListTokenSource.TokenFactory">
            <summary><inheritDoc/></summary>
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:Antlr4.Runtime.Misc.Args">
            <author>Sam Harwell</author>
        </member>
        <member name="M:Antlr4.Runtime.Misc.Args.NotNull(System.String,System.Object)">
            <exception cref="T:System.ArgumentNullException">
            if
            <paramref name="value"/>
            is
            <see langword="null"/>
            .
            </exception>
        </member>
        <member name="T:Antlr4.Runtime.Misc.IIntSet">
            <summary>A generic set of integers.</summary>
            <remarks>A generic set of integers.</remarks>
            <seealso cref="T:Antlr4.Runtime.Misc.IntervalSet"/>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IIntSet.Add(System.Int32)">
            <summary>Adds the specified value to the current set.</summary>
            <remarks>Adds the specified value to the current set.</remarks>
            <param name="el">the value to add</param>
            <exception>
            IllegalStateException
            if the current set is read-only
            </exception>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IIntSet.AddAll(Antlr4.Runtime.Misc.IIntSet)">
             <summary>
             Modify the current
             <see cref="T:Antlr4.Runtime.Misc.IIntSet"/>
             object to contain all elements that are
             present in itself, the specified
             <paramref name="set"/>
             , or both.
             </summary>
             <param name="set">
             The set to add to the current set. A
             <see langword="null"/>
             argument is
             treated as though it were an empty set.
             </param>
             <returns>
            
             <c>this</c>
             (to support chained calls)
             </returns>
             <exception>
             IllegalStateException
             if the current set is read-only
             </exception>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IIntSet.And(Antlr4.Runtime.Misc.IIntSet)">
            <summary>
            Return a new
            <see cref="T:Antlr4.Runtime.Misc.IIntSet"/>
            object containing all elements that are
            present in both the current set and the specified set
            <paramref name="a"/>
            .
            </summary>
            <param name="a">
            The set to intersect with the current set. A
            <see langword="null"/>
            argument is treated as though it were an empty set.
            </param>
            <returns>
            A new
            <see cref="T:Antlr4.Runtime.Misc.IIntSet"/>
            instance containing the intersection of the
            current set and
            <paramref name="a"/>
            . The value
            <see langword="null"/>
            may be returned in
            place of an empty result set.
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IIntSet.Complement(Antlr4.Runtime.Misc.IIntSet)">
            <summary>
            Return a new
            <see cref="T:Antlr4.Runtime.Misc.IIntSet"/>
            object containing all elements that are
            present in
            <paramref name="elements"/>
            but not present in the current set. The
            following expressions are equivalent for input non-null
            <see cref="T:Antlr4.Runtime.Misc.IIntSet"/>
            instances
            <c>x</c>
            and
            <c>y</c>
            .
            <ul>
            <li>
            <c>x.complement(y)</c>
            </li>
            <li>
            <c>y.subtract(x)</c>
            </li>
            </ul>
            </summary>
            <param name="elements">
            The set to compare with the current set. A
            <see langword="null"/>
            argument is treated as though it were an empty set.
            </param>
            <returns>
            A new
            <see cref="T:Antlr4.Runtime.Misc.IIntSet"/>
            instance containing the elements present in
            <paramref name="elements"/>
            but not present in the current set. The value
            <see langword="null"/>
            may be returned in place of an empty result set.
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IIntSet.Or(Antlr4.Runtime.Misc.IIntSet)">
            <summary>
            Return a new
            <see cref="T:Antlr4.Runtime.Misc.IIntSet"/>
            object containing all elements that are
            present in the current set, the specified set
            <paramref name="a"/>
            , or both.
            <p>
            This method is similar to
            <see cref="M:Antlr4.Runtime.Misc.IIntSet.AddAll(Antlr4.Runtime.Misc.IIntSet)"/>
            , but returns a new
            <see cref="T:Antlr4.Runtime.Misc.IIntSet"/>
            instance instead of modifying the current set.</p>
            </summary>
            <param name="a">
            The set to union with the current set. A
            <see langword="null"/>
            argument
            is treated as though it were an empty set.
            </param>
            <returns>
            A new
            <see cref="T:Antlr4.Runtime.Misc.IIntSet"/>
            instance containing the union of the current
            set and
            <paramref name="a"/>
            . The value
            <see langword="null"/>
            may be returned in place of an
            empty result set.
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IIntSet.Subtract(Antlr4.Runtime.Misc.IIntSet)">
            <summary>
            Return a new
            <see cref="T:Antlr4.Runtime.Misc.IIntSet"/>
            object containing all elements that are
            present in the current set but not present in the input set
            <paramref name="a"/>
            .
            The following expressions are equivalent for input non-null
            <see cref="T:Antlr4.Runtime.Misc.IIntSet"/>
            instances
            <c>x</c>
            and
            <c>y</c>
            .
            <ul>
            <li>
            <c>y.subtract(x)</c>
            </li>
            <li>
            <c>x.complement(y)</c>
            </li>
            </ul>
            </summary>
            <param name="a">
            The set to compare with the current set. A
            <see langword="null"/>
            argument is treated as though it were an empty set.
            </param>
            <returns>
            A new
            <see cref="T:Antlr4.Runtime.Misc.IIntSet"/>
            instance containing the elements present in
            <c>elements</c>
            but not present in the current set. The value
            <see langword="null"/>
            may be returned in place of an empty result set.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Misc.IIntSet.Count">
            <summary>Return the total number of elements represented by the current set.</summary>
            <remarks>Return the total number of elements represented by the current set.</remarks>
            <returns>
            the total number of elements represented by the current set,
            regardless of the manner in which the elements are stored.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Misc.IIntSet.IsNil">
             <summary>
             Returns
             <see langword="true"/>
             if this set contains no elements.
             </summary>
             <returns>
            
             <see langword="true"/>
             if the current set contains no elements; otherwise,
             <see langword="false"/>
             .
             </returns>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IIntSet.Equals(System.Object)">
            <summary><inheritDoc/></summary>
        </member>
        <member name="P:Antlr4.Runtime.Misc.IIntSet.SingleElement">
            <summary>
            Returns the single value contained in the set, if
            <see cref="P:Antlr4.Runtime.Misc.IIntSet.Count"/>
            is 1;
            otherwise, returns
            <see cref="F:Antlr4.Runtime.TokenConstants.InvalidType"/>
            .
            </summary>
            <returns>
            the single value contained in the set, if
            <see cref="P:Antlr4.Runtime.Misc.IIntSet.Count"/>
            is 1;
            otherwise, returns
            <see cref="F:Antlr4.Runtime.TokenConstants.InvalidType"/>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IIntSet.Contains(System.Int32)">
             <summary>
             Returns
             <see langword="true"/>
             if the set contains the specified element.
             </summary>
             <param name="el">The element to check for.</param>
             <returns>
            
             <see langword="true"/>
             if the set contains
             <paramref name="el"/>
             ; otherwise
             <see langword="false"/>
             .
             </returns>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IIntSet.Remove(System.Int32)">
            <summary>Removes the specified value from the current set.</summary>
            <remarks>
            Removes the specified value from the current set. If the current set does
            not contain the element, no changes are made.
            </remarks>
            <param name="el">the value to remove</param>
            <exception>
            IllegalStateException
            if the current set is read-only
            </exception>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IIntSet.ToList">
            <summary>Return a list containing the elements represented by the current set.</summary>
            <remarks>
            Return a list containing the elements represented by the current set. The
            list is returned in ascending numerical order.
            </remarks>
            <returns>
            A list containing all element present in the current set, sorted
            in ascending numerical order.
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IIntSet.ToString">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:Antlr4.Runtime.Misc.Interval">
            <summary>An immutable inclusive interval a..b.</summary>
            <remarks>An immutable inclusive interval a..b.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.Misc.Interval.a">
            <summary>The start of the interval.</summary>
            <remarks>The start of the interval.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.Misc.Interval.b">
            <summary>The end of the interval (inclusive).</summary>
            <remarks>The end of the interval (inclusive).</remarks>
        </member>
        <member name="M:Antlr4.Runtime.Misc.Interval.Of(System.Int32,System.Int32)">
            <summary>
            Interval objects are used readonly so share all with the
            same single value a==b up to some max size.
            </summary>
            <remarks>
            Interval objects are used readonly so share all with the
            same single value a==b up to some max size.  Use an array as a perfect hash.
            Return shared object for 0..INTERVAL_POOL_MAX_VALUE or a new
            Interval object with a..a in it.  On Java.g4, 218623 IntervalSets
            have a..a (set with 1 element).
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Misc.Interval.Length">
            <summary>return number of elements between a and b inclusively.</summary>
            <remarks>
            return number of elements between a and b inclusively. x..x is length 1.
            if b &lt; a, then length is 0. 9..10 has length 2.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Misc.Interval.StartsBeforeDisjoint(Antlr4.Runtime.Misc.Interval)">
            <summary>Does this start completely before other? Disjoint</summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.Interval.StartsBeforeNonDisjoint(Antlr4.Runtime.Misc.Interval)">
            <summary>Does this start at or before other? Nondisjoint</summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.Interval.StartsAfter(Antlr4.Runtime.Misc.Interval)">
            <summary>Does this.a start after other.b? May or may not be disjoint</summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.Interval.StartsAfterDisjoint(Antlr4.Runtime.Misc.Interval)">
            <summary>Does this start completely after other? Disjoint</summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.Interval.StartsAfterNonDisjoint(Antlr4.Runtime.Misc.Interval)">
            <summary>Does this start after other? NonDisjoint</summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.Interval.Disjoint(Antlr4.Runtime.Misc.Interval)">
            <summary>Are both ranges disjoint? I.e., no overlap?</summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.Interval.Adjacent(Antlr4.Runtime.Misc.Interval)">
            <summary>Are two intervals adjacent such as 0..41 and 42..42?</summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.Interval.Union(Antlr4.Runtime.Misc.Interval)">
            <summary>Return the interval computed from combining this and other</summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.Interval.Intersection(Antlr4.Runtime.Misc.Interval)">
            <summary>Return the interval in common between this and o</summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.Interval.DifferenceNotProperlyContained(Antlr4.Runtime.Misc.Interval)">
            <summary>
            Return the interval with elements from
            <c>this</c>
            not in
            <paramref name="other"/>
            ;
            <paramref name="other"/>
            must not be totally enclosed (properly contained)
            within
            <c>this</c>
            , which would result in two disjoint intervals
            instead of the single one returned by this method.
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Misc.IntervalSet">
            <summary>
            This class implements the
            <see cref="T:Antlr4.Runtime.Misc.IIntSet"/>
            backed by a sorted array of
            non-overlapping intervals. It is particularly efficient for representing
            large collections of numbers, where the majority of elements appear as part
            of a sequential range of numbers that are all part of the set. For example,
            the set { 1, 2, 3, 4, 7, 8 } may be represented as { [1, 4], [7, 8] }.
            <p>
            This class is able to represent sets containing any combination of values in
            the range
            <see cref="F:System.Int32.MinValue"/>
            to
            <see cref="F:System.Int32.MaxValue"/>
            (inclusive).</p>
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Misc.IntervalSet.intervals">
            <summary>The list of sorted, disjoint intervals.</summary>
            <remarks>The list of sorted, disjoint intervals.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IntervalSet.Of(System.Int32)">
            <summary>Create a set with a single element, el.</summary>
            <remarks>Create a set with a single element, el.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IntervalSet.Of(System.Int32,System.Int32)">
            <summary>Create a set with all ints within range [a..b] (inclusive)</summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IntervalSet.Add(System.Int32)">
            <summary>Add a single element to the set.</summary>
            <remarks>
            Add a single element to the set.  An isolated element is stored
            as a range el..el.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IntervalSet.Add(System.Int32,System.Int32)">
            <summary>Add interval; i.e., add all integers from a to b to set.</summary>
            <remarks>
            Add interval; i.e., add all integers from a to b to set.
            If b&lt;a, do nothing.
            Keep list in sorted order (by left range value).
            If overlap, combine ranges.  For example,
            If this is {1..5, 10..20}, adding 6..7 yields
            {1..5, 6..7, 10..20}.  Adding 4..8 yields {1..8, 10..20}.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IntervalSet.Or(Antlr4.Runtime.Misc.IntervalSet[])">
            <summary>combine all sets in the array returned the or'd value</summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IntervalSet.Complement(Antlr4.Runtime.Misc.IIntSet)">
             <summary>
             <inheritDoc/>
            
             </summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IntervalSet.Subtract(Antlr4.Runtime.Misc.IntervalSet,Antlr4.Runtime.Misc.IntervalSet)">
            <summary>Compute the set difference between two interval sets.</summary>
            <remarks>
            Compute the set difference between two interval sets. The specific
            operation is
            <c>left - right</c>
            . If either of the input sets is
            <see langword="null"/>
            , it is treated as though it was an empty set.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IntervalSet.And(Antlr4.Runtime.Misc.IIntSet)">
             <summary>
             <inheritDoc/>
            
             </summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IntervalSet.Contains(System.Int32)">
             <summary>
             <inheritDoc/>
            
             </summary>
        </member>
        <member name="P:Antlr4.Runtime.Misc.IntervalSet.IsNil">
             <summary>
             <inheritDoc/>
            
             </summary>
        </member>
        <member name="P:Antlr4.Runtime.Misc.IntervalSet.SingleElement">
             <summary>
             <inheritDoc/>
            
             </summary>
        </member>
        <member name="P:Antlr4.Runtime.Misc.IntervalSet.MaxElement">
            <summary>Returns the maximum value contained in the set.</summary>
            <remarks>Returns the maximum value contained in the set.</remarks>
            <returns>
            the maximum value contained in the set. If the set is empty, this
            method returns
            <see cref="F:Antlr4.Runtime.TokenConstants.InvalidType"/>
            .
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Misc.IntervalSet.MinElement">
            <summary>Returns the minimum value contained in the set.</summary>
            <remarks>Returns the minimum value contained in the set.</remarks>
            <returns>
            the minimum value contained in the set. If the set is empty, this
            method returns
            <see cref="F:Antlr4.Runtime.TokenConstants.InvalidType"/>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IntervalSet.GetIntervals">
            <summary>Return a list of Interval objects.</summary>
            <remarks>Return a list of Interval objects.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IntervalSet.Equals(System.Object)">
            <summary>
            Are two IntervalSets equal?  Because all intervals are sorted
            and disjoint, equals is a simple linear walk over both lists
            to make sure they are the same.
            </summary>
            <remarks>
            Are two IntervalSets equal?  Because all intervals are sorted
            and disjoint, equals is a simple linear walk over both lists
            to make sure they are the same.  Interval.equals() is used
            by the List.equals() method to check the ranges.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.Misc.MurmurHash">
            <author>Sam Harwell</author>
        </member>
        <member name="M:Antlr4.Runtime.Misc.MurmurHash.Initialize">
            <summary>Initialize the hash using the default seed value.</summary>
            <remarks>Initialize the hash using the default seed value.</remarks>
            <returns>the intermediate hash value</returns>
        </member>
        <member name="M:Antlr4.Runtime.Misc.MurmurHash.Initialize(System.Int32)">
            <summary>
            Initialize the hash using the specified
            <paramref name="seed"/>
            .
            </summary>
            <param name="seed">the seed</param>
            <returns>the intermediate hash value</returns>
        </member>
        <member name="M:Antlr4.Runtime.Misc.MurmurHash.Update(System.Int32,System.Int32)">
            <summary>
            Update the intermediate hash value for the next input
            <paramref name="value"/>
            .
            </summary>
            <param name="hash">the intermediate hash value</param>
            <param name="value">the value to add to the current hash</param>
            <returns>the updated intermediate hash value</returns>
        </member>
        <member name="M:Antlr4.Runtime.Misc.MurmurHash.Update(System.Int32,System.Object)">
            <summary>
            Update the intermediate hash value for the next input
            <paramref name="value"/>
            .
            </summary>
            <param name="hash">the intermediate hash value</param>
            <param name="value">the value to add to the current hash</param>
            <returns>the updated intermediate hash value</returns>
        </member>
        <member name="M:Antlr4.Runtime.Misc.MurmurHash.Finish(System.Int32,System.Int32)">
            <summary>
            Apply the final computation steps to the intermediate value
            <paramref name="hash"/>
            to form the final result of the MurmurHash 3 hash function.
            </summary>
            <param name="hash">the intermediate hash value</param>
            <param name="numberOfWords">the number of integer values added to the hash</param>
            <returns>the final hash result</returns>
        </member>
        <member name="M:Antlr4.Runtime.Misc.MurmurHash.HashCode``1(``0[],System.Int32)">
            <summary>
            Utility function to compute the hash code of an array using the
            MurmurHash algorithm.
            </summary>
            <remarks>
            Utility function to compute the hash code of an array using the
            MurmurHash algorithm.
            </remarks>
            <param name="data">the array data</param>
            <param name="seed">the seed for the MurmurHash algorithm</param>
            <returns>the hash code of the data</returns>
        </member>
        <member name="T:Antlr4.Runtime.Misc.ParseCanceledException">
            <summary>This exception is thrown to cancel a parsing operation.</summary>
            <remarks>
            This exception is thrown to cancel a parsing operation. This exception does
            not extend
            <see cref="T:Antlr4.Runtime.RecognitionException"/>
            , allowing it to bypass the standard
            error recovery mechanisms.
            <see cref="T:Antlr4.Runtime.BailErrorStrategy"/>
            throws this exception in
            response to a parse error.
            </remarks>
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Misc.RuleDependencyChecker">
            <author>Sam Harwell</author>
        </member>
        <member name="M:Antlr4.Runtime.Misc.Utils.ToMap(System.String[])">
            <summary>Convert array of strings to string&#x2192;index map.</summary>
            <remarks>
            Convert array of strings to string&#x2192;index map. Useful for
            converting rulenames to name&#x2192;ruleindex map.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.NoViableAltException">
            <summary>
            Indicates that the parser could not decide which of two or more paths
            to take based upon the remaining input.
            </summary>
            <remarks>
            Indicates that the parser could not decide which of two or more paths
            to take based upon the remaining input. It tracks the starting token
            of the offending input and also knows where the parser was
            in the various paths when the error. Reported by reportNoViableAlternative()
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.NoViableAltException.deadEndConfigs">
            <summary>Which configurations did we try at input.index() that couldn't match input.LT(1)?</summary>
        </member>
        <member name="F:Antlr4.Runtime.NoViableAltException.startToken">
            <summary>
            The token object at the start index; the input stream might
            not be buffering tokens so get a reference to it.
            </summary>
            <remarks>
            The token object at the start index; the input stream might
            not be buffering tokens so get a reference to it. (At the
            time the error occurred, of course the stream needs to keep a
            buffer all of the tokens but later we might not have access to those.)
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.Parser">
            <summary>This is all the parsing support code essentially; most of it is error recovery stuff.</summary>
            <remarks>This is all the parsing support code essentially; most of it is error recovery stuff.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.Parser.bypassAltsAtnCache">
            <summary>
            This field maps from the serialized ATN string to the deserialized
            <see cref="T:Antlr4.Runtime.Atn.ATN"/>
            with
            bypass alternatives.
            </summary>
            <seealso cref="P:Antlr4.Runtime.Atn.ATNDeserializationOptions.GenerateRuleBypassTransitions"/>
        </member>
        <member name="F:Antlr4.Runtime.Parser._errHandler">
            <summary>The error handling strategy for the parser.</summary>
            <remarks>
            The error handling strategy for the parser. The default value is a new
            instance of
            <see cref="T:Antlr4.Runtime.DefaultErrorStrategy"/>
            .
            </remarks>
            <seealso cref="P:Antlr4.Runtime.Parser.ErrorHandler"/>
        </member>
        <member name="F:Antlr4.Runtime.Parser._input">
            <summary>The input stream.</summary>
            <remarks>The input stream.</remarks>
            <seealso cref="P:Antlr4.Runtime.Parser.InputStream"/>
        </member>
        <member name="F:Antlr4.Runtime.Parser._ctx">
            <summary>
            The
            <see cref="T:Antlr4.Runtime.ParserRuleContext"/>
            object for the currently executing rule.
            This is always non-null during the parsing process.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Parser._buildParseTrees">
            <summary>
            Specifies whether or not the parser should construct a parse tree during
            the parsing process.
            </summary>
            <remarks>
            Specifies whether or not the parser should construct a parse tree during
            the parsing process. The default value is
            <see langword="true"/>
            .
            </remarks>
            <seealso cref="P:Antlr4.Runtime.Parser.BuildParseTree"/>
        </member>
        <member name="F:Antlr4.Runtime.Parser._tracer">
            <summary>
            When
            <see cref="P:Antlr4.Runtime.Parser.Trace"/>
            <c>(true)</c>
            is called, a reference to the
            <see cref="T:Antlr4.Runtime.Parser.TraceListener"/>
            is stored here so it can be easily removed in a
            later call to
            <see cref="P:Antlr4.Runtime.Parser.Trace"/>
            <c>(false)</c>
            . The listener itself is
            implemented as a parser listener so this field is not directly used by
            other parser methods.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Parser._parseListeners">
            <summary>
            The list of
            <see cref="T:Antlr4.Runtime.Tree.IParseTreeListener"/>
            listeners registered to receive
            events during the parse.
            </summary>
            <seealso cref="M:Antlr4.Runtime.Parser.AddParseListener(Antlr4.Runtime.Tree.IParseTreeListener)"/>
        </member>
        <member name="F:Antlr4.Runtime.Parser._syntaxErrors">
            <summary>The number of syntax errors reported during parsing.</summary>
            <remarks>
            The number of syntax errors reported during parsing. This value is
            incremented each time
            <see cref="M:Antlr4.Runtime.Parser.NotifyErrorListeners(System.String)"/>
            is called.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Parser.Reset">
            <summary>reset the parser's state</summary>
        </member>
        <member name="M:Antlr4.Runtime.Parser.Match(System.Int32)">
            <summary>
            Match current input symbol against
            <paramref name="ttype"/>
            . If the symbol type
            matches,
            <see cref="M:Antlr4.Runtime.IAntlrErrorStrategy.ReportMatch(Antlr4.Runtime.Parser)"/>
            and
            <see cref="M:Antlr4.Runtime.Parser.Consume"/>
            are
            called to complete the match process.
            <p>If the symbol type does not match,
            <see cref="M:Antlr4.Runtime.IAntlrErrorStrategy.RecoverInline(Antlr4.Runtime.Parser)"/>
            is called on the current error
            strategy to attempt recovery. If
            <see cref="P:Antlr4.Runtime.Parser.BuildParseTree"/>
            is
            <see langword="true"/>
            and the token index of the symbol returned by
            <see cref="M:Antlr4.Runtime.IAntlrErrorStrategy.RecoverInline(Antlr4.Runtime.Parser)"/>
            is -1, the symbol is added to
            the parse tree by calling
            <see cref="M:Antlr4.Runtime.ParserRuleContext.AddErrorNode(Antlr4.Runtime.IToken)"/>
            .</p>
            </summary>
            <param name="ttype">the token type to match</param>
            <returns>the matched symbol</returns>
            <exception cref="T:Antlr4.Runtime.RecognitionException">
            if the current input symbol did not match
            <paramref name="ttype"/>
            and the error strategy could not recover from the
            mismatched symbol
            </exception>
            <exception cref="T:Antlr4.Runtime.RecognitionException"/>
        </member>
        <member name="M:Antlr4.Runtime.Parser.MatchWildcard">
            <summary>Match current input symbol as a wildcard.</summary>
            <remarks>
            Match current input symbol as a wildcard. If the symbol type matches
            (i.e. has a value greater than 0),
            <see cref="M:Antlr4.Runtime.IAntlrErrorStrategy.ReportMatch(Antlr4.Runtime.Parser)"/>
            and
            <see cref="M:Antlr4.Runtime.Parser.Consume"/>
            are called to complete the match process.
            <p>If the symbol type does not match,
            <see cref="M:Antlr4.Runtime.IAntlrErrorStrategy.RecoverInline(Antlr4.Runtime.Parser)"/>
            is called on the current error
            strategy to attempt recovery. If
            <see cref="P:Antlr4.Runtime.Parser.BuildParseTree"/>
            is
            <see langword="true"/>
            and the token index of the symbol returned by
            <see cref="M:Antlr4.Runtime.IAntlrErrorStrategy.RecoverInline(Antlr4.Runtime.Parser)"/>
            is -1, the symbol is added to
            the parse tree by calling
            <see cref="M:Antlr4.Runtime.ParserRuleContext.AddErrorNode(Antlr4.Runtime.IToken)"/>
            .</p>
            </remarks>
            <returns>the matched symbol</returns>
            <exception cref="T:Antlr4.Runtime.RecognitionException">
            if the current input symbol did not match
            a wildcard and the error strategy could not recover from the mismatched
            symbol
            </exception>
            <exception cref="T:Antlr4.Runtime.RecognitionException"/>
        </member>
        <member name="P:Antlr4.Runtime.Parser.BuildParseTree">
             <summary>
             Track the
             <see cref="T:Antlr4.Runtime.ParserRuleContext"/>
             objects during the parse and hook
             them up using the
             <see cref="F:Antlr4.Runtime.ParserRuleContext.children"/>
             list so that it
             forms a parse tree. The
             <see cref="T:Antlr4.Runtime.ParserRuleContext"/>
             returned from the start
             rule represents the root of the parse tree.
             <p>Note that if we are not building parse trees, rule contexts only point
             upwards. When a rule exits, it returns the context but that gets garbage
             collected if nobody holds a reference. It points upwards but nobody
             points at it.</p>
             <p>When we build parse trees, we are adding all of these contexts to
             <see cref="F:Antlr4.Runtime.ParserRuleContext.children"/>
             list. Contexts are then not candidates
             for garbage collection.</p>
             </summary>
             <summary>
             Gets whether or not a complete parse tree will be constructed while
             parsing.
             </summary>
             <remarks>
             Gets whether or not a complete parse tree will be constructed while
             parsing. This property is
             <see langword="true"/>
             for a newly constructed parser.
             </remarks>
             <returns>
            
             <see langword="true"/>
             if a complete parse tree will be constructed while
             parsing, otherwise
             <see langword="false"/>
             </returns>
        </member>
        <member name="P:Antlr4.Runtime.Parser.TrimParseTree">
             <summary>Trim the internal lists of the parse tree during parsing to conserve memory.</summary>
             <remarks>
             Trim the internal lists of the parse tree during parsing to conserve memory.
             This property is set to
             <see langword="false"/>
             by default for a newly constructed parser.
             </remarks>
             <value>
            
             <see langword="true"/>
             to trim the capacity of the
             <see cref="F:Antlr4.Runtime.ParserRuleContext.children"/>
             list to its size after a rule is parsed.
             </value>
             <returns>
            
             <see langword="true"/>
             if the
             <see cref="F:Antlr4.Runtime.ParserRuleContext.children"/>
             list is trimmed
             using the default
             <see cref="T:Antlr4.Runtime.Parser.TrimToSizeListener"/>
             during the parse process.
             </returns>
        </member>
        <member name="M:Antlr4.Runtime.Parser.AddParseListener(Antlr4.Runtime.Tree.IParseTreeListener)">
            <summary>
            Registers
            <paramref name="listener"/>
            to receive events during the parsing process.
            <p>To support output-preserving grammar transformations (including but not
            limited to left-recursion removal, automated left-factoring, and
            optimized code generation), calls to listener methods during the parse
            may differ substantially from calls made by
            <see cref="F:Antlr4.Runtime.Tree.ParseTreeWalker.Default"/>
            used after the parse is complete. In
            particular, rule entry and exit events may occur in a different order
            during the parse than after the parser. In addition, calls to certain
            rule entry methods may be omitted.</p>
            <p>With the following specific exceptions, calls to listener events are
            <em>deterministic</em>, i.e. for identical input the calls to listener
            methods will be the same.</p>
            <ul>
            <li>Alterations to the grammar used to generate code may change the
            behavior of the listener calls.</li>
            <li>Alterations to the command line options passed to ANTLR 4 when
            generating the parser may change the behavior of the listener calls.</li>
            <li>Changing the version of the ANTLR Tool used to generate the parser
            may change the behavior of the listener calls.</li>
            </ul>
            </summary>
            <param name="listener">the listener to add</param>
            <exception cref="T:System.ArgumentNullException">
            if
            <c/>
            listener is
            <see langword="null"/>
            </exception>
        </member>
        <member name="M:Antlr4.Runtime.Parser.RemoveParseListener(Antlr4.Runtime.Tree.IParseTreeListener)">
            <summary>
            Remove
            <paramref name="listener"/>
            from the list of parse listeners.
            <p>If
            <paramref name="listener"/>
            is
            <see langword="null"/>
            or has not been added as a parse
            listener, this method does nothing.</p>
            </summary>
            <seealso cref="M:Antlr4.Runtime.Parser.AddParseListener(Antlr4.Runtime.Tree.IParseTreeListener)"/>
            <param name="listener">the listener to remove</param>
        </member>
        <member name="M:Antlr4.Runtime.Parser.RemoveParseListeners">
            <summary>Remove all parse listeners.</summary>
            <remarks>Remove all parse listeners.</remarks>
            <seealso cref="M:Antlr4.Runtime.Parser.AddParseListener(Antlr4.Runtime.Tree.IParseTreeListener)"/>
        </member>
        <member name="M:Antlr4.Runtime.Parser.TriggerEnterRuleEvent">
            <summary>Notify any parse listeners of an enter rule event.</summary>
            <remarks>Notify any parse listeners of an enter rule event.</remarks>
            <seealso cref="M:Antlr4.Runtime.Parser.AddParseListener(Antlr4.Runtime.Tree.IParseTreeListener)"/>
        </member>
        <member name="M:Antlr4.Runtime.Parser.TriggerExitRuleEvent">
            <summary>Notify any parse listeners of an exit rule event.</summary>
            <remarks>Notify any parse listeners of an exit rule event.</remarks>
            <seealso cref="M:Antlr4.Runtime.Parser.AddParseListener(Antlr4.Runtime.Tree.IParseTreeListener)"/>
        </member>
        <member name="P:Antlr4.Runtime.Parser.NumberOfSyntaxErrors">
            <summary>Gets the number of syntax errors reported during parsing.</summary>
            <remarks>
            Gets the number of syntax errors reported during parsing. This value is
            incremented each time
            <see cref="M:Antlr4.Runtime.Parser.NotifyErrorListeners(System.String)"/>
            is called.
            </remarks>
            <seealso cref="M:Antlr4.Runtime.Parser.NotifyErrorListeners(System.String)"/>
        </member>
        <member name="M:Antlr4.Runtime.Parser.GetATNWithBypassAlts">
            <summary>
            The ATN with bypass alternatives is expensive to create so we create it
            lazily.
            </summary>
            <remarks>
            The ATN with bypass alternatives is expensive to create so we create it
            lazily.
            </remarks>
            <exception cref="T:System.NotSupportedException">
            if the current parser does not
            implement the
            <see cref="P:Antlr4.Runtime.Recognizer`2.SerializedAtn"/>
            method.
            </exception>
        </member>
        <member name="M:Antlr4.Runtime.Parser.CompileParseTreePattern(System.String,System.Int32)">
            <summary>The preferred method of getting a tree pattern.</summary>
            <remarks>
            The preferred method of getting a tree pattern. For example, here's a
            sample use:
            <pre>
            ParseTree t = parser.expr();
            ParseTreePattern p = parser.compileParseTreePattern("&lt;ID&gt;+0", MyParser.RULE_expr);
            ParseTreeMatch m = p.match(t);
            String id = m.get("ID");
            </pre>
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Parser.CompileParseTreePattern(System.String,System.Int32,Antlr4.Runtime.Lexer)">
            <summary>
            The same as
            <see cref="M:Antlr4.Runtime.Parser.CompileParseTreePattern(System.String,System.Int32)"/>
            but specify a
            <see cref="T:Antlr4.Runtime.Lexer"/>
            rather than trying to deduce it from this parser.
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Parser.CurrentToken">
            <summary>
            Match needs to return the current input symbol, which gets put
            into the label for the associated token ref; e.g., x=ID.
            </summary>
            <remarks>
            Match needs to return the current input symbol, which gets put
            into the label for the associated token ref; e.g., x=ID.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Parser.Consume">
            <summary>
            Consume and return the
            <linkplain>
            #getCurrentToken
            current symbol
            </linkplain>
            .
            <p>E.g., given the following input with
            <c>A</c>
            being the current
            lookahead symbol, this function moves the cursor to
            <c>B</c>
            and returns
            <c>A</c>
            .</p>
            <pre>
            A B
            ^
            </pre>
            If the parser is not in error recovery mode, the consumed symbol is added
            to the parse tree using
            <see cref="M:Antlr4.Runtime.ParserRuleContext.AddChild(Antlr4.Runtime.IToken)"/>
            , and
            <see cref="M:Antlr4.Runtime.Tree.IParseTreeListener.VisitTerminal(Antlr4.Runtime.Tree.ITerminalNode)"/>
            is called on any parse listeners.
            If the parser <em>is</em> in error recovery mode, the consumed symbol is
            added to the parse tree using
            <see cref="M:Antlr4.Runtime.ParserRuleContext.AddErrorNode(Antlr4.Runtime.IToken)"/>
            , and
            <see cref="M:Antlr4.Runtime.Tree.IParseTreeListener.VisitErrorNode(Antlr4.Runtime.Tree.IErrorNode)"/>
            is called on any parse
            listeners.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Parser.EnterRule(Antlr4.Runtime.ParserRuleContext,System.Int32,System.Int32)">
            <summary>Always called by generated parsers upon entry to a rule.</summary>
            <remarks>
            Always called by generated parsers upon entry to a rule. Access field
            <see cref="F:Antlr4.Runtime.Parser._ctx"/>
            get the current context.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Parser.Precedence">
            <summary>Get the precedence level for the top-most precedence rule.</summary>
            <remarks>Get the precedence level for the top-most precedence rule.</remarks>
            <returns>
            The precedence level for the top-most precedence rule, or -1 if
            the parser context is not nested within a precedence rule.
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Parser.PushNewRecursionContext(Antlr4.Runtime.ParserRuleContext,System.Int32,System.Int32)">
            <summary>
            Like
            <see cref="M:Antlr4.Runtime.Parser.EnterRule(Antlr4.Runtime.ParserRuleContext,System.Int32,System.Int32)"/>
            but for recursive rules.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Parser.IsExpectedToken(System.Int32)">
             <summary>
             Checks whether or not
             <paramref name="symbol"/>
             can follow the current state in the
             ATN. The behavior of this method is equivalent to the following, but is
             implemented such that the complete context-sensitive follow set does not
             need to be explicitly constructed.
             <pre>
             return getExpectedTokens().contains(symbol);
             </pre>
             </summary>
             <param name="symbol">the symbol type to check</param>
             <returns>
            
             <see langword="true"/>
             if
             <paramref name="symbol"/>
             can follow the current state in
             the ATN, otherwise
             <see langword="false"/>
             .
             </returns>
        </member>
        <member name="M:Antlr4.Runtime.Parser.GetExpectedTokens">
            <summary>
            Computes the set of input symbols which could follow the current parser
            state and context, as given by
            <see cref="P:Antlr4.Runtime.Recognizer`2.State"/>
            and
            <see cref="P:Antlr4.Runtime.Parser.Context"/>
            ,
            respectively.
            </summary>
            <seealso cref="M:Antlr4.Runtime.Atn.ATN.GetExpectedTokens(System.Int32,Antlr4.Runtime.RuleContext)"/>
        </member>
        <member name="M:Antlr4.Runtime.Parser.GetRuleIndex(System.String)">
            <summary>
            Get a rule's index (i.e.,
            <c>RULE_ruleName</c>
            field) or -1 if not found.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Parser.GetRuleInvocationStack">
            <summary>
            Return List&lt;String&gt; of the rule names in your parser instance
            leading up to a call to the current rule.
            </summary>
            <remarks>
            Return List&lt;String&gt; of the rule names in your parser instance
            leading up to a call to the current rule.  You could override if
            you want more details such as the file/line info of where
            in the ATN a rule is invoked.
            This is very useful for error messages.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Parser.GetDFAStrings">
            <summary>For debugging and other purposes.</summary>
            <remarks>For debugging and other purposes.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.Parser.DumpDFA">
            <summary>For debugging and other purposes.</summary>
            <remarks>For debugging and other purposes.</remarks>
        </member>
        <member name="P:Antlr4.Runtime.Parser.Profile">
            <since>4.3</since>
        </member>
        <member name="P:Antlr4.Runtime.Parser.Trace">
            <summary>
            During a parse is sometimes useful to listen in on the rule entry and exit
            events as well as token matches.
            </summary>
            <remarks>
            During a parse is sometimes useful to listen in on the rule entry and exit
            events as well as token matches. This is for quick and dirty debugging.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.ParserInterpreter">
            <summary>
            A parser simulator that mimics what ANTLR's generated
            parser code does.
            </summary>
            <remarks>
            A parser simulator that mimics what ANTLR's generated
            parser code does. A ParserATNSimulator is used to make
            predictions via adaptivePredict but this class moves a pointer through the
            ATN to simulate parsing. ParserATNSimulator just
            makes us efficient rather than having to backtrack, for example.
            This properly creates parse trees even for left recursive rules.
            We rely on the left recursive rule invocation and special predicate
            transitions to make left recursive rules work.
            See TestParserInterpreter for examples.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.ParserInterpreter.Parse(System.Int32)">
            <summary>Begin parsing at startRuleIndex</summary>
        </member>
        <member name="T:Antlr4.Runtime.ParserRuleContext">
            <summary>A rule invocation record for parsing.</summary>
            <remarks>
            A rule invocation record for parsing.
            Contains all of the information about the current rule not stored in the
            RuleContext. It handles parse tree children list, Any ATN state
            tracing, and the default values available for rule indications:
            start, stop, rule index, current alt number, current
            ATN state.
            Subclasses made for each rule and grammar track the parameters,
            return values, locals, and labels specific to that rule. These
            are the objects that are returned from rules.
            Note text is not an actual field of a rule return value; it is computed
            from start and stop using the input stream's toString() method.  I
            could add a ctor to this so that we can pass in and store the input
            stream, but I'm not sure we want to do that.  It would seem to be undefined
            to get the .text property anyway if the rule matches tokens from multiple
            input streams.
            I do not use getters for fields of objects that are used simply to
            group values such as this aggregate.  The getters/setters are there to
            satisfy the superclass interface.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.ParserRuleContext.children">
            <summary>
            If we are debugging or building a parse tree for a visitor,
            we need to track all of the tokens and rule invocations associated
            with this rule's context.
            </summary>
            <remarks>
            If we are debugging or building a parse tree for a visitor,
            we need to track all of the tokens and rule invocations associated
            with this rule's context. This is empty for parsing w/o tree constr.
            operation because we don't the need to track the details about
            how we parse this rule.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.ParserRuleContext._start">
            <summary>
            For debugging/tracing purposes, we want to track all of the nodes in
            the ATN traversed by the parser for a particular rule.
            </summary>
            <remarks>
            For debugging/tracing purposes, we want to track all of the nodes in
            the ATN traversed by the parser for a particular rule.
            This list indicates the sequence of ATN nodes used to match
            the elements of the children list. This list does not include
            ATN nodes and other rules used to match rule invocations. It
            traces the rule invocation node itself but nothing inside that
            other rule's ATN submachine.
            There is NOT a one-to-one correspondence between the children and
            states list. There are typically many nodes in the ATN traversed
            for each element in the children list. For example, for a rule
            invocation there is the invoking state and the following state.
            The parser setState() method updates field s and adds it to this list
            if we are debugging/tracing.
            This does not trace states visited during prediction.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.ParserRuleContext._stop">
            <summary>
            For debugging/tracing purposes, we want to track all of the nodes in
            the ATN traversed by the parser for a particular rule.
            </summary>
            <remarks>
            For debugging/tracing purposes, we want to track all of the nodes in
            the ATN traversed by the parser for a particular rule.
            This list indicates the sequence of ATN nodes used to match
            the elements of the children list. This list does not include
            ATN nodes and other rules used to match rule invocations. It
            traces the rule invocation node itself but nothing inside that
            other rule's ATN submachine.
            There is NOT a one-to-one correspondence between the children and
            states list. There are typically many nodes in the ATN traversed
            for each element in the children list. For example, for a rule
            invocation there is the invoking state and the following state.
            The parser setState() method updates field s and adds it to this list
            if we are debugging/tracing.
            This does not trace states visited during prediction.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.ParserRuleContext.exception">
            <summary>The exception that forced this rule to return.</summary>
            <remarks>
            The exception that forced this rule to return. If the rule successfully
            completed, this is
            <see langword="null"/>
            .
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.ParserRuleContext.CopyFrom(Antlr4.Runtime.ParserRuleContext)">
             <summary>
             COPY a ctx (I'm deliberately not using copy constructor) to avoid
             confusion with creating node with parent. Does not copy children.
            
             This is used in the generated parser code to flip a generic XContext
             node for rule X to a YContext for alt label Y. In that sense, it is
             not really a generic copy function.
            
             If we do an error sync() at start of a rule, we might add error nodes
             to the generic XContext so this function must copy those nodes to
             the YContext as well else they are lost!
             </summary>
        </member>
        <member name="M:Antlr4.Runtime.ParserRuleContext.AddChild(Antlr4.Runtime.Tree.ITerminalNode)">
            <summary>Does not set parent link; other add methods do that</summary>
        </member>
        <member name="M:Antlr4.Runtime.ParserRuleContext.RemoveLastChild">
            <summary>
            Used by enterOuterAlt to toss out a RuleContext previously added as
            we entered a rule.
            </summary>
            <remarks>
            Used by enterOuterAlt to toss out a RuleContext previously added as
            we entered a rule. If we have # label, we will need to remove
            generic ruleContext object.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.ParserRuleContext.ToInfoString(Antlr4.Runtime.Parser)">
            <summary>Used for rule context info debugging during parse-time, not so much for ATN debugging</summary>
        </member>
        <member name="T:Antlr4.Runtime.ProxyErrorListener`1">
            <summary>
            This implementation of
            <see cref="T:Antlr4.Runtime.IAntlrErrorListener`1"/>
            dispatches all calls to a
            collection of delegate listeners. This reduces the effort required to support multiple
            listeners.
            </summary>
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.ProxyParserErrorListener">
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.RecognitionException">
            <summary>The root of the ANTLR exception hierarchy.</summary>
            <remarks>
            The root of the ANTLR exception hierarchy. In general, ANTLR tracks just
            3 kinds of errors: prediction errors, failed predicate errors, and
            mismatched input errors. In each case, the parser knows where it is
            in the input, where it is in the ATN, the rule invocation stack,
            and what kind of problem occurred.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.RecognitionException.recognizer">
            <summary>
            The
            <see cref="T:Antlr4.Runtime.IRecognizer"/>
            where this exception originated.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.RecognitionException.offendingToken">
            <summary>
            The current
            <see cref="T:Antlr4.Runtime.IToken"/>
            when an error occurred. Since not all streams
            support accessing symbols by index, we have to track the
            <see cref="T:Antlr4.Runtime.IToken"/>
            instance itself.
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.RecognitionException.OffendingState">
            <summary>
            Get the ATN state number the parser was in at the time the error
            occurred.
            </summary>
            <remarks>
            Get the ATN state number the parser was in at the time the error
            occurred. For
            <see cref="T:Antlr4.Runtime.NoViableAltException"/>
            and
            <see cref="T:Antlr4.Runtime.LexerNoViableAltException"/>
            exceptions, this is the
            <see cref="T:Antlr4.Runtime.Atn.DecisionState"/>
            number. For others, it is the state whose outgoing
            edge we couldn't match.
            <p>If the state number is not known, this method returns -1.</p>
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.RecognitionException.GetExpectedTokens">
            <summary>
            Gets the set of input symbols which could potentially follow the
            previously matched symbol at the time this exception was thrown.
            </summary>
            <remarks>
            Gets the set of input symbols which could potentially follow the
            previously matched symbol at the time this exception was thrown.
            <p>If the set of expected tokens is not known and could not be computed,
            this method returns
            <see langword="null"/>
            .</p>
            </remarks>
            <returns>
            The set of token types that could potentially follow the current
            state in the ATN, or
            <see langword="null"/>
            if the information is not available.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.RecognitionException.Context">
            <summary>
            Gets the
            <see cref="T:Antlr4.Runtime.RuleContext"/>
            at the time this exception was thrown.
            <p>If the context is not available, this method returns
            <see langword="null"/>
            .</p>
            </summary>
            <returns>
            The
            <see cref="T:Antlr4.Runtime.RuleContext"/>
            at the time this exception was thrown.
            If the context is not available, this method returns
            <see langword="null"/>
            .
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.RecognitionException.InputStream">
            <summary>
            Gets the input stream which is the symbol source for the recognizer where
            this exception was thrown.
            </summary>
            <remarks>
            Gets the input stream which is the symbol source for the recognizer where
            this exception was thrown.
            <p>If the input stream is not available, this method returns
            <see langword="null"/>
            .</p>
            </remarks>
            <returns>
            The input stream which is the symbol source for the recognizer
            where this exception was thrown, or
            <see langword="null"/>
            if the stream is not
            available.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.RecognitionException.Recognizer">
            <summary>
            Gets the
            <see cref="T:Antlr4.Runtime.IRecognizer"/>
            where this exception occurred.
            <p>If the recognizer is not available, this method returns
            <see langword="null"/>
            .</p>
            </summary>
            <returns>
            The recognizer where this exception occurred, or
            <see langword="null"/>
            if
            the recognizer is not available.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Recognizer`2.RuleNames">
            <summary>
            Used to print out token names like ID during debugging and
            error reporting.
            </summary>
            <remarks>
            Used to print out token names like ID during debugging and
            error reporting.  The generated parsers implement a method
            that overrides this to point to their String[] tokenNames.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Recognizer`2.Vocabulary">
            <summary>Get the vocabulary used by the recognizer.</summary>
            <remarks>Get the vocabulary used by the recognizer.</remarks>
            <returns>
            A
            <see cref="T:Antlr4.Runtime.IVocabulary"/>
            instance providing information about the
            vocabulary used by the grammar.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Recognizer`2.TokenTypeMap">
            <summary>Get a map from token names to token types.</summary>
            <remarks>
            Get a map from token names to token types.
            <p>Used for XPath and tree pattern compilation.</p>
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Recognizer`2.RuleIndexMap">
            <summary>Get a map from rule names to rule indexes.</summary>
            <remarks>
            Get a map from rule names to rule indexes.
            <p>Used for XPath and tree pattern compilation.</p>
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Recognizer`2.SerializedAtn">
            <summary>
            If this recognizer was generated, it will have a serialized ATN
            representation of the grammar.
            </summary>
            <remarks>
            If this recognizer was generated, it will have a serialized ATN
            representation of the grammar.
            <p>For interpreters, we don't know their serialized ATN despite having
            created the interpreter from it.</p>
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Recognizer`2.GrammarFileName">
            <summary>For debugging and other purposes, might want the grammar name.</summary>
            <remarks>
            For debugging and other purposes, might want the grammar name.
            Have ANTLR generate an implementation for this method.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Recognizer`2.Atn">
            <summary>
            Get the
            <see cref="T:Antlr4.Runtime.Atn.ATN"/>
            used by the recognizer for prediction.
            </summary>
            <returns>
            The
            <see cref="T:Antlr4.Runtime.Atn.ATN"/>
            used by the recognizer for prediction.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Recognizer`2.Interpreter">
            <summary>Get the ATN interpreter used by the recognizer for prediction.</summary>
            <remarks>Get the ATN interpreter used by the recognizer for prediction.</remarks>
            <returns>The ATN interpreter used by the recognizer for prediction.</returns>
            <summary>Set the ATN interpreter used by the recognizer for prediction.</summary>
            <remarks>Set the ATN interpreter used by the recognizer for prediction.</remarks>
            <value>
            The ATN interpreter used by the recognizer for
            prediction.
            </value>
        </member>
        <member name="P:Antlr4.Runtime.Recognizer`2.ParseInfo">
            <summary>
            If profiling during the parse/lex, this will return DecisionInfo records
            for each decision in recognizer in a ParseInfo object.
            </summary>
            <remarks>
            If profiling during the parse/lex, this will return DecisionInfo records
            for each decision in recognizer in a ParseInfo object.
            </remarks>
            <since>4.3</since>
        </member>
        <member name="M:Antlr4.Runtime.Recognizer`2.GetErrorHeader(Antlr4.Runtime.RecognitionException)">
            <summary>What is the error header, normally line/character position information?</summary>
        </member>
        <member name="M:Antlr4.Runtime.Recognizer`2.GetTokenErrorDisplay(Antlr4.Runtime.IToken)">
            <summary>
            How should a token be displayed in an error message? The default
            is to display just the text, but during development you might
            want to have a lot of information spit out.
            </summary>
            <remarks>
            How should a token be displayed in an error message? The default
            is to display just the text, but during development you might
            want to have a lot of information spit out.  Override in that case
            to use t.toString() (which, for CommonToken, dumps everything about
            the token). This is better than forcing you to override a method in
            your token objects because you don't have to go modify your lexer
            so that it creates a new Java type.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Recognizer`2.AddErrorListener(Antlr4.Runtime.IAntlrErrorListener{`0})">
            <exception>
            NullPointerException
            if
            <paramref name="listener"/>
            is
            <see langword="null"/>
            .
            </exception>
        </member>
        <member name="P:Antlr4.Runtime.Recognizer`2.State">
            <summary>
            Indicate that the recognizer has changed internal state that is
            consistent with the ATN state passed in.
            </summary>
            <remarks>
            Indicate that the recognizer has changed internal state that is
            consistent with the ATN state passed in.  This way we always know
            where we are in the ATN as the parser goes along. The rule
            context objects form a stack that lets us see the stack of
            invoking rules. Combine this and we have complete ATN
            configuration information.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.RuleContext">
            <summary>A rule context is a record of a single rule invocation.</summary>
            <remarks>
            A rule context is a record of a single rule invocation. It knows
            which context invoked it, if any. If there is no parent context, then
            naturally the invoking state is not valid.  The parent link
            provides a chain upwards from the current rule invocation to the root
            of the invocation tree, forming a stack. We actually carry no
            information about the rule associated with this context (except
            when parsing). We keep only the state number of the invoking state from
            the ATN submachine that invoked this. Contrast this with the s
            pointer inside ParserRuleContext that tracks the current state
            being "executed" for the current rule.
            The parent contexts are useful for computing lookahead sets and
            getting error information.
            These objects are used during parsing and prediction.
            For the special case of parsers, we use the subclass
            ParserRuleContext.
            </remarks>
            <seealso cref="T:Antlr4.Runtime.ParserRuleContext"/>
        </member>
        <member name="F:Antlr4.Runtime.RuleContext._parent">
            <summary>What context invoked this rule?</summary>
        </member>
        <member name="F:Antlr4.Runtime.RuleContext.invokingState">
            <summary>
            What state invoked the rule associated with this context?
            The "return address" is the followState of invokingState
            If parent is null, this should be -1.
            </summary>
            <remarks>
            What state invoked the rule associated with this context?
            The "return address" is the followState of invokingState
            If parent is null, this should be -1.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.RuleContext.IsEmpty">
            <summary>
            A context is empty if there is no invoking state; meaning nobody call
            current context.
            </summary>
            <remarks>
            A context is empty if there is no invoking state; meaning nobody call
            current context.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.RuleContext.GetText">
            <summary>Return the combined text of all child nodes.</summary>
            <remarks>
            Return the combined text of all child nodes. This method only considers
            tokens which have been added to the parse tree.
            <p/>
            Since tokens on hidden channels (e.g. whitespace or comments) are not
            added to the parse trees, they will not appear in the output of this
            method.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.RuleContext.ToStringTree(Antlr4.Runtime.Parser)">
            <summary>
            Print out a whole tree, not just a node, in LISP format
            (root child1 ..
            </summary>
            <remarks>
            Print out a whole tree, not just a node, in LISP format
            (root child1 .. childN). Print just a node if this is a leaf.
            We have to know the recognizer so we can get rule names.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.RuleContext.ToStringTree(System.Collections.Generic.IList{System.String})">
            <summary>
            Print out a whole tree, not just a node, in LISP format
            (root child1 ..
            </summary>
            <remarks>
            Print out a whole tree, not just a node, in LISP format
            (root child1 .. childN). Print just a node if this is a leaf.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.TokenStreamRewriter">
            <summary>
            Useful for rewriting out a buffered input token stream after doing some
            augmentation or other manipulations on it.
            </summary>
            <remarks>
            Useful for rewriting out a buffered input token stream after doing some
            augmentation or other manipulations on it.
            <p>
            You can insert stuff, replace, and delete chunks. Note that the operations
            are done lazily--only if you convert the buffer to a
            <see cref="T:System.String"/>
            with
            <see cref="M:Antlr4.Runtime.ITokenStream.GetText"/>
            . This is very efficient because you are not
            moving data around all the time. As the buffer of tokens is converted to
            strings, the
            <see cref="M:Antlr4.Runtime.TokenStreamRewriter.GetText"/>
            method(s) scan the input token stream and
            check to see if there is an operation at the current index. If so, the
            operation is done and then normal
            <see cref="T:System.String"/>
            rendering continues on the
            buffer. This is like having multiple Turing machine instruction streams
            (programs) operating on a single input tape. :)</p>
            <p>
            This rewriter makes no modifications to the token stream. It does not ask the
            stream to fill itself up nor does it advance the input cursor. The token
            stream
            <see cref="P:Antlr4.Runtime.IIntStream.Index"/>
            will return the same value before and
            after any
            <see cref="M:Antlr4.Runtime.TokenStreamRewriter.GetText"/>
            call.</p>
            <p>
            The rewriter only works on tokens that you have in the buffer and ignores the
            current input cursor. If you are buffering tokens on-demand, calling
            <see cref="M:Antlr4.Runtime.TokenStreamRewriter.GetText"/>
            halfway through the input will only do rewrites for those
            tokens in the first half of the file.</p>
            <p>
            Since the operations are done lazily at
            <see cref="M:Antlr4.Runtime.TokenStreamRewriter.GetText"/>
            -time, operations do
            not screw up the token index values. That is, an insert operation at token
            index
            <c>i</c>
            does not change the index values for tokens
            <c>i</c>
            +1..n-1.</p>
            <p>
            Because operations never actually alter the buffer, you may always get the
            original token stream back without undoing anything. Since the instructions
            are queued up, you can easily simulate transactions and roll back any changes
            if there is an error just by removing instructions. For example,</p>
            <pre>
            CharStream input = new ANTLRFileStream("input");
            TLexer lex = new TLexer(input);
            CommonTokenStream tokens = new CommonTokenStream(lex);
            T parser = new T(tokens);
            TokenStreamRewriter rewriter = new TokenStreamRewriter(tokens);
            parser.startRule();
            </pre>
            <p>
            Then in the rules, you can execute (assuming rewriter is visible):</p>
            <pre>
            Token t,u;
            ...
            rewriter.insertAfter(t, "text to put after t");}
            rewriter.insertAfter(u, "text after u");}
            System.out.println(tokens.toString());
            </pre>
            <p>
            You can also have multiple "instruction streams" and get multiple rewrites
            from a single pass over the input. Just name the instruction streams and use
            that name again when printing the buffer. This could be useful for generating
            a C file and also its header file--all from the same buffer:</p>
            <pre>
            tokens.insertAfter("pass1", t, "text to put after t");}
            tokens.insertAfter("pass2", u, "text after u");}
            System.out.println(tokens.toString("pass1"));
            System.out.println(tokens.toString("pass2"));
            </pre>
            <p>
            If you don't use named rewrite streams, a "default" stream is used as the
            first example shows.</p>
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.TokenStreamRewriter.RewriteOperation.instructionIndex">
            <summary>What index into rewrites List are we?</summary>
        </member>
        <member name="F:Antlr4.Runtime.TokenStreamRewriter.RewriteOperation.index">
            <summary>Token buffer index.</summary>
            <remarks>Token buffer index.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.TokenStreamRewriter.RewriteOperation.Execute(System.Text.StringBuilder)">
            <summary>Execute the rewrite operation by possibly adding to the buffer.</summary>
            <remarks>
            Execute the rewrite operation by possibly adding to the buffer.
            Return the index of the next token to operate on.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.TokenStreamRewriter.ReplaceOp">
            <summary>
            I'm going to try replacing range from x..y with (y-x)+1 ReplaceOp
            instructions.
            </summary>
            <remarks>
            I'm going to try replacing range from x..y with (y-x)+1 ReplaceOp
            instructions.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.TokenStreamRewriter.tokens">
            <summary>Our source stream</summary>
        </member>
        <member name="F:Antlr4.Runtime.TokenStreamRewriter.programs">
            <summary>You may have multiple, named streams of rewrite operations.</summary>
            <remarks>
            You may have multiple, named streams of rewrite operations.
            I'm calling these things "programs."
            Maps String (name) &#x2192; rewrite (List)
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.TokenStreamRewriter.lastRewriteTokenIndexes">
            <summary>Map String (program name) &#x2192; Integer index</summary>
        </member>
        <member name="M:Antlr4.Runtime.TokenStreamRewriter.Rollback(System.String,System.Int32)">
            <summary>
            Rollback the instruction stream for a program so that
            the indicated instruction (via instructionIndex) is no
            longer in the stream.
            </summary>
            <remarks>
            Rollback the instruction stream for a program so that
            the indicated instruction (via instructionIndex) is no
            longer in the stream. UNTESTED!
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.TokenStreamRewriter.DeleteProgram(System.String)">
            <summary>Reset the program so that no instructions exist</summary>
        </member>
        <member name="M:Antlr4.Runtime.TokenStreamRewriter.GetText">
            <summary>
            Return the text from the original tokens altered per the
            instructions given to this rewriter.
            </summary>
            <remarks>
            Return the text from the original tokens altered per the
            instructions given to this rewriter.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.TokenStreamRewriter.GetText(Antlr4.Runtime.Misc.Interval)">
            <summary>
            Return the text associated with the tokens in the interval from the
            original token stream but with the alterations given to this rewriter.
            </summary>
            <remarks>
            Return the text associated with the tokens in the interval from the
            original token stream but with the alterations given to this rewriter.
            The interval refers to the indexes in the original token stream.
            We do not alter the token stream in any way, so the indexes
            and intervals are still consistent. Includes any operations done
            to the first and last token in the interval. So, if you did an
            insertBefore on the first token, you would get that insertion.
            The same is true if you do an insertAfter the stop token.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.TokenStreamRewriter.ReduceToSingleOperationPerIndex(System.Collections.Generic.IList{Antlr4.Runtime.TokenStreamRewriter.RewriteOperation})">
            <summary>
            We need to combine operations and report invalid operations (like
            overlapping replaces that are not completed nested).
            </summary>
            <remarks>
            We need to combine operations and report invalid operations (like
            overlapping replaces that are not completed nested). Inserts to
            same index need to be combined etc...  Here are the cases:
            I.i.u I.j.v								leave alone, nonoverlapping
            I.i.u I.i.v								combine: Iivu
            R.i-j.u R.x-y.v	| i-j in x-y			delete first R
            R.i-j.u R.i-j.v							delete first R
            R.i-j.u R.x-y.v	| x-y in i-j			ERROR
            R.i-j.u R.x-y.v	| boundaries overlap	ERROR
            Delete special case of replace (text==null):
            D.i-j.u D.x-y.v	| boundaries overlap	combine to max(min)..max(right)
            I.i.u R.x-y.v | i in (x+1)-y			delete I (since insert before
            we're not deleting i)
            I.i.u R.x-y.v | i not in (x+1)-y		leave alone, nonoverlapping
            R.x-y.v I.i.u | i in x-y				ERROR
            R.x-y.v I.x.u 							R.x-y.uv (combine, delete I)
            R.x-y.v I.i.u | i not in x-y			leave alone, nonoverlapping
            I.i.u = insert u before op @ index i
            R.x-y.u = replace x-y indexed tokens with u
            First we need to examine replaces. For any replace op:
            1. wipe out any insertions before op within that range.
            2. Drop any replace op before that is contained completely within
            that range.
            3. Throw exception upon boundary overlap with any previous replace.
            Then we can deal with inserts:
            1. for any inserts to same index, combine even if not adjacent.
            2. for any prior replace with same left boundary, combine this
            insert with replace and delete this replace.
            3. throw exception if index in same range as previous replace
            Don't actually delete; make op null in list. Easier to walk list.
            Later we can throw as we add to index &#x2192; op map.
            Note that I.2 R.2-2 will wipe out I.2 even though, technically, the
            inserted stuff would be before the replace range. But, if you
            add tokens in front of a method body '{' and then delete the method
            body, I think the stuff before the '{' you added should disappear too.
            Return a map from token index to operation.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.TokenStreamRewriter.GetKindOfOps``1(System.Collections.Generic.IList{Antlr4.Runtime.TokenStreamRewriter.RewriteOperation},System.Int32)">
            <summary>Get all operations before an index of a particular kind</summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.Visit(Antlr4.Runtime.Tree.IParseTree)">
            <summary>
            <inheritDoc/>
            <p>The default implementation calls
            <see cref="M:Antlr4.Runtime.Tree.IParseTree.Accept``1(Antlr4.Runtime.Tree.IParseTreeVisitor{``0})"/>
            on the
            specified tree.</p>
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)">
            <summary>
            <inheritDoc/>
            <p>The default implementation initializes the aggregate result to
            <see cref="P:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.DefaultResult">defaultResult()</see>
            . Before visiting each child, it
            calls
            <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.ShouldVisitNextChild(Antlr4.Runtime.Tree.IRuleNode,`0)">shouldVisitNextChild</see>
            ; if the result
            is
            <see langword="false"/>
            no more children are visited and the current aggregate
            result is returned. After visiting a child, the aggregate result is
            updated by calling
            <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.AggregateResult(`0,`0)">aggregateResult</see>
            with the
            previous aggregate result and the result of visiting the child.</p>
            <p>The default implementation is not safe for use in visitors that modify
            the tree structure. Visitors that modify the tree should override this
            method to behave properly in respect to the specific algorithm in use.</p>
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitTerminal(Antlr4.Runtime.Tree.ITerminalNode)">
            <summary>
            <inheritDoc/>
            <p>The default implementation returns the result of
            <see cref="P:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.DefaultResult">defaultResult</see>
            .</p>
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitErrorNode(Antlr4.Runtime.Tree.IErrorNode)">
            <summary>
            <inheritDoc/>
            <p>The default implementation returns the result of
            <see cref="P:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.DefaultResult">defaultResult</see>
            .</p>
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.DefaultResult">
            <summary>Gets the default value returned by visitor methods.</summary>
            <remarks>
            Gets the default value returned by visitor methods. This value is
            returned by the default implementations of
            <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitTerminal(Antlr4.Runtime.Tree.ITerminalNode)">visitTerminal</see>
            ,
            <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitErrorNode(Antlr4.Runtime.Tree.IErrorNode)">visitErrorNode</see>
            .
            The default implementation of
            <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)">visitChildren</see>
            initializes its aggregate result to this value.
            <p>The base implementation returns
            <see langword="null"/>
            .</p>
            </remarks>
            <returns>The default value returned by visitor methods.</returns>
        </member>
        <member name="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.AggregateResult(`0,`0)">
            <summary>Aggregates the results of visiting multiple children of a node.</summary>
            <remarks>
            Aggregates the results of visiting multiple children of a node. After
            either all children are visited or
            <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.ShouldVisitNextChild(Antlr4.Runtime.Tree.IRuleNode,`0)"/>
            returns
            <see langword="false"/>
            , the aggregate value is returned as the result of
            <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            .
            <p>The default implementation returns
            <paramref name="nextResult"/>
            , meaning
            <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            will return the result of the last child visited
            (or return the initial value if the node has no children).</p>
            </remarks>
            <param name="aggregate">
            The previous aggregate value. In the default
            implementation, the aggregate value is initialized to
            <see cref="P:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.DefaultResult"/>
            , which is passed as the
            <paramref name="aggregate"/>
            argument
            to this method after the first child node is visited.
            </param>
            <param name="nextResult">
            The result of the immediately preceeding call to visit
            a child node.
            </param>
            <returns>The updated aggregate result.</returns>
        </member>
        <member name="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.ShouldVisitNextChild(Antlr4.Runtime.Tree.IRuleNode,`0)">
             <summary>
             This method is called after visiting each child in
             <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
             . This method is first called before the first
             child is visited; at that point
             <paramref name="currentResult"/>
             will be the initial
             value (in the default implementation, the initial value is returned by a
             call to
             <see cref="P:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.DefaultResult"/>
             . This method is not called after the last
             child is visited.
             <p>The default implementation always returns
             <see langword="true"/>
             , indicating that
             <c>visitChildren</c>
             should only return after all children are visited.
             One reason to override this method is to provide a "short circuit"
             evaluation option for situations where the result of visiting a single
             child has the potential to determine the result of the visit operation as
             a whole.</p>
             </summary>
             <param name="node">
             The
             <see cref="T:Antlr4.Runtime.Tree.IRuleNode"/>
             whose children are currently being
             visited.
             </param>
             <param name="currentResult">
             The current aggregate result of the children visited
             to the current point.
             </param>
             <returns>
            
             <see langword="true"/>
             to continue visiting children. Otherwise return
             <see langword="false"/>
             to stop visiting children and immediately return the
             current aggregate result from
             <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
             .
             </returns>
        </member>
        <member name="T:Antlr4.Runtime.Tree.ErrorNodeImpl">
            <summary>
            Represents a token that was consumed during resynchronization
            rather than during a valid match operation.
            </summary>
            <remarks>
            Represents a token that was consumed during resynchronization
            rather than during a valid match operation. For example,
            we will create this kind of a node during single token insertion
            and deletion as well as during "consume until error recovery set"
            upon no viable alternative exceptions.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.Tree.IParseTree">
            <summary>
            An interface to access the tree of
            <see cref="T:Antlr4.Runtime.RuleContext"/>
            objects created
            during a parse that makes the data structure look like a simple parse tree.
            This node represents both internal nodes, rule invocations,
            and leaf nodes, token matches.
            <p>The payload is either a
            <see cref="T:Antlr4.Runtime.IToken"/>
            or a
            <see cref="T:Antlr4.Runtime.RuleContext"/>
            object.</p>
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.IParseTree.Accept``1(Antlr4.Runtime.Tree.IParseTreeVisitor{``0})">
            <summary>
            The
            <see cref="T:Antlr4.Runtime.Tree.IParseTreeVisitor`1"/>
            needs a double dispatch method.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.IParseTree.GetText">
            <summary>Return the combined text of all leaf nodes.</summary>
            <remarks>
            Return the combined text of all leaf nodes. Does not get any
            off-channel tokens (if any) so won't return whitespace and
            comments if they are sent to parser on hidden channel.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Tree.IParseTree.ToStringTree(Antlr4.Runtime.Parser)">
            <summary>
            Specialize toStringTree so that it can print out more information
            based upon the parser.
            </summary>
            <remarks>
            Specialize toStringTree so that it can print out more information
            based upon the parser.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.Tree.IParseTreeVisitor`1">
            <summary>This interface defines the basic notion of a parse tree visitor.</summary>
            <remarks>
            This interface defines the basic notion of a parse tree visitor. Generated
            visitors implement this interface and the
            <c>XVisitor</c>
            interface for
            grammar
            <c>X</c>
            .
            </remarks>
            <author>Sam Harwell</author>
        </member>
        <member name="M:Antlr4.Runtime.Tree.IParseTreeVisitor`1.Visit(Antlr4.Runtime.Tree.IParseTree)">
            <summary>Visit a parse tree, and return a user-defined result of the operation.</summary>
            <remarks>Visit a parse tree, and return a user-defined result of the operation.</remarks>
            <param name="tree">
            The
            <see cref="T:Antlr4.Runtime.Tree.IParseTree"/>
            to visit.
            </param>
            <returns>The result of visiting the parse tree.</returns>
        </member>
        <member name="M:Antlr4.Runtime.Tree.IParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)">
            <summary>
            Visit the children of a node, and return a user-defined result
            of the operation.
            </summary>
            <remarks>
            Visit the children of a node, and return a user-defined result
            of the operation.
            </remarks>
            <param name="node">
            The
            <see cref="T:Antlr4.Runtime.Tree.IRuleNode"/>
            whose children should be visited.
            </param>
            <returns>The result of visiting the children of the node.</returns>
        </member>
        <member name="M:Antlr4.Runtime.Tree.IParseTreeVisitor`1.VisitTerminal(Antlr4.Runtime.Tree.ITerminalNode)">
            <summary>Visit a terminal node, and return a user-defined result of the operation.</summary>
            <remarks>Visit a terminal node, and return a user-defined result of the operation.</remarks>
            <param name="node">
            The
            <see cref="T:Antlr4.Runtime.Tree.ITerminalNode"/>
            to visit.
            </param>
            <returns>The result of visiting the node.</returns>
        </member>
        <member name="M:Antlr4.Runtime.Tree.IParseTreeVisitor`1.VisitErrorNode(Antlr4.Runtime.Tree.IErrorNode)">
            <summary>Visit an error node, and return a user-defined result of the operation.</summary>
            <remarks>Visit an error node, and return a user-defined result of the operation.</remarks>
            <param name="node">
            The
            <see cref="T:Antlr4.Runtime.Tree.IErrorNode"/>
            to visit.
            </param>
            <returns>The result of visiting the node.</returns>
        </member>
        <member name="T:Antlr4.Runtime.Tree.ISyntaxTree">
            <summary>
            A tree that knows about an interval in a token stream
            is some kind of syntax tree.
            </summary>
            <remarks>
            A tree that knows about an interval in a token stream
            is some kind of syntax tree. Subinterfaces distinguish
            between parse trees and other kinds of syntax trees we might want to create.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Tree.ISyntaxTree.SourceInterval">
            <summary>
            Return an
            <see cref="T:Antlr4.Runtime.Misc.Interval"/>
            indicating the index in the
            <see cref="T:Antlr4.Runtime.ITokenStream"/>
            of the first and last token associated with this
            subtree. If this node is a leaf, then the interval represents a single
            token.
            <p>If source interval is unknown, this returns
            <see cref="F:Antlr4.Runtime.Misc.Interval.Invalid"/>
            .</p>
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Tree.ITree">
            <summary>The basic notion of a tree has a parent, a payload, and a list of children.</summary>
            <remarks>
            The basic notion of a tree has a parent, a payload, and a list of children.
            It is the most abstract interface for all the trees used by ANTLR.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Tree.ITree.Parent">
            <summary>The parent of this node.</summary>
            <remarks>
            The parent of this node. If the return value is null, then this
            node is the root of the tree.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Tree.ITree.Payload">
            <summary>This method returns whatever object represents the data at this note.</summary>
            <remarks>
            This method returns whatever object represents the data at this note. For
            example, for parse trees, the payload can be a
            <see cref="T:Antlr4.Runtime.IToken"/>
            representing
            a leaf node or a
            <see cref="T:Antlr4.Runtime.RuleContext"/>
            object representing a rule
            invocation. For abstract syntax trees (ASTs), this is a
            <see cref="T:Antlr4.Runtime.IToken"/>
            object.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Tree.ITree.GetChild(System.Int32)">
            <summary>
            If there are children, get the
            <paramref name="i"/>
            th value indexed from 0.
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Tree.ITree.ChildCount">
            <summary>
            How many children are there? If there is none, then this
            node represents a leaf node.
            </summary>
            <remarks>
            How many children are there? If there is none, then this
            node represents a leaf node.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Tree.ITree.ToStringTree">
            <summary>
            Print out a whole tree, not just a node, in LISP format
            <c>(root child1 .. childN)</c>
            . Print just a node if this is a leaf.
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Tree.ParseTreeProperty`1">
            <summary>Associate a property with a parse tree node.</summary>
            <remarks>
            Associate a property with a parse tree node. Useful with parse tree listeners
            that need to associate values with particular tree nodes, kind of like
            specifying a return value for the listener event method that visited a
            particular node. Example:
            <pre>
            ParseTreeProperty&lt;Integer&gt; values = new ParseTreeProperty&lt;Integer&gt;();
            values.put(tree, 36);
            int x = values.get(tree);
            values.removeFrom(tree);
            </pre>
            You would make one decl (values here) in the listener and use lots of times
            in your event methods.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Tree.ParseTreeWalker.EnterRule(Antlr4.Runtime.Tree.IParseTreeListener,Antlr4.Runtime.Tree.IRuleNode)">
            <summary>
            The discovery of a rule node, involves sending two events: the generic
            <see cref="M:Antlr4.Runtime.Tree.IParseTreeListener.EnterEveryRule(Antlr4.Runtime.ParserRuleContext)"/>
            and a
            <see cref="T:Antlr4.Runtime.RuleContext"/>
            -specific event. First we trigger the generic and then
            the rule specific. We to them in reverse order upon finishing the node.
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Tree.Pattern.Chunk">
            <summary>
            A chunk is either a token tag, a rule tag, or a span of literal text within a
            tree pattern.
            </summary>
            <remarks>
            A chunk is either a token tag, a rule tag, or a span of literal text within a
            tree pattern.
            <p>The method
            <see cref="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Split(System.String)"/>
            returns a list of
            chunks in preparation for creating a token stream by
            <see cref="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Tokenize(System.String)"/>
            . From there, we get a parse
            tree from with
            <see cref="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Compile(System.String,System.Int32)"/>
            . These
            chunks are converted to
            <see cref="T:Antlr4.Runtime.Tree.Pattern.RuleTagToken"/>
            ,
            <see cref="T:Antlr4.Runtime.Tree.Pattern.TokenTagToken"/>
            , or the
            regular tokens of the text surrounding the tags.</p>
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch">
            <summary>
            Represents the result of matching a
            <see cref="T:Antlr4.Runtime.Tree.IParseTree"/>
            against a tree pattern.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.tree">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.Tree"/>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.pattern">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.Pattern"/>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.labels">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.Labels"/>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.mismatchedNode">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.MismatchedNode"/>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.#ctor(Antlr4.Runtime.Tree.IParseTree,Antlr4.Runtime.Tree.Pattern.ParseTreePattern,Antlr4.Runtime.Misc.MultiMap{System.String,Antlr4.Runtime.Tree.IParseTree},Antlr4.Runtime.Tree.IParseTree)">
            <summary>
            Constructs a new instance of
            <see cref="T:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch"/>
            from the specified
            parse tree and pattern.
            </summary>
            <param name="tree">The parse tree to match against the pattern.</param>
            <param name="pattern">The parse tree pattern.</param>
            <param name="labels">
            A mapping from label names to collections of
            <see cref="T:Antlr4.Runtime.Tree.IParseTree"/>
            objects located by the tree pattern matching process.
            </param>
            <param name="mismatchedNode">
            The first node which failed to match the tree
            pattern during the matching process.
            </param>
            <exception>
            IllegalArgumentException
            if
            <paramref name="tree"/>
            is
            <see langword="null"/>
            </exception>
            <exception>
            IllegalArgumentException
            if
            <paramref name="pattern"/>
            is
            <see langword="null"/>
            </exception>
            <exception>
            IllegalArgumentException
            if
            <paramref name="labels"/>
            is
            <see langword="null"/>
            </exception>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.Get(System.String)">
            <summary>
            Get the last node associated with a specific
            <paramref name="label"/>
            .
            <p>For example, for pattern
            <c>&lt;id:ID&gt;</c>
            ,
            <c>get("id")</c>
            returns the
            node matched for that
            <c>ID</c>
            . If more than one node
            matched the specified label, only the last is returned. If there is
            no node associated with the label, this returns
            <see langword="null"/>
            .</p>
            <p>Pattern tags like
            <c>&lt;ID&gt;</c>
            and
            <c>&lt;expr&gt;</c>
            without labels are
            considered to be labeled with
            <c>ID</c>
            and
            <c>expr</c>
            , respectively.</p>
            </summary>
            <param name="label">The label to check.</param>
            <returns>
            The last
            <see cref="T:Antlr4.Runtime.Tree.IParseTree"/>
            to match a tag with the specified
            label, or
            <see langword="null"/>
            if no parse tree matched a tag with the label.
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.GetAll(System.String)">
            <summary>Return all nodes matching a rule or token tag with the specified label.</summary>
            <remarks>
            Return all nodes matching a rule or token tag with the specified label.
            <p>If the
            <paramref name="label"/>
            is the name of a parser rule or token in the
            grammar, the resulting list will contain both the parse trees matching
            rule or tags explicitly labeled with the label and the complete set of
            parse trees matching the labeled and unlabeled tags in the pattern for
            the parser rule or token. For example, if
            <paramref name="label"/>
            is
            <c>"foo"</c>
            ,
            the result will contain <em>all</em> of the following.</p>
            <ul>
            <li>Parse tree nodes matching tags of the form
            <c>&lt;foo:anyRuleName&gt;</c>
            and
            <c>&lt;foo:AnyTokenName&gt;</c>
            .</li>
            <li>Parse tree nodes matching tags of the form
            <c>&lt;anyLabel:foo&gt;</c>
            .</li>
            <li>Parse tree nodes matching tags of the form
            <c>&lt;foo&gt;</c>
            .</li>
            </ul>
            </remarks>
            <param name="label">The label.</param>
            <returns>
            A collection of all
            <see cref="T:Antlr4.Runtime.Tree.IParseTree"/>
            nodes matching tags with
            the specified
            <paramref name="label"/>
            . If no nodes matched the label, an empty list
            is returned.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.Labels">
            <summary>Return a mapping from label &#x2192; [list of nodes].</summary>
            <remarks>
            Return a mapping from label &#x2192; [list of nodes].
            <p>The map includes special entries corresponding to the names of rules and
            tokens referenced in tags in the original pattern. For additional
            information, see the description of
            <see cref="M:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.GetAll(System.String)"/>
            .</p>
            </remarks>
            <returns>
            A mapping from labels to parse tree nodes. If the parse tree
            pattern did not contain any rule or token tags, this map will be empty.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.MismatchedNode">
            <summary>Get the node at which we first detected a mismatch.</summary>
            <remarks>Get the node at which we first detected a mismatch.</remarks>
            <returns>
            the node at which we first detected a mismatch, or
            <see langword="null"/>
            if the match was successful.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.Succeeded">
             <summary>Gets a value indicating whether the match operation succeeded.</summary>
             <remarks>Gets a value indicating whether the match operation succeeded.</remarks>
             <returns>
            
             <see langword="true"/>
             if the match operation succeeded; otherwise,
             <see langword="false"/>
             .
             </returns>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.Pattern">
            <summary>Get the tree pattern we are matching against.</summary>
            <remarks>Get the tree pattern we are matching against.</remarks>
            <returns>The tree pattern we are matching against.</returns>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.Tree">
            <summary>Get the parse tree we are trying to match to a pattern.</summary>
            <remarks>Get the parse tree we are trying to match to a pattern.</remarks>
            <returns>
            The
            <see cref="T:Antlr4.Runtime.Tree.IParseTree"/>
            we are trying to match to a pattern.
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.ToString">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:Antlr4.Runtime.Tree.Pattern.ParseTreePattern">
            <summary>
            A pattern like
            <c>&lt;ID&gt; = &lt;expr&gt;;</c>
            converted to a
            <see cref="T:Antlr4.Runtime.Tree.IParseTree"/>
            by
            <see cref="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Compile(System.String,System.Int32)"/>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.patternRuleIndex">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.PatternRuleIndex"/>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.pattern">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.Pattern"/>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.patternTree">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.PatternTree"/>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.matcher">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.Matcher"/>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.#ctor(Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher,System.String,System.Int32,Antlr4.Runtime.Tree.IParseTree)">
            <summary>
            Construct a new instance of the
            <see cref="T:Antlr4.Runtime.Tree.Pattern.ParseTreePattern"/>
            class.
            </summary>
            <param name="matcher">
            The
            <see cref="T:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher"/>
            which created this
            tree pattern.
            </param>
            <param name="pattern">The tree pattern in concrete syntax form.</param>
            <param name="patternRuleIndex">
            The parser rule which serves as the root of the
            tree pattern.
            </param>
            <param name="patternTree">
            The tree pattern in
            <see cref="T:Antlr4.Runtime.Tree.IParseTree"/>
            form.
            </param>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.Match(Antlr4.Runtime.Tree.IParseTree)">
            <summary>Match a specific parse tree against this tree pattern.</summary>
            <remarks>Match a specific parse tree against this tree pattern.</remarks>
            <param name="tree">The parse tree to match against this tree pattern.</param>
            <returns>
            A
            <see cref="T:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch"/>
            object describing the result of the
            match operation. The
            <see cref="P:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.Succeeded"/>
            method can be
            used to determine whether or not the match was successful.
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.Matches(Antlr4.Runtime.Tree.IParseTree)">
             <summary>Determine whether or not a parse tree matches this tree pattern.</summary>
             <remarks>Determine whether or not a parse tree matches this tree pattern.</remarks>
             <param name="tree">The parse tree to match against this tree pattern.</param>
             <returns>
            
             <see langword="true"/>
             if
             <paramref name="tree"/>
             is a match for the current tree
             pattern; otherwise,
             <see langword="false"/>
             .
             </returns>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.FindAll(Antlr4.Runtime.Tree.IParseTree,System.String)">
            <summary>
            Find all nodes using XPath and then try to match those subtrees against
            this tree pattern.
            </summary>
            <remarks>
            Find all nodes using XPath and then try to match those subtrees against
            this tree pattern.
            </remarks>
            <param name="tree">
            The
            <see cref="T:Antlr4.Runtime.Tree.IParseTree"/>
            to match against this pattern.
            </param>
            <param name="xpath">An expression matching the nodes</param>
            <returns>
            A collection of
            <see cref="T:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch"/>
            objects describing the
            successful matches. Unsuccessful matches are omitted from the result,
            regardless of the reason for the failure.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.Matcher">
            <summary>
            Get the
            <see cref="T:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher"/>
            which created this tree pattern.
            </summary>
            <returns>
            The
            <see cref="T:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher"/>
            which created this tree
            pattern.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.Pattern">
            <summary>Get the tree pattern in concrete syntax form.</summary>
            <remarks>Get the tree pattern in concrete syntax form.</remarks>
            <returns>The tree pattern in concrete syntax form.</returns>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.PatternRuleIndex">
            <summary>
            Get the parser rule which serves as the outermost rule for the tree
            pattern.
            </summary>
            <remarks>
            Get the parser rule which serves as the outermost rule for the tree
            pattern.
            </remarks>
            <returns>
            The parser rule which serves as the outermost rule for the tree
            pattern.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.PatternTree">
            <summary>
            Get the tree pattern as a
            <see cref="T:Antlr4.Runtime.Tree.IParseTree"/>
            . The rule and token tags from
            the pattern are present in the parse tree as terminal nodes with a symbol
            of type
            <see cref="T:Antlr4.Runtime.Tree.Pattern.RuleTagToken"/>
            or
            <see cref="T:Antlr4.Runtime.Tree.Pattern.TokenTagToken"/>
            .
            </summary>
            <returns>
            The tree pattern as a
            <see cref="T:Antlr4.Runtime.Tree.IParseTree"/>
            .
            </returns>
        </member>
        <member name="T:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher">
            <summary>
            A tree pattern matching mechanism for ANTLR
            <see cref="T:Antlr4.Runtime.Tree.IParseTree"/>
            s.
            <p>Patterns are strings of source input text with special tags representing
            token or rule references such as:</p>
            <p>
            <c>&lt;ID&gt; = &lt;expr&gt;;</c>
            </p>
            <p>Given a pattern start rule such as
            <c>statement</c>
            , this object constructs
            a
            <see cref="T:Antlr4.Runtime.Tree.IParseTree"/>
            with placeholders for the
            <c>ID</c>
            and
            <c>expr</c>
            subtree. Then the
            <see cref="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Match(Antlr4.Runtime.Tree.IParseTree,Antlr4.Runtime.Tree.Pattern.ParseTreePattern)"/>
            routines can compare an actual
            <see cref="T:Antlr4.Runtime.Tree.IParseTree"/>
            from a parse with this pattern. Tag
            <c>&lt;ID&gt;</c>
            matches
            any
            <c>ID</c>
            token and tag
            <c>&lt;expr&gt;</c>
            references the result of the
            <c>expr</c>
            rule (generally an instance of
            <c>ExprContext</c>
            .</p>
            <p>Pattern
            <c>x = 0;</c>
            is a similar pattern that matches the same pattern
            except that it requires the identifier to be
            <c>x</c>
            and the expression to
            be
            <c>0</c>
            .</p>
            <p>The
            <see cref="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Matches(Antlr4.Runtime.Tree.IParseTree,Antlr4.Runtime.Tree.Pattern.ParseTreePattern)"/>
            routines return
            <see langword="true"/>
            or
            <see langword="false"/>
            based
            upon a match for the tree rooted at the parameter sent in. The
            <see cref="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Match(Antlr4.Runtime.Tree.IParseTree,Antlr4.Runtime.Tree.Pattern.ParseTreePattern)"/>
            routines return a
            <see cref="T:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch"/>
            object that
            contains the parse tree, the parse tree pattern, and a map from tag name to
            matched nodes (more below). A subtree that fails to match, returns with
            <see cref="P:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.MismatchedNode"/>
            set to the first tree node that did not
            match.</p>
            <p>For efficiency, you can compile a tree pattern in string form to a
            <see cref="T:Antlr4.Runtime.Tree.Pattern.ParseTreePattern"/>
            object.</p>
            <p>See
            <c>TestParseTreeMatcher</c>
            for lots of examples.
            <see cref="T:Antlr4.Runtime.Tree.Pattern.ParseTreePattern"/>
            has two static helper methods:
            <see cref="M:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.FindAll(Antlr4.Runtime.Tree.IParseTree,System.String)"/>
            and
            <see cref="M:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.Match(Antlr4.Runtime.Tree.IParseTree)"/>
            that
            are easy to use but not super efficient because they create new
            <see cref="T:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher"/>
            objects each time and have to compile the
            pattern in string form before using it.</p>
            <p>The lexer and parser that you pass into the
            <see cref="T:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher"/>
            constructor are used to parse the pattern in string form. The lexer converts
            the
            <c>&lt;ID&gt; = &lt;expr&gt;;</c>
            into a sequence of four tokens (assuming lexer
            throws out whitespace or puts it on a hidden channel). Be aware that the
            input stream is reset for the lexer (but not the parser; a
            <see cref="T:Antlr4.Runtime.ParserInterpreter"/>
            is created to parse the input.). Any user-defined
            fields you have put into the lexer might get changed when this mechanism asks
            it to scan the pattern string.</p>
            <p>Normally a parser does not accept token
            <c>&lt;expr&gt;</c>
            as a valid
            <c>expr</c>
            but, from the parser passed in, we create a special version of
            the underlying grammar representation (an
            <see cref="T:Antlr4.Runtime.Atn.ATN"/>
            ) that allows imaginary
            tokens representing rules (
            <c>&lt;expr&gt;</c>
            ) to match entire rules. We call
            these <em>bypass alternatives</em>.</p>
            <p>Delimiters are
            <c>&lt;</c>
            and
            <c>&gt;</c>
            , with
            <c>\</c>
            as the escape string
            by default, but you can set them to whatever you want using
            <see cref="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.SetDelimiters(System.String,System.String,System.String)"/>
            . You must escape both start and stop strings
            <c>\&lt;</c>
            and
            <c>\&gt;</c>
            .</p>
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.lexer">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Lexer"/>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.parser">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Parser"/>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.#ctor(Antlr4.Runtime.Lexer,Antlr4.Runtime.Parser)">
            <summary>
            Constructs a
            <see cref="T:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher"/>
            or from a
            <see cref="T:Antlr4.Runtime.Lexer"/>
            and
            <see cref="T:Antlr4.Runtime.Parser"/>
            object. The lexer input stream is altered for tokenizing
            the tree patterns. The parser is used as a convenient mechanism to get
            the grammar name, plus token, rule names.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.SetDelimiters(System.String,System.String,System.String)">
            <summary>
            Set the delimiters used for marking rule and token tags within concrete
            syntax used by the tree pattern parser.
            </summary>
            <remarks>
            Set the delimiters used for marking rule and token tags within concrete
            syntax used by the tree pattern parser.
            </remarks>
            <param name="start">The start delimiter.</param>
            <param name="stop">The stop delimiter.</param>
            <param name="escapeLeft">The escape sequence to use for escaping a start or stop delimiter.</param>
            <exception>
            IllegalArgumentException
            if
            <paramref name="start"/>
            is
            <see langword="null"/>
            or empty.
            </exception>
            <exception>
            IllegalArgumentException
            if
            <paramref name="stop"/>
            is
            <see langword="null"/>
            or empty.
            </exception>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Matches(Antlr4.Runtime.Tree.IParseTree,System.String,System.Int32)">
            <summary>
            Does
            <paramref name="pattern"/>
            matched as rule
            <paramref name="patternRuleIndex"/>
            match
            <paramref name="tree"/>
            ?
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Matches(Antlr4.Runtime.Tree.IParseTree,Antlr4.Runtime.Tree.Pattern.ParseTreePattern)">
            <summary>
            Does
            <paramref name="pattern"/>
            matched as rule patternRuleIndex match tree? Pass in a
            compiled pattern instead of a string representation of a tree pattern.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Match(Antlr4.Runtime.Tree.IParseTree,System.String,System.Int32)">
            <summary>
            Compare
            <paramref name="pattern"/>
            matched as rule
            <paramref name="patternRuleIndex"/>
            against
            <paramref name="tree"/>
            and return a
            <see cref="T:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch"/>
            object that contains the
            matched elements, or the node at which the match failed.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Match(Antlr4.Runtime.Tree.IParseTree,Antlr4.Runtime.Tree.Pattern.ParseTreePattern)">
            <summary>
            Compare
            <paramref name="pattern"/>
            matched against
            <paramref name="tree"/>
            and return a
            <see cref="T:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch"/>
            object that contains the matched elements, or the
            node at which the match failed. Pass in a compiled pattern instead of a
            string representation of a tree pattern.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Compile(System.String,System.Int32)">
            <summary>
            For repeated use of a tree pattern, compile it to a
            <see cref="T:Antlr4.Runtime.Tree.Pattern.ParseTreePattern"/>
            using this method.
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Lexer">
            <summary>Used to convert the tree pattern string into a series of tokens.</summary>
            <remarks>
            Used to convert the tree pattern string into a series of tokens. The
            input stream is reset.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Parser">
            <summary>
            Used to collect to the grammar file name, token names, rule names for
            used to parse the pattern into a parse tree.
            </summary>
            <remarks>
            Used to collect to the grammar file name, token names, rule names for
            used to parse the pattern into a parse tree.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.MatchImpl(Antlr4.Runtime.Tree.IParseTree,Antlr4.Runtime.Tree.IParseTree,Antlr4.Runtime.Misc.MultiMap{System.String,Antlr4.Runtime.Tree.IParseTree})">
            <summary>
            Recursively walk
            <paramref name="tree"/>
            against
            <paramref name="patternTree"/>
            , filling
            <c>match.</c>
            <see cref="P:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.Labels"/>
            .
            </summary>
            <returns>
            the first node encountered in
            <paramref name="tree"/>
            which does not match
            a corresponding node in
            <paramref name="patternTree"/>
            , or
            <see langword="null"/>
            if the match
            was successful. The specific node returned depends on the matching
            algorithm used by the implementation, and may be overridden.
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.GetRuleTagToken(Antlr4.Runtime.Tree.IParseTree)">
             <summary>
             Is
             <paramref name="t"/>
            
             <c>(expr &lt;expr&gt;)</c>
             subtree?
             </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Split(System.String)">
            <summary>
            Split
            <c>&lt;ID&gt; = &lt;e:expr&gt; ;</c>
            into 4 chunks for tokenizing by
            <see cref="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Tokenize(System.String)"/>
            .
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Tree.Pattern.RuleTagToken">
            <summary>
            A
            <see cref="T:Antlr4.Runtime.IToken"/>
            object representing an entire subtree matched by a parser
            rule; e.g.,
            <c>&lt;expr&gt;</c>
            . These tokens are created for
            <see cref="T:Antlr4.Runtime.Tree.Pattern.TagChunk"/>
            chunks where the tag corresponds to a parser rule.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.RuleTagToken.ruleName">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.RuleTagToken.RuleName"/>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.RuleTagToken.bypassTokenType">
            <summary>The token type for the current token.</summary>
            <remarks>
            The token type for the current token. This is the token type assigned to
            the bypass alternative for the rule during ATN deserialization.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.RuleTagToken.label">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.RuleTagToken.Label"/>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.RuleTagToken.#ctor(System.String,System.Int32)">
            <summary>
            Constructs a new instance of
            <see cref="T:Antlr4.Runtime.Tree.Pattern.RuleTagToken"/>
            with the specified rule
            name and bypass token type and no label.
            </summary>
            <param name="ruleName">The name of the parser rule this rule tag matches.</param>
            <param name="bypassTokenType">The bypass token type assigned to the parser rule.</param>
            <exception>
            IllegalArgumentException
            if
            <paramref name="ruleName"/>
            is
            <see langword="null"/>
            or empty.
            </exception>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.RuleTagToken.#ctor(System.String,System.Int32,System.String)">
            <summary>
            Constructs a new instance of
            <see cref="T:Antlr4.Runtime.Tree.Pattern.RuleTagToken"/>
            with the specified rule
            name, bypass token type, and label.
            </summary>
            <param name="ruleName">The name of the parser rule this rule tag matches.</param>
            <param name="bypassTokenType">The bypass token type assigned to the parser rule.</param>
            <param name="label">
            The label associated with the rule tag, or
            <see langword="null"/>
            if
            the rule tag is unlabeled.
            </param>
            <exception>
            IllegalArgumentException
            if
            <paramref name="ruleName"/>
            is
            <see langword="null"/>
            or empty.
            </exception>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.RuleTagToken.RuleName">
            <summary>Gets the name of the rule associated with this rule tag.</summary>
            <remarks>Gets the name of the rule associated with this rule tag.</remarks>
            <returns>The name of the parser rule associated with this rule tag.</returns>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.RuleTagToken.Label">
            <summary>Gets the label associated with the rule tag.</summary>
            <remarks>Gets the label associated with the rule tag.</remarks>
            <returns>
            The name of the label associated with the rule tag, or
            <see langword="null"/>
            if this is an unlabeled rule tag.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.RuleTagToken.Channel">
            <summary>
            <inheritDoc/>
            <p>Rule tag tokens are always placed on the
            <see cref="F:Antlr4.Runtime.TokenConstants.DefaultChannel"/>
            .</p>
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.RuleTagToken.Text">
            <summary>
            <inheritDoc/>
            <p>This method returns the rule tag formatted with
            <c>&lt;</c>
            and
            <c>&gt;</c>
            delimiters.</p>
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.RuleTagToken.Type">
            <summary>
            <inheritDoc/>
            <p>Rule tag tokens have types assigned according to the rule bypass
            transitions created during ATN deserialization.</p>
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.RuleTagToken.Line">
            <summary>
            <inheritDoc/>
            <p>The implementation for
            <see cref="T:Antlr4.Runtime.Tree.Pattern.RuleTagToken"/>
            always returns 0.</p>
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.RuleTagToken.Column">
            <summary>
            <inheritDoc/>
            <p>The implementation for
            <see cref="T:Antlr4.Runtime.Tree.Pattern.RuleTagToken"/>
            always returns -1.</p>
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.RuleTagToken.TokenIndex">
            <summary>
            <inheritDoc/>
            <p>The implementation for
            <see cref="T:Antlr4.Runtime.Tree.Pattern.RuleTagToken"/>
            always returns -1.</p>
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.RuleTagToken.StartIndex">
            <summary>
            <inheritDoc/>
            <p>The implementation for
            <see cref="T:Antlr4.Runtime.Tree.Pattern.RuleTagToken"/>
            always returns -1.</p>
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.RuleTagToken.StopIndex">
            <summary>
            <inheritDoc/>
            <p>The implementation for
            <see cref="T:Antlr4.Runtime.Tree.Pattern.RuleTagToken"/>
            always returns -1.</p>
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.RuleTagToken.TokenSource">
            <summary>
            <inheritDoc/>
            <p>The implementation for
            <see cref="T:Antlr4.Runtime.Tree.Pattern.RuleTagToken"/>
            always returns
            <see langword="null"/>
            .</p>
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.RuleTagToken.InputStream">
            <summary>
            <inheritDoc/>
            <p>The implementation for
            <see cref="T:Antlr4.Runtime.Tree.Pattern.RuleTagToken"/>
            always returns
            <see langword="null"/>
            .</p>
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.RuleTagToken.ToString">
            <summary>
            <inheritDoc/>
            <p>The implementation for
            <see cref="T:Antlr4.Runtime.Tree.Pattern.RuleTagToken"/>
            returns a string of the form
            <c>ruleName:bypassTokenType</c>
            .</p>
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Tree.Pattern.TagChunk">
            <summary>Represents a placeholder tag in a tree pattern.</summary>
            <remarks>
            Represents a placeholder tag in a tree pattern. A tag can have any of the
            following forms.
            <ul>
            <li>
            <c>expr</c>
            : An unlabeled placeholder for a parser rule
            <c>expr</c>
            .</li>
            <li>
            <c>ID</c>
            : An unlabeled placeholder for a token of type
            <c>ID</c>
            .</li>
            <li>
            <c>e:expr</c>
            : A labeled placeholder for a parser rule
            <c>expr</c>
            .</li>
            <li>
            <c>id:ID</c>
            : A labeled placeholder for a token of type
            <c>ID</c>
            .</li>
            </ul>
            This class does not perform any validation on the tag or label names aside
            from ensuring that the tag is a non-null, non-empty string.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.TagChunk.tag">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.TagChunk.Tag"/>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.TagChunk.label">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.TagChunk.Label"/>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.TagChunk.#ctor(System.String)">
            <summary>
            Construct a new instance of
            <see cref="T:Antlr4.Runtime.Tree.Pattern.TagChunk"/>
            using the specified tag and
            no label.
            </summary>
            <param name="tag">
            The tag, which should be the name of a parser rule or token
            type.
            </param>
            <exception>
            IllegalArgumentException
            if
            <paramref name="tag"/>
            is
            <see langword="null"/>
            or
            empty.
            </exception>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.TagChunk.#ctor(System.String,System.String)">
            <summary>
            Construct a new instance of
            <see cref="T:Antlr4.Runtime.Tree.Pattern.TagChunk"/>
            using the specified label
            and tag.
            </summary>
            <param name="label">
            The label for the tag. If this is
            <see langword="null"/>
            , the
            <see cref="T:Antlr4.Runtime.Tree.Pattern.TagChunk"/>
            represents an unlabeled tag.
            </param>
            <param name="tag">
            The tag, which should be the name of a parser rule or token
            type.
            </param>
            <exception>
            IllegalArgumentException
            if
            <paramref name="tag"/>
            is
            <see langword="null"/>
            or
            empty.
            </exception>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.TagChunk.Tag">
            <summary>Get the tag for this chunk.</summary>
            <remarks>Get the tag for this chunk.</remarks>
            <returns>The tag for the chunk.</returns>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.TagChunk.Label">
            <summary>Get the label, if any, assigned to this chunk.</summary>
            <remarks>Get the label, if any, assigned to this chunk.</remarks>
            <returns>
            The label assigned to this chunk, or
            <see langword="null"/>
            if no label is
            assigned to the chunk.
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.TagChunk.ToString">
            <summary>This method returns a text representation of the tag chunk.</summary>
            <remarks>
            This method returns a text representation of the tag chunk. Labeled tags
            are returned in the form
            <c>label:tag</c>
            , and unlabeled tags are
            returned as just the tag name.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.Tree.Pattern.TextChunk">
            <summary>
            Represents a span of raw text (concrete syntax) between tags in a tree
            pattern string.
            </summary>
            <remarks>
            Represents a span of raw text (concrete syntax) between tags in a tree
            pattern string.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.TextChunk.text">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.TextChunk.Text"/>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.TextChunk.#ctor(System.String)">
            <summary>
            Constructs a new instance of
            <see cref="T:Antlr4.Runtime.Tree.Pattern.TextChunk"/>
            with the specified text.
            </summary>
            <param name="text">The text of this chunk.</param>
            <exception>
            IllegalArgumentException
            if
            <paramref name="text"/>
            is
            <see langword="null"/>
            .
            </exception>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.TextChunk.Text">
            <summary>Gets the raw text of this chunk.</summary>
            <remarks>Gets the raw text of this chunk.</remarks>
            <returns>The text of the chunk.</returns>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.TextChunk.ToString">
            <summary>
            <inheritDoc/>
            <p>The implementation for
            <see cref="T:Antlr4.Runtime.Tree.Pattern.TextChunk"/>
            returns the result of
            <see cref="P:Antlr4.Runtime.Tree.Pattern.TextChunk.Text"/>
            in single quotes.</p>
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Tree.Pattern.TokenTagToken">
            <summary>
            A
            <see cref="T:Antlr4.Runtime.IToken"/>
            object representing a token of a particular type; e.g.,
            <c>&lt;ID&gt;</c>
            . These tokens are created for
            <see cref="T:Antlr4.Runtime.Tree.Pattern.TagChunk"/>
            chunks where the
            tag corresponds to a lexer rule or token type.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.TokenTagToken.tokenName">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.TokenTagToken.TokenName"/>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.TokenTagToken.label">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.TokenTagToken.Label"/>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.TokenTagToken.#ctor(System.String,System.Int32)">
            <summary>
            Constructs a new instance of
            <see cref="T:Antlr4.Runtime.Tree.Pattern.TokenTagToken"/>
            for an unlabeled tag
            with the specified token name and type.
            </summary>
            <param name="tokenName">The token name.</param>
            <param name="type">The token type.</param>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.TokenTagToken.#ctor(System.String,System.Int32,System.String)">
            <summary>
            Constructs a new instance of
            <see cref="T:Antlr4.Runtime.Tree.Pattern.TokenTagToken"/>
            with the specified
            token name, type, and label.
            </summary>
            <param name="tokenName">The token name.</param>
            <param name="type">The token type.</param>
            <param name="label">
            The label associated with the token tag, or
            <see langword="null"/>
            if
            the token tag is unlabeled.
            </param>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.TokenTagToken.TokenName">
            <summary>Gets the token name.</summary>
            <remarks>Gets the token name.</remarks>
            <returns>The token name.</returns>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.TokenTagToken.Label">
            <summary>Gets the label associated with the rule tag.</summary>
            <remarks>Gets the label associated with the rule tag.</remarks>
            <returns>
            The name of the label associated with the rule tag, or
            <see langword="null"/>
            if this is an unlabeled rule tag.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.TokenTagToken.Text">
            <summary>
            <inheritDoc/>
            <p>The implementation for
            <see cref="T:Antlr4.Runtime.Tree.Pattern.TokenTagToken"/>
            returns the token tag
            formatted with
            <c>&lt;</c>
            and
            <c>&gt;</c>
            delimiters.</p>
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.TokenTagToken.ToString">
            <summary>
            <inheritDoc/>
            <p>The implementation for
            <see cref="T:Antlr4.Runtime.Tree.Pattern.TokenTagToken"/>
            returns a string of the form
            <c>tokenName:type</c>
            .</p>
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Tree.Trees">
            <summary>A set of utility routines useful for all kinds of ANTLR trees.</summary>
            <remarks>A set of utility routines useful for all kinds of ANTLR trees.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Trees.ToStringTree(Antlr4.Runtime.Tree.ITree)">
            <summary>Print out a whole tree in LISP form.</summary>
            <remarks>
            Print out a whole tree in LISP form.
            <see cref="M:Antlr4.Runtime.Tree.Trees.GetNodeText(Antlr4.Runtime.Tree.ITree,Antlr4.Runtime.Parser)"/>
            is used on the
            node payloads to get the text for the nodes.  Detect
            parse trees and extract data appropriately.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Trees.ToStringTree(Antlr4.Runtime.Tree.ITree,Antlr4.Runtime.Parser)">
            <summary>Print out a whole tree in LISP form.</summary>
            <remarks>
            Print out a whole tree in LISP form.
            <see cref="M:Antlr4.Runtime.Tree.Trees.GetNodeText(Antlr4.Runtime.Tree.ITree,Antlr4.Runtime.Parser)"/>
            is used on the
            node payloads to get the text for the nodes.  Detect
            parse trees and extract data appropriately.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Trees.ToStringTree(Antlr4.Runtime.Tree.ITree,System.Collections.Generic.IList{System.String})">
            <summary>Print out a whole tree in LISP form.</summary>
            <remarks>
            Print out a whole tree in LISP form.
            <see cref="M:Antlr4.Runtime.Tree.Trees.GetNodeText(Antlr4.Runtime.Tree.ITree,Antlr4.Runtime.Parser)"/>
            is used on the
            node payloads to get the text for the nodes.  Detect
            parse trees and extract data appropriately.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Trees.GetChildren(Antlr4.Runtime.Tree.ITree)">
            <summary>Return ordered list of all children of this node</summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Trees.GetAncestors(Antlr4.Runtime.Tree.ITree)">
            <summary>Return a list of all ancestors of this node.</summary>
            <remarks>
            Return a list of all ancestors of this node.  The first node of
            list is the root and the last is the parent of this node.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.Tree.Xpath.XPath">
            <summary>
            Represent a subset of XPath XML path syntax for use in identifying nodes in
            parse trees.
            </summary>
            <remarks>
            Represent a subset of XPath XML path syntax for use in identifying nodes in
            parse trees.
            <p>
            Split path into words and separators
            <c>/</c>
            and
            <c>//</c>
            via ANTLR
            itself then walk path elements from left to right. At each separator-word
            pair, find set of nodes. Next stage uses those as work list.</p>
            <p>
            The basic interface is
            <see cref="M:Antlr4.Runtime.Tree.Xpath.XPath.FindAll(Antlr4.Runtime.Tree.IParseTree,System.String,Antlr4.Runtime.Parser)">ParseTree.findAll</see>
            <c>(tree, pathString, parser)</c>
            .
            But that is just shorthand for:</p>
            <pre>
            <see cref="T:Antlr4.Runtime.Tree.Xpath.XPath"/>
            p = new
            <see cref="M:Antlr4.Runtime.Tree.Xpath.XPath.#ctor(Antlr4.Runtime.Parser,System.String)">XPath</see>
            (parser, pathString);
            return p.
            <see cref="M:Antlr4.Runtime.Tree.Xpath.XPath.Evaluate(Antlr4.Runtime.Tree.IParseTree)">evaluate</see>
            (tree);
            </pre>
            <p>
            See
            <c>org.antlr.v4.test.TestXPath</c>
            for descriptions. In short, this
            allows operators:</p>
            <dl>
            <dt>/</dt> <dd>root</dd>
            <dt>//</dt> <dd>anywhere</dd>
            <dt>!</dt> <dd>invert; this must appear directly after root or anywhere
            operator</dd>
            </dl>
            <p>
            and path elements:</p>
            <dl>
            <dt>ID</dt> <dd>token name</dd>
            <dt>'string'</dt> <dd>any string literal token from the grammar</dd>
            <dt>expr</dt> <dd>rule name</dd>
            <dt>*</dt> <dd>wildcard matching any node</dd>
            </dl>
            <p>
            Whitespace is not allowed.</p>
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Xpath.XPath.GetXPathElement(Antlr4.Runtime.IToken,System.Boolean)">
            <summary>
            Convert word like
            <c>*</c>
            or
            <c>ID</c>
            or
            <c>expr</c>
            to a path
            element.
            <paramref name="anywhere"/>
            is
            <see langword="true"/>
            if
            <c>//</c>
            precedes the
            word.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Xpath.XPath.Evaluate(Antlr4.Runtime.Tree.IParseTree)">
            <summary>
            Return a list of all nodes starting at
            <paramref name="t"/>
            as root that satisfy the
            path. The root
            <c>/</c>
            is relative to the node passed to
            <see cref="M:Antlr4.Runtime.Tree.Xpath.XPath.Evaluate(Antlr4.Runtime.Tree.IParseTree)"/>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Xpath.XPathElement.#ctor(System.String)">
            <summary>
            Construct element like
            <c>/ID</c>
            or
            <c>ID</c>
            or
            <c>/*</c>
            etc...
            op is null if just node
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Xpath.XPathElement.Evaluate(Antlr4.Runtime.Tree.IParseTree)">
            <summary>
            Given tree rooted at
            <paramref name="t"/>
            return all nodes matched by this path
            element.
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Tree.Xpath.XPathRuleAnywhereElement">
            <summary>
            Either
            <c>ID</c>
            at start of path or
            <c>...//ID</c>
            in middle of path.
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.UnbufferedCharStream">
            <summary>Do not buffer up the entire char stream.</summary>
            <remarks>
            Do not buffer up the entire char stream. It does keep a small buffer
            for efficiency and also buffers while a mark exists (set by the
            lookahead prediction in parser). "Unbuffered" here refers to fact
            that it doesn't buffer all data, not that's it's on demand loading of char.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedCharStream.data">
            <summary>A moving window buffer of the data being scanned.</summary>
            <remarks>
            A moving window buffer of the data being scanned. While there's a marker,
            we keep adding to buffer. Otherwise,
            <see cref="M:Antlr4.Runtime.UnbufferedCharStream.Consume">consume()</see>
            resets so
            we start filling at index 0 again.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedCharStream.n">
            <summary>
            The number of characters currently in
            <see cref="F:Antlr4.Runtime.UnbufferedCharStream.data">data</see>
            .
            <p>This is not the buffer capacity, that's
            <c>data.length</c>
            .</p>
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedCharStream.p">
            <summary>
            0..n-1 index into
            <see cref="F:Antlr4.Runtime.UnbufferedCharStream.data">data</see>
            of next character.
            <p>The
            <c>LA(1)</c>
            character is
            <c>data[p]</c>
            . If
            <c>p == n</c>
            , we are
            out of buffered characters.</p>
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedCharStream.numMarkers">
            <summary>
            Count up with
            <see cref="M:Antlr4.Runtime.UnbufferedCharStream.Mark">mark()</see>
            and down with
            <see cref="M:Antlr4.Runtime.UnbufferedCharStream.Release(System.Int32)">release()</see>
            . When we
            <c>release()</c>
            the last mark,
            <c>numMarkers</c>
            reaches 0 and we reset the buffer. Copy
            <c>data[p]..data[n-1]</c>
            to
            <c>data[0]..data[(n-1)-p]</c>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedCharStream.lastChar">
            <summary>
            This is the
            <c>LA(-1)</c>
            character for the current position.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedCharStream.lastCharBufferStart">
            <summary>
            When
            <c>numMarkers &gt; 0</c>
            , this is the
            <c>LA(-1)</c>
            character for the
            first character in
            <see cref="F:Antlr4.Runtime.UnbufferedCharStream.data">data</see>
            . Otherwise, this is unspecified.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedCharStream.currentCharIndex">
            <summary>Absolute character index.</summary>
            <remarks>
            Absolute character index. It's the index of the character about to be
            read via
            <c>LA(1)</c>
            . Goes from 0 to the number of characters in the
            entire stream, although the stream size is unknown before the end is
            reached.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedCharStream.name">
            <summary>The name or source of this char stream.</summary>
            <remarks>The name or source of this char stream.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.UnbufferedCharStream.#ctor">
            <summary>Useful for subclasses that pull char from other than this.input.</summary>
            <remarks>Useful for subclasses that pull char from other than this.input.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.UnbufferedCharStream.#ctor(System.Int32)">
            <summary>Useful for subclasses that pull char from other than this.input.</summary>
            <remarks>Useful for subclasses that pull char from other than this.input.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.UnbufferedCharStream.Sync(System.Int32)">
            <summary>
            Make sure we have 'need' elements from current position
            <see cref="F:Antlr4.Runtime.UnbufferedCharStream.p">p</see>
            .
            Last valid
            <c>p</c>
            index is
            <c>data.length-1</c>
            .
            <c>p+need-1</c>
            is
            the char index 'need' elements ahead. If we need 1 element,
            <c>(p+1-1)==p</c>
            must be less than
            <c>data.length</c>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.UnbufferedCharStream.Fill(System.Int32)">
            <summary>
            Add
            <paramref name="n"/>
            characters to the buffer. Returns the number of characters
            actually added to the buffer. If the return value is less than
            <paramref name="n"/>
            ,
            then EOF was reached before
            <paramref name="n"/>
            characters could be added.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.UnbufferedCharStream.NextChar">
            <summary>
            Override to provide different source of characters than
            <see cref="F:Antlr4.Runtime.UnbufferedCharStream.input">input</see>
            .
            </summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Antlr4.Runtime.UnbufferedCharStream.Mark">
            <summary>Return a marker that we can release later.</summary>
            <remarks>
            Return a marker that we can release later.
            <p>The specific marker value used for this class allows for some level of
            protection against misuse where
            <c>seek()</c>
            is called on a mark or
            <c>release()</c>
            is called in the wrong order.</p>
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.UnbufferedCharStream.Release(System.Int32)">
            <summary>Decrement number of markers, resetting buffer if we hit 0.</summary>
            <remarks>Decrement number of markers, resetting buffer if we hit 0.</remarks>
            <param name="marker"/>
        </member>
        <member name="M:Antlr4.Runtime.UnbufferedCharStream.Seek(System.Int32)">
            <summary>
            Seek to absolute character index, which might not be in the current
            sliding window.
            </summary>
            <remarks>
            Seek to absolute character index, which might not be in the current
            sliding window.  Move
            <c>p</c>
            to
            <c>index-bufferStartIndex</c>
            .
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedTokenStream.tokens">
            <summary>A moving window buffer of the data being scanned.</summary>
            <remarks>
            A moving window buffer of the data being scanned. While there's a marker,
            we keep adding to buffer. Otherwise,
            <see cref="M:Antlr4.Runtime.UnbufferedTokenStream.Consume">consume()</see>
            resets so
            we start filling at index 0 again.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedTokenStream.n">
            <summary>
            The number of tokens currently in
            <see cref="F:Antlr4.Runtime.UnbufferedTokenStream.tokens">tokens</see>
            .
            <p>This is not the buffer capacity, that's
            <c>tokens.length</c>
            .</p>
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedTokenStream.p">
            <summary>
            0..n-1 index into
            <see cref="F:Antlr4.Runtime.UnbufferedTokenStream.tokens">tokens</see>
            of next token.
            <p>The
            <c>LT(1)</c>
            token is
            <c>tokens[p]</c>
            . If
            <c>p == n</c>
            , we are
            out of buffered tokens.</p>
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedTokenStream.numMarkers">
            <summary>
            Count up with
            <see cref="M:Antlr4.Runtime.UnbufferedTokenStream.Mark">mark()</see>
            and down with
            <see cref="M:Antlr4.Runtime.UnbufferedTokenStream.Release(System.Int32)">release()</see>
            . When we
            <c>release()</c>
            the last mark,
            <c>numMarkers</c>
            reaches 0 and we reset the buffer. Copy
            <c>tokens[p]..tokens[n-1]</c>
            to
            <c>tokens[0]..tokens[(n-1)-p]</c>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedTokenStream.lastToken">
            <summary>
            This is the
            <c>LT(-1)</c>
            token for the current position.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedTokenStream.lastTokenBufferStart">
            <summary>
            When
            <c>numMarkers &gt; 0</c>
            , this is the
            <c>LT(-1)</c>
            token for the
            first token in
            <see cref="F:Antlr4.Runtime.UnbufferedTokenStream.tokens"/>
            . Otherwise, this is
            <see langword="null"/>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedTokenStream.currentTokenIndex">
            <summary>Absolute token index.</summary>
            <remarks>
            Absolute token index. It's the index of the token about to be read via
            <c>LT(1)</c>
            . Goes from 0 to the number of tokens in the entire stream,
            although the stream size is unknown before the end is reached.
            <p>This value is used to set the token indexes if the stream provides tokens
            that implement
            <see cref="T:Antlr4.Runtime.IWritableToken"/>
            .</p>
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.UnbufferedTokenStream.Sync(System.Int32)">
            <summary>
            Make sure we have 'need' elements from current position
            <see cref="F:Antlr4.Runtime.UnbufferedTokenStream.p">p</see>
            . Last valid
            <c>p</c>
            index is
            <c>tokens.length-1</c>
            .
            <c>p+need-1</c>
            is the tokens index 'need' elements
            ahead.  If we need 1 element,
            <c>(p+1-1)==p</c>
            must be less than
            <c>tokens.length</c>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.UnbufferedTokenStream.Fill(System.Int32)">
            <summary>
            Add
            <paramref name="n"/>
            elements to the buffer. Returns the number of tokens
            actually added to the buffer. If the return value is less than
            <paramref name="n"/>
            ,
            then EOF was reached before
            <paramref name="n"/>
            tokens could be added.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.UnbufferedTokenStream.Mark">
            <summary>Return a marker that we can release later.</summary>
            <remarks>
            Return a marker that we can release later.
            <p>The specific marker value used for this class allows for some level of
            protection against misuse where
            <c>seek()</c>
            is called on a mark or
            <c>release()</c>
            is called in the wrong order.</p>
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.Vocabulary">
            <summary>
            This class provides a default implementation of the
            <see cref="T:Antlr4.Runtime.IVocabulary"/>
            interface.
            </summary>
            <author>Sam Harwell</author>
        </member>
        <member name="F:Antlr4.Runtime.Vocabulary.EmptyVocabulary">
            <summary>
            Gets an empty
            <see cref="T:Antlr4.Runtime.IVocabulary"/>
            instance.
            <p>
            No literal or symbol names are assigned to token types, so
            <see cref="M:Antlr4.Runtime.Vocabulary.GetDisplayName(System.Int32)"/>
            returns the numeric value for all tokens
            except
            <see cref="F:Antlr4.Runtime.TokenConstants.EOF"/>
            .</p>
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Vocabulary.#ctor(System.String[],System.String[])">
            <summary>
            Constructs a new instance of
            <see cref="T:Antlr4.Runtime.Vocabulary"/>
            from the specified
            literal and symbolic token names.
            </summary>
            <param name="literalNames">
            The literal names assigned to tokens, or
            <see langword="null"/>
            if no literal names are assigned.
            </param>
            <param name="symbolicNames">
            The symbolic names assigned to tokens, or
            <see langword="null"/>
            if no symbolic names are assigned.
            </param>
            <seealso cref="M:Antlr4.Runtime.Vocabulary.GetLiteralName(System.Int32)"/>
            <seealso cref="M:Antlr4.Runtime.Vocabulary.GetSymbolicName(System.Int32)"/>
        </member>
        <member name="M:Antlr4.Runtime.Vocabulary.#ctor(System.String[],System.String[],System.String[])">
            <summary>
            Constructs a new instance of
            <see cref="T:Antlr4.Runtime.Vocabulary"/>
            from the specified
            literal, symbolic, and display token names.
            </summary>
            <param name="literalNames">
            The literal names assigned to tokens, or
            <see langword="null"/>
            if no literal names are assigned.
            </param>
            <param name="symbolicNames">
            The symbolic names assigned to tokens, or
            <see langword="null"/>
            if no symbolic names are assigned.
            </param>
            <param name="displayNames">
            The display names assigned to tokens, or
            <see langword="null"/>
            to use the values in
            <paramref name="literalNames"/>
            and
            <paramref name="symbolicNames"/>
            as
            the source of display names, as described in
            <see cref="M:Antlr4.Runtime.Vocabulary.GetDisplayName(System.Int32)"/>
            .
            </param>
            <seealso cref="M:Antlr4.Runtime.Vocabulary.GetLiteralName(System.Int32)"/>
            <seealso cref="M:Antlr4.Runtime.Vocabulary.GetSymbolicName(System.Int32)"/>
            <seealso cref="M:Antlr4.Runtime.Vocabulary.GetDisplayName(System.Int32)"/>
        </member>
        <member name="M:Antlr4.Runtime.Vocabulary.getMaxTokenType">
            <summary>
            Returns the highest token type value. It can be used to iterate from
            zero to that number, inclusively, thus querying all stored entries.
            </summary>
        </member>
    </members>
</doc>
